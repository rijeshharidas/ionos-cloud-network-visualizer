<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IONOS Cloud Network Visualizer</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' rx='7' fill='%23003D8F'/%3E%3Ccircle cx='10' cy='12' r='2.5' fill='%2311C7E6'/%3E%3Ccircle cx='22' cy='12' r='2.5' fill='%2311C7E6'/%3E%3Ccircle cx='16' cy='22' r='2.5' fill='%2311C7E6'/%3E%3Ccircle cx='16' cy='7' r='1.5' fill='%2311C7E6' opacity='.6'/%3E%3Cline x1='10' y1='12' x2='22' y2='12' stroke='%2311C7E6' stroke-width='1.2' opacity='.7'/%3E%3Cline x1='10' y1='12' x2='16' y2='22' stroke='%2311C7E6' stroke-width='1.2' opacity='.7'/%3E%3Cline x1='22' y1='12' x2='16' y2='22' stroke='%2311C7E6' stroke-width='1.2' opacity='.7'/%3E%3Cline x1='10' y1='12' x2='16' y2='7' stroke='%2311C7E6' stroke-width='1' opacity='.4'/%3E%3Cline x1='22' y1='12' x2='16' y2='7' stroke='%2311C7E6' stroke-width='1' opacity='.4'/%3E%3C/svg%3E">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
<style>
  :root {
    --bg-primary: #001B41;
    --bg-secondary: #00264d;
    --bg-tertiary: #003366;
    --bg-hover: #004080;
    --text-primary: #f1f5f9;
    --text-secondary: #a0c4e8;
    --text-muted: #6a9ec8;
    --border: #1a4a7a;
    --accent: #11C7E6;
    --accent-hover: #0ea8c4;
    --accent-glow: rgba(17, 199, 230, 0.15);
    --ionos-amber: #FFAA00;
    --success: #10b981;
    --warning: #FFAA00;
    --danger: #ef4444;
    --sidebar-width: 300px;
    --detail-width: 380px;
  }

  html[data-theme="light"] {
    --bg-primary: #ffffff;
    --bg-secondary: #f8f9fa;
    --bg-tertiary: #e8ecf1;
    --bg-hover: #e0e8f0;
    --text-primary: #0f172a;
    --text-secondary: #1e293b;
    --text-muted: #64748b;
    --border: #cbd5e1;
    --accent: #0284c7;
    --accent-hover: #0369a1;
    --accent-glow: rgba(2, 132, 199, 0.12);
  }
  html[data-theme="light"] #mapBackground .leaflet-tile-pane { filter: grayscale(0.05) brightness(1.02) contrast(1.05); }
  html[data-theme="light"] #mapBackground.overview-mode.pre-login .leaflet-tile-pane { filter: brightness(0.92); }
  html[data-theme="light"] #mapBackground.overview-mode.pre-login { opacity: 0.6; }
  html[data-theme="light"] .map-cluster-bubble { box-shadow: 0 4px 16px rgba(0,0,0,0.15); }
  html[data-theme="light"] .toast { box-shadow: 0 4px 12px rgba(0,0,0,0.15); }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    height: 100vh;
    overflow: hidden;
    display: flex;
  }

  /* ---- Sidebar ---- */
  .sidebar {
    width: var(--sidebar-width);
    background: var(--bg-secondary);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--bg-tertiary) transparent;
  }
  .sidebar::-webkit-scrollbar { width: 6px; }
  .sidebar::-webkit-scrollbar-track { background: transparent; }
  .sidebar::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 3px; }
  .sidebar::-webkit-scrollbar-thumb:hover { background: var(--border); }

  .sidebar-header {
    padding: 14px 20px 12px;
    border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, rgba(17, 199, 230, 0.06) 0%, transparent 100%);
  }

  .sidebar-header .brand-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .sidebar-header .brand-logo {
    flex-shrink: 0;
    color: var(--text-primary);
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .sidebar-header .brand-logo svg { display: block; }

  .sidebar-header .brand-title {
    flex: 1;
    min-width: 0;
  }

  .sidebar-header h1 {
    font-size: 15px;
    font-weight: 700;
    color: var(--text-primary);
    letter-spacing: -0.3px;
    line-height: 1.15;
    margin: 0;
  }

  .sidebar-header h1 span.brand-cloud {
    color: var(--accent);
  }

  .sidebar-header .brand-subtitle {
    font-size: 10px;
    color: var(--text-muted);
    font-weight: 500;
    letter-spacing: 1.2px;
    margin-top: 0;
    text-transform: uppercase;
  }

  .sidebar-header .header-controls {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
  }

  .sidebar-section {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }

  .sidebar-section label {
    display: block;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    margin-bottom: 8px;
  }

  input[type="password"], input[type="text"], select {
    width: 100%;
    padding: 8px 12px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 13px;
    outline: none;
    transition: border-color 0.2s;
  }
  .sidebar-section select {
    font-size: 12px;
    padding: 6px 10px;
  }
  .sidebar-section select option {
    font-size: 12px;
    padding: 4px 8px;
  }

  input:focus, select:focus { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent-glow); }
  select { cursor: pointer; }

  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    width: 100%;
    margin-top: 8px;
  }

  .btn-primary { background: var(--accent); color: white; }
  .btn-primary:hover { background: var(--accent-hover); }
  .btn-primary:disabled { background: var(--bg-tertiary); color: var(--text-muted); cursor: not-allowed; }
  .btn-disconnect { background: rgba(239,68,68,0.15); color: #f87171; border: 1px solid rgba(239,68,68,0.3); }
  .btn-disconnect:hover { background: rgba(239,68,68,0.25); color: #fca5a5; }
  .view-mode-btn { border: 1px solid var(--border); transition: all 0.2s; }
  .view-mode-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
  .view-mode-btn:not(.active) { background: var(--bg-tertiary); color: var(--text-secondary); }
  .btn-sm { padding: 5px 6px; font-size: 11px; }
  .view-mode-group { display: flex; gap: 4px; margin-bottom: 8px; }
  .view-mode-group .view-mode-btn { flex: 1; }
  .vdc-label-bg { fill: var(--bg-secondary); fill-opacity: 0.7; rx: 6; }
  .vdc-label-text { fill: var(--text-primary); font-size: 13px; font-weight: 600; font-family: 'Inter', sans-serif; }
  .vdc-toggle { cursor: pointer; fill: var(--text-muted); font-size: 14px; font-family: 'Inter', sans-serif; }
  .vdc-toggle:hover { fill: var(--accent); }
  .vdc-boundary-collapsed { stroke-opacity: 0.25 !important; }
  .vdc-collapsed-label { fill: var(--text-muted); font-size: 12px; font-style: italic; font-family: 'Inter', sans-serif; }
  .btn-secondary { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border); }
  .btn-secondary:hover { background: var(--bg-hover); }

  /* ---- Legend (unified resources) ---- */
  .legend-list { list-style: none; display: grid; grid-template-columns: 1fr 1fr; gap: 0; }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    margin: 0;
    font-size: 12px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s;
    border-radius: 6px;
  }
  .legend-item:hover, .legend-item:focus-visible { color: var(--text-primary); background: var(--bg-tertiary); }
  .legend-item.dimmed { opacity: 0.3; }
  .legend-icon { width: 22px; height: 22px; flex-shrink: 0; }
  .legend-count {
    margin-left: auto;
    font-size: 11px;
    color: var(--text-muted);
    background: var(--bg-primary);
    padding: 1px 6px;
    border-radius: 10px;
  }

  /* ---- Main Canvas ---- */
  .main-area { flex: 1; position: relative; overflow: hidden; }
  .main-area svg { width: 100%; height: 100%; display: block; position: relative; z-index: 1; }

  /* ---- Map Background (passive behind topology) ---- */
  #mapBackground {
    position: absolute; inset: 0; z-index: 0;
    opacity: 0; transition: opacity 0.6s ease, z-index 0s;
    pointer-events: none; background: var(--bg-primary);
  }
  /* Override Leaflet default #ddd background so unloaded tiles blend with the app theme */
  #mapBackground.leaflet-container { background: var(--bg-primary); }
  #mapBackground.visible { opacity: 0.85; }
  #mapBackground .leaflet-control-container { display: none; }
  #mapBackground .leaflet-tile-pane { filter: grayscale(0.1) brightness(1.1) contrast(1.15); }

  /* ---- Map Overview Mode (interactive, above SVG) ---- */
  #mapBackground.overview-mode {
    opacity: 1; z-index: 2; pointer-events: auto;
  }
  #mapBackground.overview-mode .leaflet-control-container { display: block; }
  #mapBackground.overview-mode .leaflet-tile-pane { filter: none; }
  /* Pre-login: dim map so onboarding card stands out */
  #mapBackground.overview-mode.pre-login { opacity: 0.45; }
  #mapBackground.overview-mode.pre-login .leaflet-tile-pane { filter: brightness(0.7); }
  #graphSvg.hidden-for-map { opacity: 0; pointer-events: none; transition: opacity 0.4s ease; }

  /* Cluster bubble markers */
  .map-cluster-bubble {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: var(--bg-secondary); border: 2px solid var(--accent);
    border-radius: 50%; cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    text-align: center;
  }
  .map-cluster-bubble:hover {
    transform: scale(1.12);
    box-shadow: 0 6px 24px rgba(17,199,230,0.35);
    border-color: #fff;
  }
  .map-cluster-flag { font-size: 20px; line-height: 1; }
  .map-cluster-name { font-size: 10px; font-weight: 600; color: var(--text-primary); line-height: 1.2; margin-top: 2px; }
  .map-cluster-count {
    font-size: 9px; color: var(--text-muted);
    background: var(--bg-primary); padding: 1px 6px; border-radius: 8px; margin-top: 2px;
  }

  /* Individual VDC markers (shown after zooming into a region) */
  .map-vdc-marker {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: var(--bg-secondary); border: 2px solid var(--accent);
    border-radius: 50%; cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    text-align: center;
  }
  .map-vdc-marker:hover {
    transform: scale(1.12);
    box-shadow: 0 6px 24px rgba(17,199,230,0.35);
    border-color: #fff;
  }
  .map-vdc-marker .map-cluster-flag { font-size: 18px; }
  .map-vdc-marker .map-cluster-name { font-size: 9px; max-width: 68px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

  /* Billing traffic panel on Global Map */
  .map-billing-panel {
    position: absolute; top: 12px; right: 12px; z-index: 1200;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 10px; padding: 10px 14px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    font-size: 11px; min-width: 200px; max-width: 280px;
    max-height: 50vh; overflow-y: auto;
    backdrop-filter: blur(12px);
    transition: opacity 0.3s ease;
  }
  .map-billing-panel.hidden { display: none; }
  .map-billing-panel h4 {
    font-size: 11px; font-weight: 700; color: var(--text-primary);
    margin: 0 0 8px 0; display: flex; align-items: center; gap: 6px;
  }
  .map-billing-panel h4 svg { opacity: 0.6; }
  .mbp-table { width: 100%; border-collapse: collapse; }
  .mbp-table th {
    font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px;
    color: var(--text-muted); font-weight: 600;
    padding: 2px 0 4px 0; border-bottom: 1px solid var(--border);
    text-align: right;
  }
  .mbp-table th:first-child { text-align: left; }
  .mbp-table td {
    padding: 4px 0; font-size: 11px; font-family: 'JetBrains Mono', monospace;
    text-align: right; color: var(--text-secondary);
  }
  .mbp-table td:first-child {
    text-align: left; font-family: inherit; font-weight: 500;
    color: var(--text-primary); max-width: 120px;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
  }
  .mbp-table tr:hover td { color: var(--text-primary); }
  .mbp-table tr.mbp-total td {
    border-top: 1px solid var(--border); font-weight: 700;
    color: var(--text-primary); padding-top: 6px;
  }
  .mbp-in { color: #4fc3f7; }
  .mbp-out { color: #ff8a65; }
  .mbp-table tr.mbp-total .mbp-in { color: #4fc3f7; }
  .mbp-table tr.mbp-total .mbp-out { color: #ff8a65; }

  /* Available DC location markers — compact flag + city name, color-coded border */
  .map-available-loc {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    width: 48px; height: 48px;
    border-radius: 50%;
    border: 1.5px solid rgba(17,199,230,0.8);
    background: rgba(25,28,38,0.8);
    opacity: 0.9;
    text-align: center;
    box-shadow: 0 0 8px rgba(17,199,230,0.15), 0 2px 8px rgba(0,0,0,0.4);
    transition: all 0.2s;
    cursor: pointer;
  }
  .map-available-loc:hover { opacity: 1; transform: scale(1.08); }
  .map-available-loc.cloud-private { border-color: rgba(187,134,252,0.8); box-shadow: 0 0 8px rgba(187,134,252,0.15), 0 2px 8px rgba(0,0,0,0.4); }
  .map-available-loc.cloud-both { border-color: rgba(160,180,255,0.8); box-shadow: 0 0 8px rgba(160,180,255,0.15), 0 2px 8px rgba(0,0,0,0.4); }
  .map-available-flag { font-size: 16px; line-height: 1; }
  .map-available-name { font-size: 7.5px; font-weight: 600; color: rgba(255,255,255,0.8); line-height: 1.1; margin-top: 1px; white-space: nowrap; }

  /* Dimmed variant — when shown alongside active cluster bubbles */
  .map-available-loc.dimmed {
    width: 36px; height: 36px;
    opacity: 0.45;
    border-style: dashed;
    border-width: 1px;
    box-shadow: none;
    background: rgba(25,28,38,0.6);
  }
  .map-available-loc.dimmed .map-available-flag { font-size: 13px; }
  .map-available-loc.dimmed .map-available-name { font-size: 6.5px; color: rgba(255,255,255,0.5); }
  .map-available-loc.dimmed:hover { opacity: 0.8; transform: scale(1.1); }

  /* Tooltip for DC location markers */
  .map-loc-tooltip {
    background: var(--bg-secondary) !important; border: 1px solid var(--border) !important;
    border-radius: 8px !important; padding: 8px 12px !important;
    box-shadow: 0 4px 16px rgba(0,0,0,0.5) !important;
    color: var(--text-primary) !important; font-family: inherit !important;
    font-size: 11px !important; line-height: 1.4 !important;
    max-width: 220px !important;
  }
  .map-loc-tooltip .leaflet-tooltip-arrow { display: none; }
  .map-loc-tooltip .tt-city { font-size: 12px; font-weight: 700; margin-bottom: 4px; }
  .map-loc-tooltip .tt-cloud { font-size: 10px; font-weight: 600; margin-bottom: 3px; }
  .map-loc-tooltip .tt-cloud.tt-public { color: #11C7E6; }
  .map-loc-tooltip .tt-cloud.tt-private { color: #BB86FC; }
  .map-loc-tooltip .tt-cloud.tt-both { color: #A0B4FF; }
  /* Back to overview button */
  .map-back-btn {
    position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
    z-index: 10; background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 20px; padding: 6px 16px; color: var(--text-primary);
    font-size: 12px; font-weight: 600; cursor: pointer;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    display: none; align-items: center; gap: 6px; transition: all 0.2s;
  }
  .map-back-btn:hover { background: var(--bg-tertiary); border-color: var(--accent); }
  .map-back-btn.visible { display: flex; }

  .empty-state {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: var(--text-muted);
    pointer-events: auto;
    z-index: 3;
  }
  .empty-state .empty-icon { font-size: 48px; margin-bottom: 16px; opacity: 0.3; }
  .empty-state h2 { font-size: 18px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; }
  .empty-state p { font-size: 13px; line-height: 1.5; max-width: 320px; margin: 0 auto; }

  /* ---- Onboarding ---- */
  .onboarding { max-width: 440px; text-align: center; }
  .onboarding-header { margin-bottom: 24px; }
  .onboarding-header svg { margin: 0 auto 8px; display: block; color: var(--text-primary); }
  .onboarding-header .onboarding-appname { font-size: 15px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; letter-spacing: -0.2px; }
  .onboarding-header p { font-size: 13px; color: var(--text-muted); margin: 0 auto; max-width: none; text-align: center; }
  .onboarding-steps { display: flex; flex-direction: column; gap: 10px; text-align: left; }
  .onboarding-step { display: flex; gap: 12px; align-items: flex-start; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px; padding: 12px 14px; transition: border-color 0.2s; }
  .onboarding-step .step-number { margin-top: 2px; }
  .onboarding-step:hover { border-color: var(--accent); }
  .step-number { width: 26px; height: 26px; border-radius: 50%; background: var(--accent); color: white; font-size: 12px; font-weight: 700; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
  .step-content { flex: 1; min-width: 0; }
  .step-title { font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 1px; }
  .step-desc { font-size: 11px; color: var(--text-secondary); line-height: 1.4; }
  .step-desc a { color: var(--accent); text-decoration: none; }
  .step-desc a:hover { text-decoration: underline; }
  .onboarding-footer { margin-top: 16px; font-size: 11px; color: var(--text-muted); }
  .onboarding-footer kbd { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 3px; padding: 1px 5px; font-family: inherit; font-size: 11px; }

  /* ---- Feature Carousel (pre-login) ---- */
  .feature-carousel { margin-top: 20px; position: relative; overflow: hidden; border-radius: 10px; background: var(--bg-secondary); border: 1px solid var(--border); }
  .feature-carousel-track { display: flex; transition: transform 0.5s cubic-bezier(0.4,0,0.2,1); }
  .feature-slide { min-width: 100%; padding: 16px 20px; box-sizing: border-box; display: flex; align-items: center; gap: 14px; }
  .feature-slide-icon { font-size: 28px; flex-shrink: 0; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; border-radius: 10px; background: rgba(17,199,230,0.08); }
  .feature-slide-content { flex: 1; text-align: left; }
  .feature-slide-title { font-size: 13px; font-weight: 600; color: var(--text-primary); margin-bottom: 3px; }
  .feature-slide-desc { font-size: 11px; color: var(--text-secondary); line-height: 1.45; }
  .feature-carousel-dots { display: flex; justify-content: center; gap: 6px; padding: 8px 0 10px; }
  .feature-carousel-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); opacity: 0.35; cursor: pointer; transition: all 0.3s; border: none; padding: 0; }
  .feature-carousel-dot.active { opacity: 1; background: var(--accent); transform: scale(1.3); }

  /* ---- Post-connect Loading Screen ---- */
  .connect-loading-overlay { position: absolute; inset: 0; background: var(--bg-primary); display: none; align-items: center; justify-content: center; flex-direction: column; gap: 20px; z-index: 200; opacity: 0; transition: opacity 0.4s; }
  .connect-loading-overlay.active { display: flex; opacity: 1; }
  .connect-loading-overlay.fade-out { opacity: 0; }
  .connect-loading-title { font-size: 16px; font-weight: 600; color: var(--text-primary); }
  .connect-loading-subtitle { font-size: 12px; color: var(--text-muted); margin-top: -12px; }
  .connect-loading-checklist { display: flex; flex-direction: column; gap: 10px; min-width: 300px; }
  .connect-loading-item { display: flex; align-items: center; gap: 12px; padding: 10px 14px; border-radius: 8px; background: var(--bg-secondary); border: 1px solid var(--border); transition: all 0.4s; }
  .connect-loading-item.active { border-color: var(--accent); background: rgba(17,199,230,0.06); }
  .connect-loading-item.done { border-color: var(--success); background: rgba(16,185,129,0.06); }
  .connect-loading-item-icon { width: 22px; height: 22px; border-radius: 50%; display: flex; align-items: center; justify-content: center; flex-shrink: 0; font-size: 12px; background: var(--bg-tertiary); color: var(--text-muted); transition: all 0.3s; }
  .connect-loading-item.active .connect-loading-item-icon { background: rgba(17,199,230,0.15); color: var(--accent); }
  .connect-loading-item.done .connect-loading-item-icon { background: rgba(16,185,129,0.15); color: var(--success); }
  .connect-loading-item-text { font-size: 12px; color: var(--text-secondary); transition: color 0.3s; }
  .connect-loading-item.active .connect-loading-item-text { color: var(--text-primary); font-weight: 500; }
  .connect-loading-item.done .connect-loading-item-text { color: var(--success); }
  .connect-loading-spinner { width: 12px; height: 12px; border: 2px solid var(--bg-tertiary); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
  .connect-loading-check { display: none; }
  .connect-loading-item.done .connect-loading-check { display: block; }
  .connect-loading-item.done .connect-loading-spinner { display: none; }
  .connect-loading-item .connect-loading-spinner { display: none; }
  .connect-loading-item.active .connect-loading-spinner { display: block; }
  .connect-loading-progress { width: 300px; height: 3px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; margin-top: 4px; }
  .connect-loading-progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--success)); border-radius: 2px; transition: width 0.6s ease; }

  /* ---- Search (Canvas Overlay) ---- */
  .canvas-search {
    position: absolute; top: 16px; left: 16px; z-index: 15;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 10px; padding: 8px 12px; min-width: 280px; max-width: 340px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
  }
  .canvas-search .search-box { position: relative; display: flex; align-items: center; }
  .canvas-search .search-icon { color: var(--text-muted); flex-shrink: 0; width: 14px; height: 14px; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); pointer-events: none; }
  .canvas-search .search-box input {
    flex: 1; background: var(--bg-tertiary); border: 1px solid var(--border);
    border-radius: 6px; padding: 7px 28px 7px 30px; color: var(--text-primary);
    font-size: 13px; font-family: inherit; outline: none; width: 100%;
  }
  .canvas-search .search-box input:focus { border-color: var(--accent); }
  .canvas-search .search-box input::placeholder { color: var(--text-muted); }
  .search-clear { position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 16px; padding: 0 4px; line-height: 1; }
  .search-clear:hover { color: var(--text-primary); }
  .search-results { max-height: 200px; overflow-y: auto; margin-top: 6px; }
  .search-result-item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; color: var(--text-secondary); transition: background 0.15s; }
  .search-result-item:hover, .search-result-item:focus-visible { background: var(--bg-tertiary); color: var(--text-primary); }
  .search-result-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .search-result-count { font-size: 10px; color: var(--text-muted); margin-top: 4px; }

  /* ---- Collapsible Sidebar ---- */
  .sidebar-toggle { position: absolute; top: 16px; right: -14px; width: 28px; height: 28px; border-radius: 50%; background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-muted); cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 20; font-size: 12px; transition: all 0.2s; }
  .sidebar-toggle:hover { color: var(--text-primary); background: var(--bg-tertiary); }
  .sidebar { position: relative; transition: width 0.3s ease; }
  .sidebar.collapsed { width: 0; min-width: 0; overflow: hidden; border-right: none; }
  .sidebar.collapsed .sidebar-toggle { display: none; }

  /* Expand button shown in canvas when sidebar is hidden */
  .sidebar-expand {
    position: absolute; top: 16px; left: 16px; z-index: 20;
    width: 34px; height: 34px; border-radius: 8px;
    background: var(--bg-secondary); border: 1px solid var(--border);
    color: var(--text-muted); cursor: pointer;
    display: none; align-items: center; justify-content: center;
    font-size: 14px; transition: all 0.2s;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  }
  .sidebar-expand:hover { color: var(--text-primary); background: var(--bg-tertiary); }
  .sidebar-expand.visible { display: flex; }

  /* ---- Shortcuts Overlay ---- */
  .shortcuts-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 300; display: flex; align-items: center; justify-content: center; }
  .shortcuts-dialog { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; padding: 20px; min-width: 300px; max-width: 400px; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }

  /* ---- Table View Overlay ---- */
  .table-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 300; display: flex; align-items: center; justify-content: center; }
  .table-dialog { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; width: 95vw; max-width: 1200px; max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 8px 32px rgba(0,0,0,0.4); overflow: hidden; }
  .table-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--border); }
  .table-header h2 { font-size: 15px; font-weight: 700; margin: 0; }
  .table-controls { display: flex; align-items: center; gap: 8px; }
  #tableSearch { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; color: var(--text-primary); font-size: 12px; width: 200px; outline: none; }
  #tableSearch:focus { border-color: var(--accent); }
  #tableSearch::placeholder { color: var(--text-muted); }
  .table-csv-btn { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; padding: 6px 12px; color: var(--text-secondary); font-size: 12px; cursor: pointer; transition: all 0.15s; white-space: nowrap; }
  .table-csv-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
  .table-filters { display: flex; flex-wrap: wrap; gap: 6px; padding: 10px 20px; border-bottom: 1px solid var(--border); }
  .table-filter-pill { display: inline-flex; align-items: center; gap: 5px; padding: 4px 10px; border-radius: 12px; font-size: 11px; font-weight: 500; cursor: pointer; transition: all 0.15s; background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid transparent; user-select: none; }
  .table-filter-pill:hover { color: var(--text-primary); background: var(--bg-hover); }
  .table-filter-pill.active { color: var(--text-primary); border-color: var(--border); }
  .table-filter-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .table-scroll { flex: 1; overflow: auto; min-height: 0; }
  .resource-table { width: 100%; border-collapse: collapse; font-size: 12px; }
  .resource-table thead { position: sticky; top: 0; z-index: 1; }
  .resource-table th { background: var(--bg-primary); padding: 10px 12px; text-align: left; font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.3px; border-bottom: 1px solid var(--border); white-space: nowrap; }
  .resource-table th.sortable { cursor: pointer; user-select: none; }
  .resource-table th.sortable:hover { color: var(--text-primary); }
  .resource-table th .sort-arrow { margin-left: 4px; font-size: 10px; opacity: 0.4; }
  .resource-table th.sort-asc .sort-arrow, .resource-table th.sort-desc .sort-arrow { opacity: 1; color: var(--accent); }
  .resource-table td { padding: 8px 12px; border-bottom: 1px solid var(--bg-tertiary); color: var(--text-secondary); vertical-align: middle; }
  .resource-table tbody tr { cursor: pointer; transition: background 0.1s; }
  .resource-table tbody tr:hover { background: var(--bg-tertiary); }
  .resource-table tbody tr:hover td { color: var(--text-primary); }
  .table-type-badge { display: inline-flex; align-items: center; gap: 5px; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 500; }
  .table-type-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
  .table-state { font-size: 11px; font-weight: 500; }
  .table-state.available, .table-state.running, .table-state.active { color: var(--success); }
  .table-state.busy, .table-state.deploying, .table-state.provisioning { color: #FFAA00; }
  .table-state.inactive, .table-state.shutoff, .table-state.suspended { color: var(--text-muted); }
  .table-state.error, .table-state.failed { color: #ef4444; }
  .table-ips { font-family: 'SF Mono', 'Consolas', monospace; font-size: 11px; color: #38bdf8; }
  .table-footer { padding: 10px 20px; border-top: 1px solid var(--border); font-size: 11px; color: var(--text-muted); display: flex; align-items: center; justify-content: space-between; }
  .table-empty { padding: 40px 20px; text-align: center; color: var(--text-muted); font-size: 13px; }

  /* ---- Loading Stages ---- */
  .loading-stages { display: flex; gap: 8px; margin-bottom: 16px; /* legacy — kept for compat */ }
  .loading-stage { font-size: 11px; color: var(--text-muted); padding: 4px 10px; border-radius: 12px; background: var(--bg-tertiary); border: 1px solid var(--border); transition: all 0.3s; display: none; /* hidden — replaced by checklist */ }
  .loading-stage.active { color: var(--accent); border-color: var(--accent); background: rgba(17,199,230,0.1); }
  .loading-stage.done { color: var(--success); border-color: var(--success); background: rgba(16,185,129,0.1); }
  .loading-bar { width: 200px; height: 3px; background: var(--bg-tertiary); border-radius: 2px; overflow: hidden; display: none; /* hidden — replaced by checklist progress */ }
  .loading-bar-fill { height: 100%; width: 0%; background: var(--accent); border-radius: 2px; transition: width 0.4s ease; }

  /* ---- Stat Card Enhancements ---- */
  /* (stat cards merged into legend) */

  /* ---- Loading ---- */
  .loading-overlay {
    position: absolute; inset: 0;
    background: var(--bg-primary);
    display: none; align-items: center; justify-content: center;
    flex-direction: column; gap: 20px; z-index: 200;
    opacity: 0; transition: opacity 0.4s;
  }
  .loading-overlay.active { display: flex; opacity: 1; }
  .loading-overlay.fade-out { opacity: 0; }
  .spinner { width: 40px; height: 40px; border: 3px solid var(--bg-tertiary); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text { font-size: 13px; color: var(--text-secondary); display: none; }

  /* ---- Detail Panel ---- */
  .detail-panel {
    width: 0; background: var(--bg-secondary);
    border-left: 1px solid var(--border);
    overflow-y: auto; transition: width 0.3s ease; flex-shrink: 0;
  }
  .detail-panel.open { width: var(--detail-width); }
  .detail-content { padding: 20px; width: var(--detail-width); }
  .detail-header { display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 16px; }
  .detail-header h2 { font-size: 15px; font-weight: 700; word-break: break-all; }
  .detail-close { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 20px; padding: 0 4px; line-height: 1; }
  .detail-close:hover { color: var(--text-primary); }
  .detail-badge { display: inline-block; padding: 3px 10px; border-radius: 12px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px; margin-bottom: 16px; }
  .detail-table { width: 100%; border-collapse: collapse; margin-bottom: 16px; }
  .detail-table th, .detail-table td { padding: 8px 0; font-size: 12px; border-bottom: 1px solid var(--bg-tertiary); text-align: left; vertical-align: top; }
  .detail-table th { color: var(--text-muted); font-weight: 500; width: 110px; }
  .detail-table td { color: var(--text-primary); word-break: break-all; }
  .detail-section-title { font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); margin: 16px 0 8px; }
  .connected-item { display: flex; align-items: center; gap: 8px; padding: 6px 10px; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 4px; font-size: 12px; cursor: pointer; transition: background 0.15s; }
  .connected-item:hover, .connected-item:focus-visible { background: var(--bg-hover); }
  .connected-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }

  /* ---- AI Assistant Panel ---- */
  .ai-panel {
    width: 0; min-width: 0; overflow: hidden; background: var(--bg-secondary); border-left: none;
    flex-shrink: 0; display: flex; flex-direction: column; transition: width 0.3s ease, min-width 0.3s ease;
    position: relative; z-index: 50;
  }
  .ai-panel.open { width: 400px; min-width: 400px; border-left: 1px solid var(--border); }
  .ai-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 14px 16px; border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, rgba(168,85,247,0.08) 0%, transparent 100%);
    flex-shrink: 0;
  }
  .ai-title { display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 700; }
  .ai-title svg { flex-shrink: 0; }
  .ai-controls { display: flex; align-items: center; gap: 6px; }
  .ai-controls select {
    font-size: 11px; padding: 4px 6px; border-radius: 5px; border: 1px solid var(--border);
    background: var(--bg-tertiary); color: var(--text-secondary); font-family: inherit; cursor: pointer;
  }
  .ai-docs-toggle { display: flex; align-items: center; gap: 4px; font-size: 11px; color: var(--text-muted); cursor: pointer; padding: 3px 8px; border-radius: 5px; border: 1px solid var(--border); background: var(--bg-tertiary); user-select: none; transition: all 0.2s; }
  .ai-docs-toggle:hover { color: var(--text-primary); border-color: var(--accent); }
  .ai-docs-toggle input { display: none; }
  .ai-docs-toggle input:checked ~ svg { color: var(--accent); }
  .ai-docs-toggle input:checked ~ span { color: var(--accent); }
  .ai-cost-banner {
    padding: 10px 14px; font-size: 11px; color: #fbbf24; background: rgba(251,191,36,0.08);
    border-bottom: 1px solid rgba(251,191,36,0.2); display: flex; align-items: center;
    gap: 8px; flex-shrink: 0; line-height: 1.4;
  }
  .ai-cost-banner.hidden { display: none; }
  .ai-cost-banner button {
    padding: 3px 10px; border-radius: 4px; font-size: 10px; font-weight: 600;
    border: 1px solid rgba(251,191,36,0.4); background: rgba(251,191,36,0.12); color: #fbbf24;
    cursor: pointer; white-space: nowrap; font-family: inherit;
  }
  .ai-cost-banner button:hover { background: rgba(251,191,36,0.25); }
  .ai-messages {
    flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 12px;
    min-height: 0;
  }
  .ai-msg {
    max-width: 90%; padding: 10px 14px; border-radius: 12px; font-size: 13px; line-height: 1.5;
    word-wrap: break-word;
  }
  .ai-msg-user {
    align-self: flex-end; background: rgba(17,199,230,0.15); color: var(--text-primary);
    border-bottom-right-radius: 4px;
  }
  .ai-msg-assistant {
    align-self: flex-start; background: var(--bg-tertiary); color: var(--text-primary);
    border-bottom-left-radius: 4px; white-space: pre-wrap;
  }
  .ai-msg-error {
    align-self: flex-start; background: rgba(239,68,68,0.1); color: #f87171;
    border-bottom-left-radius: 4px; font-size: 12px;
  }
  .ai-typing {
    align-self: flex-start; padding: 10px 14px; background: var(--bg-tertiary);
    border-radius: 12px; border-bottom-left-radius: 4px; font-size: 13px;
    color: var(--text-muted);
  }
  .ai-typing-dots { display: inline-flex; gap: 3px; }
  .ai-typing-dots span {
    width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted);
    animation: aiDot 1.4s infinite ease-in-out;
  }
  .ai-typing-dots span:nth-child(2) { animation-delay: 0.2s; }
  .ai-typing-dots span:nth-child(3) { animation-delay: 0.4s; }
  @keyframes aiDot { 0%,80%,100% { opacity: 0.3; transform: scale(0.8); } 40% { opacity: 1; transform: scale(1); } }
  .ai-suggestions {
    padding: 8px 16px; display: flex; flex-wrap: wrap; gap: 6px; border-top: 1px solid var(--border);
    flex-shrink: 0;
  }
  .ai-suggest-btn {
    padding: 5px 12px; border-radius: 16px; font-size: 11px; font-weight: 500;
    border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-secondary);
    cursor: pointer; font-family: inherit; transition: all 0.15s; white-space: nowrap;
  }
  .ai-suggest-btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--accent); }
  .ai-input-area {
    padding: 12px 16px; border-top: 1px solid var(--border); display: flex; gap: 8px;
    align-items: flex-end; flex-shrink: 0;
  }
  .ai-input-area textarea {
    flex: 1; resize: none; padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border);
    background: var(--bg-tertiary); color: var(--text-primary); font-family: inherit; font-size: 13px;
    outline: none; line-height: 1.4;
  }
  .ai-input-area textarea:focus { border-color: var(--accent); }
  .ai-input-area button {
    padding: 8px 16px; border-radius: 8px; font-size: 12px; font-weight: 600; border: none;
    background: linear-gradient(135deg, #a855f7, #7c3aed); color: #fff; cursor: pointer;
    font-family: inherit; transition: opacity 0.15s; flex-shrink: 0;
  }
  .ai-input-area button:hover { opacity: 0.85; }
  .ai-input-area button:disabled { opacity: 0.4; cursor: not-allowed; }
  .ai-welcome { text-align: center; padding: 32px 20px; color: var(--text-muted); font-size: 12px; line-height: 1.6; }
  .ai-welcome svg { margin-bottom: 12px; opacity: 0.5; }

  /* ---- Metrics Charts ---- */
  #metricsContainer { margin-top: 4px; }
  .metrics-loading { font-size: 10px; color: var(--text-muted); }
  .metrics-chart-label { font-size: 10px; font-weight: 600; color: var(--text-muted); margin-bottom: 2px; }
  .metrics-chart-label + .metrics-chart-label { margin-top: 8px; }
  .metrics-chart svg { display: block; width: 100%; }
  .metrics-chart .axis text { fill: #6a9ec8; font-size: 8px; }
  .metrics-chart .axis .domain { display: none; }
  .metrics-chart .axis .tick line { stroke: #1a4a7a; }
  .metrics-chart .grid .grid-line { stroke: #1a4a7a; stroke-opacity: 0.3; }
  .metrics-legend { display: flex; gap: 12px; margin-top: 2px; }
  .metrics-legend span { font-size: 10px; }
  .metrics-no-data { font-size: 10px; color: var(--text-muted); padding: 8px 0; }

  /* ---- Graph Elements ---- */
  .node { cursor: pointer; }
  .node:hover .node-bg { filter: brightness(1.3); }
  .node-icon { pointer-events: none; }
  .node-label {
    font-size: 11px; fill: var(--text-primary);
    text-anchor: middle; pointer-events: none; font-weight: 600;
  }
  .node-sublabel {
    font-size: 9px; fill: var(--text-secondary);
    text-anchor: middle; pointer-events: none;
  }
  .link { stroke-width: 2; stroke-opacity: 0.35; }
  .link.traffic-flow {
    stroke-width: 2.5;
    stroke-opacity: 0.75;
    stroke-dasharray: 8, 5;
    animation: trafficFlow 0.8s linear infinite;
    filter: drop-shadow(0 0 3px currentColor);
  }
  @keyframes trafficFlow {
    to { stroke-dashoffset: -26; }
  }
  .link-label {
    font-size: 10px; fill: var(--text-secondary);
    text-anchor: middle; pointer-events: none;
    font-weight: 500;
  }
  .link-label-bg {
    fill: var(--bg-primary); fill-opacity: 0.7;
  }
  .node.highlighted .node-bg { filter: brightness(1.4); }
  .node.dimmed { opacity: 0.12; }
  .link.dimmed { stroke-opacity: 0.04; }
  .link.highlighted { stroke-opacity: 0.9; stroke-width: 3; }

  /* ---- Account Info ---- */
  .sidebar-section.account-section {
    background: linear-gradient(180deg, rgba(17, 199, 230, 0.06) 0%, transparent 100%);
    padding: 10px 20px;
  }
  .account-info { display: flex; flex-wrap: wrap; gap: 6px 16px; }
  .account-info-item { font-size: 11px; }
  .account-info-label { color: var(--text-muted); font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px; }
  .account-info-value { color: var(--text-secondary); margin-top: 1px; word-break: break-all; }

  /* ---- Highlights ---- */
  .highlight-checkbox {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 0; font-size: 12px; color: var(--text-secondary); cursor: pointer;
  }
  .highlight-checkbox input[type="checkbox"] { cursor: pointer; accent-color: var(--accent); width: 14px; height: 14px; }
  .highlight-checkbox:hover { color: var(--text-primary); }
  .highlight-checkbox .hl-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .hl-dot-firewall { background: var(--success); }
  .hl-dot-flowlogs { background: var(--accent); }
  .hl-dot-secgroups { background: var(--ionos-amber); }
  .hl-dot-ipv6 { background: #3b82f6; }
  .hl-dot-failover { background: var(--danger); }
  .hl-dot-pcc { background: #ec4899; }

  /* Highlight rings around nodes */
  @keyframes hlRingPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .hl-ring {
    fill: none; stroke-width: 3; pointer-events: none;
    animation: hlRingPulse 2s ease-in-out infinite;
  }

  /* ---- Highlights Overlay ---- */
  .highlights-overlay {
    position: absolute; top: 16px; right: 16px; z-index: 15;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 10px; padding: 10px 14px; min-width: 180px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3);
    display: none;
  }
  .highlights-overlay.open { display: block; }
  .highlights-overlay .hl-title {
    font-size: 10px; font-weight: 600; text-transform: uppercase;
    letter-spacing: 0.5px; color: var(--text-muted); margin-bottom: 6px;
  }

  /* ---- Toolbar ---- */
  .toolbar {
    position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 2px; align-items: center;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 8px; padding: 4px; z-index: 10;
    max-width: calc(100% - 40px);
  }
  .toolbar button {
    position: relative;
    background: none; border: none; color: var(--text-secondary);
    padding: 6px 7px; border-radius: 4px; cursor: pointer;
    font-size: 13px; transition: all 0.15s;
    flex-shrink: 1; min-width: 0;
  }
  .toolbar button:hover, .toolbar button:focus-visible { background: var(--bg-tertiary); color: var(--text-primary); }
  .toolbar button.active { background: var(--accent); color: #fff; }
  .toolbar-divider { width: 1px; flex-shrink: 0; background: var(--border); margin: 2px 4px; }
  .toolbar button::after {
    content: attr(data-tip);
    position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
    padding: 4px 8px; margin-bottom: 6px;
    background: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border);
    border-radius: 4px; font-size: 11px; white-space: nowrap;
    opacity: 0; pointer-events: none; transition: opacity 0.15s;
  }
  .toolbar button:hover::after { opacity: 1; }

  /* ---- Export Dropdown ---- */
  .export-dropdown-wrapper { position: relative; display: inline-flex; }
  .export-dropdown {
    position: absolute; bottom: calc(100% + 8px); right: 0;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 8px; min-width: 165px; padding: 4px 0;
    box-shadow: 0 -4px 16px rgba(0,0,0,0.35);
    opacity: 0; visibility: hidden; transform: translateY(4px);
    transition: all 0.15s ease; pointer-events: none; z-index: 100;
  }
  .export-dropdown.open { opacity: 1; visibility: visible; transform: translateY(0); pointer-events: auto; }
  .export-dropdown button {
    position: static; display: block; width: 100%; padding: 7px 14px; background: none; border: none;
    color: var(--text-secondary); font-size: 12px; font-family: inherit;
    text-align: left; cursor: pointer; transition: all 0.12s; border-radius: 0;
  }
  .export-dropdown button:hover { background: var(--bg-tertiary); color: var(--text-primary); }
  .export-dropdown button::after { display: none; content: none; opacity: 0; }
  .export-sep { height: 1px; background: var(--border); margin: 4px 0; }
  .export-section-label { padding: 6px 14px 3px; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.4px; color: var(--text-muted); pointer-events: none; }

  /* ---- IP View Mode ---- */
  /* ---- Author Footer ---- */
  .sidebar-footer {
    margin-top: auto;
    padding: 12px 20px;
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 10px;
    color: var(--text-muted);
  }
  .sidebar-footer .author-text {
    opacity: 0.7;
  }
  .sidebar-footer .author-links {
    display: flex;
    gap: 10px;
    align-items: center;
  }
  .sidebar-footer .author-links a {
    color: var(--text-muted);
    transition: color 0.2s, transform 0.2s;
    display: flex;
    align-items: center;
  }
  .sidebar-footer .author-links a:hover {
    color: var(--accent);
    transform: scale(1.15);
  }

  .ip-view-active .node-label { opacity: 0.05 !important; }
  .ip-view-active .node-sublabel:not(.node-ip-label) { opacity: 0 !important; }
  .ip-view-active .node-ip-label {
    opacity: 1 !important; font-weight: 600 !important; fill: #38bdf8 !important; font-size: 10px;
    text-shadow: 0 0 6px rgba(0,0,0,0.8), 0 1px 3px rgba(0,0,0,0.6);
    paint-order: stroke; stroke: rgba(0,10,30,0.5); stroke-width: 3px; stroke-linejoin: round;
  }
  .ip-view-active .node-ip-label .ip-line-addr { font-size: 12px; fill: #38bdf8; font-weight: 700; letter-spacing: 0.3px; }
  .ip-view-active .node-ip-label .ip-line-dns { font-size: 10px; fill: #7dd3fc; font-weight: 500; }
  .ip-view-active .node-ip-label .ip-line-cdn { font-size: 10px; fill: #22d3ee; font-weight: 500; }
  .ip-view-active .ip-detail-label { font-size: 12px !important; }
  .ip-view-active .link-label { opacity: 0 !important; }
  .ip-view-active .link-label-bg { opacity: 0 !important; }
  html[data-theme="light"] .ip-view-active .node-ip-label {
    fill: #0369a1 !important;
    stroke: rgba(255,255,255,0.6); stroke-width: 3px;
  }
  html[data-theme="light"] .ip-view-active .node-ip-label .ip-line-addr { fill: #0369a1; }
  html[data-theme="light"] .ip-view-active .node-ip-label .ip-line-dns { fill: #0284c7; }
  html[data-theme="light"] .ip-view-active .node-ip-label .ip-line-cdn { fill: #0891b2; }

  /* ---- Compute View ---- */
  /* Dim non-compute nodes — visible but de-emphasised */
  .compute-view-active .node:not([data-ntype="server"]):not([data-ntype="cube"]) { opacity: 0.5 !important; }
  /* Dim links — still visible for context */
  .compute-view-active .link { opacity: 0.35 !important; filter: none !important; }
  .compute-view-active .link.traffic-flow { animation: none !important; }
  .compute-view-active .link-label, .compute-view-active .link-label-bg { opacity: 0.25 !important; }
  /* Fade non-compute labels */
  .compute-view-active .node-label { opacity: 0.4 !important; }
  .compute-view-active .node[data-ntype="server"] .node-label,
  .compute-view-active .node[data-ntype="cube"] .node-label { opacity: 1 !important; font-size: 10px !important; }
  .compute-view-active .node-sublabel:not(.node-compute-label) { opacity: 0.15 !important; }
  /* Compute labels: 2-line layout (type+cpu on line 1, specs on line 2) */
  .compute-view-active .node-compute-label { opacity: 1 !important; font-weight: 600 !important; }
  .compute-view-active .node-compute-label .compute-line-type { font-size: 10px; }
  .compute-view-active .node-compute-label .compute-line-spec { font-size: 9px; }
  /* Color by VM type */
  .compute-view-active .node-compute-label.compute-enterprise { fill: #22d3ee !important; }  /* cyan — dedicated core */
  .compute-view-active .node-compute-label.compute-vcpu { fill: #a78bfa !important; }       /* purple — vCPU */
  .compute-view-active .node-compute-label.compute-cube { fill: #fb923c !important; }       /* orange — Cube */
  .compute-view-active .node-compute-label.compute-gpu { fill: #f43f5e !important; }        /* rose — GPU */
  .compute-view-active .node-compute-label.compute-other { fill: var(--text-secondary) !important; }

  /* ---- IP Block Panel ---- */
  .ip-block-panel { margin-top: 4px; }
  .ip-bar-container { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .ip-bar { flex: 1; height: 8px; border-radius: 4px; background: var(--bg-tertiary); overflow: hidden; }
  .ip-bar-fill { height: 100%; border-radius: 4px; transition: width 0.4s ease; }
  .ip-bar-label { font-size: 11px; color: var(--text-muted); white-space: nowrap; min-width: 55px; text-align: right; }
  .ip-block-row { display: flex; justify-content: space-between; font-size: 11px; padding: 3px 0; border-bottom: 1px solid var(--bg-tertiary); }
  .ip-block-row:last-child { border-bottom: none; }
  .ip-block-loc { color: var(--text-secondary); font-weight: 500; }
  .ip-block-stat { color: var(--text-muted); }
  .ip-block-stat .used { color: var(--accent); font-weight: 600; }

  /* ---- DNS Panel ---- */
  .dns-panel { display: flex; flex-direction: column; gap: 6px; margin-top: 4px; max-height: 300px; overflow-y: auto; font-size: 11px; }
  .dns-zone-card { background: var(--bg-tertiary); border-radius: 6px; padding: 8px 10px; border-left: 3px solid var(--text-muted); transition: background 0.2s; }
  .dns-zone-card:hover { background: var(--bg-hover); }
  .cdn-badge { display: inline-block; background: #11C7E6; color: #001B41; padding: 1px 5px; border-radius: 3px; font-weight: 700; font-size: 9px; margin-left: 6px; vertical-align: middle; }
  .cdn-badge.cdn-badge-off { background: var(--bg-hover); color: var(--text-muted); font-weight: 600; }

  /* ---- Language Dropdown ---- */
  .locale-dropdown-wrapper { position: relative; display: inline-flex; margin-left: auto; flex-shrink: 0; align-self: center; }
  .locale-toggle {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 3px 8px; height: 28px; border-radius: 6px; font-size: 11px; font-weight: 600;
    cursor: pointer; background: rgba(17,199,230,0.1); color: var(--text-secondary);
    border: 1px solid rgba(17,199,230,0.2); transition: all 0.15s ease; line-height: 1;
    box-sizing: border-box;
  }
  .locale-toggle:hover { background: rgba(17,199,230,0.18); color: var(--text-primary); }
  .locale-toggle .locale-flag { font-size: 14px; line-height: 1; }
  .locale-toggle .locale-caret { font-size: 8px; opacity: 0.6; }
  .locale-menu {
    position: absolute; top: calc(100% + 4px); right: 0; min-width: 140px;
    background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 8px;
    padding: 4px 0; box-shadow: 0 4px 16px rgba(0,0,0,0.35); z-index: 50;
    opacity: 0; visibility: hidden; transform: translateY(-4px);
    transition: all 0.15s ease; pointer-events: none;
  }
  .locale-menu.open { opacity: 1; visibility: visible; transform: translateY(0); pointer-events: auto; }
  .locale-menu button {
    display: flex; align-items: center; gap: 8px; width: 100%;
    padding: 7px 12px; background: none; border: none; color: var(--text-secondary);
    font-size: 12px; cursor: pointer; text-align: left; transition: background 0.1s;
  }
  .locale-menu button::after { display: none; }
  .locale-menu button:hover { background: var(--bg-hover); color: var(--text-primary); }
  .locale-menu button.active { color: var(--accent); font-weight: 600; }
  .locale-menu button .locale-flag { font-size: 16px; }
  .locale-menu button .locale-check { margin-left: auto; opacity: 0; font-size: 12px; color: var(--accent); }
  .locale-menu button.active .locale-check { opacity: 1; }

  /* ---- Theme Toggle ---- */
  .theme-toggle {
    display: inline-flex; align-items: center; justify-content: center;
    width: 28px; height: 28px; border-radius: 6px; font-size: 16px; line-height: 1;
    cursor: pointer; background: rgba(17,199,230,0.1); color: var(--text-secondary);
    border: 1px solid rgba(17,199,230,0.2); transition: all 0.15s ease; flex-shrink: 0;
  }
  .theme-toggle:hover { background: rgba(17,199,230,0.18); color: var(--text-primary); }

  /* ---- VDC Favorites ---- */
  .vdc-controls-wrapper { display: flex; gap: 6px; align-items: center; }
  .vdc-controls-wrapper select { flex: 1; min-width: 0; }
  .pin-vdc-btn {
    display: inline-flex; align-items: center; justify-content: center;
    width: 32px; height: 32px; border-radius: 6px; font-size: 16px; line-height: 1;
    cursor: pointer; background: var(--bg-tertiary); color: var(--text-muted);
    border: 1px solid var(--border); transition: all 0.2s ease; flex-shrink: 0;
  }
  .pin-vdc-btn:hover { background: var(--bg-hover); color: var(--ionos-amber); border-color: var(--ionos-amber); }
  .pin-vdc-btn.pinned { color: var(--ionos-amber); border-color: var(--ionos-amber); background: rgba(255,170,0,0.1); }

  /* ---- Security Badge ---- */
  .sg-badge { font-size: 8px; font-weight: 700; pointer-events: none; }

  /* ---- Security Posture Overlay ---- */
  .security-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.55); z-index: 300;
    display: flex; align-items: center; justify-content: center;
  }
  .security-panel {
    background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 14px;
    padding: 28px 32px; width: 560px; max-width: 92vw; max-height: 85vh; overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  }
  .security-panel h2 { font-size: 18px; font-weight: 700; margin-bottom: 20px; }
  .security-metrics { display: flex; flex-direction: column; gap: 14px; }
  .security-metric {
    background: var(--bg-tertiary); border-radius: 10px; padding: 14px 16px;
    border-left: 4px solid var(--text-muted); cursor: pointer; transition: background 0.15s;
  }
  .security-metric:hover { background: var(--bg-hover); }
  .security-metric.metric-good { border-left-color: #10b981; }
  .security-metric.metric-warning { border-left-color: #f59e0b; }
  .security-metric.metric-danger { border-left-color: #ef4444; }
  .metric-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
  .metric-label { font-weight: 600; font-size: 13px; }
  .metric-value { font-size: 13px; font-weight: 700; color: var(--text-muted); }
  .metric-value.good { color: #10b981; }
  .metric-value.warning { color: #f59e0b; }
  .metric-value.danger { color: #ef4444; }
  .metric-bar-container {
    height: 6px; background: var(--bg-primary); border-radius: 3px; overflow: hidden;
  }
  .metric-bar {
    height: 100%; border-radius: 3px; transition: width 0.4s ease;
  }
  .metric-bar.good { background: #10b981; }
  .metric-bar.warning { background: #f59e0b; }
  .metric-bar.danger { background: #ef4444; }
  .metric-desc { font-size: 11px; color: var(--text-muted); margin-top: 6px; }

  /* ---- Toast ---- */
  .toast-container {
    position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
    z-index: 200; display: flex; flex-direction: column; gap: 8px; align-items: center;
  }
  .toast {
    padding: 10px 20px; border-radius: 8px; font-size: 13px; color: white;
    animation: toast-in 0.3s ease, toast-out 0.3s ease 2.7s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  .toast.error { background: var(--danger); }
  .toast.success { background: var(--success); }
  .toast.info { background: var(--accent); }
  .toast.toast-persistent { animation: toast-in 0.3s ease; box-shadow: 0 4px 16px rgba(0,0,0,0.4); max-width: 600px; }
  @keyframes toast-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
  @keyframes toast-out { from { opacity: 1; } to { opacity: 0; } }

  /* ---- Tooltip ---- */
  .tooltip {
    position: absolute; background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 8px; padding: 10px 14px; font-size: 12px;
    pointer-events: none; z-index: 150;
    box-shadow: 0 4px 16px rgba(0,0,0,0.3); max-width: 280px; display: none;
  }
  .tooltip.visible { display: block; }
  .tooltip .tt-title { font-weight: 700; margin-bottom: 4px; }
  .tooltip .tt-type { color: var(--text-muted); font-size: 10px; text-transform: uppercase; letter-spacing: 0.3px; }
  .tooltip .tt-detail { color: var(--text-secondary); margin-top: 4px; }
  .tooltip .tt-nic { color: var(--text-muted); font-size: 10px; margin-top: 2px; }

  /* ---- Flow Log Explorer ---- */
  .flowlog-overlay {
    position: fixed; inset: 0; z-index: 300;
    pointer-events: none;
  }
  .flowlog-dialog {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 14px;
    width: 95vw; max-width: 1200px; max-height: 90vh; min-width: 480px; min-height: 320px;
    display: flex; flex-direction: column;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5); overflow: hidden;
    pointer-events: auto; resize: both;
  }
  .flowlog-dialog::-webkit-resizable { background: transparent; }
  .fl-resize-handle {
    position: absolute; bottom: 0; right: 0; width: 18px; height: 18px; cursor: nwse-resize; z-index: 5;
    opacity: 0.35; transition: opacity 0.15s;
  }
  .fl-resize-handle:hover { opacity: 0.7; }
  .fl-resize-handle svg { position: absolute; bottom: 4px; right: 4px; }
  .flowlog-dialog.fl-dragged { transform: none; }

  /* Docked bottom-panel mode */
  .flowlog-dialog.fl-docked {
    top: auto !important; left: 0 !important; right: 0; bottom: 0;
    transform: none !important;
    width: 100vw; max-width: 100vw; height: 35vh; min-height: 180px;
    border-radius: 14px 14px 0 0;
    resize: none;
    transition: background 0.25s, border-color 0.25s, box-shadow 0.25s;
  }
  .flowlog-dialog.fl-docked .fl-resize-handle { display: none; }
  .flowlog-dialog.fl-docked .fl-drag-hint { display: none; }
  /* Top-edge resize bar for docked mode */
  .fl-dock-resize {
    display: none; height: 6px; cursor: ns-resize;
    background: transparent; flex-shrink: 0; position: relative;
  }
  .fl-dock-resize::after {
    content: ''; position: absolute; left: 50%; top: 2px; transform: translateX(-50%);
    width: 40px; height: 3px; border-radius: 2px; background: var(--text-muted); opacity: 0.25;
    transition: opacity 0.15s;
  }
  .fl-dock-resize:hover::after { opacity: 0.6; }
  .flowlog-dialog.fl-docked .fl-dock-resize { display: block; }
  .flowlog-dialog.fl-docked .flowlog-header { cursor: default; }
  .flowlog-dialog.fl-docked .flowlog-header:active { cursor: default; }

  /* Dock button styling */
  .fl-btn-dock { position: relative; }
  .fl-btn-dock svg { vertical-align: middle; }

  .flowlog-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 16px 24px; border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, rgba(17,199,230,0.06) 0%, transparent 100%);
    cursor: grab; user-select: none;
  }
  .flowlog-header:active { cursor: grabbing; }
  .flowlog-header .fl-drag-hint {
    font-size: 10px; color: var(--text-muted); opacity: 0.5; margin-left: 8px; font-weight: 400;
  }
  .flowlog-header h2 { font-size: 16px; font-weight: 700; display: flex; align-items: center; gap: 8px; }
  .flowlog-header h2 .fl-count { font-size: 12px; font-weight: 500; color: var(--text-muted); }
  .flowlog-controls { display: flex; align-items: center; gap: 8px; }
  .flowlog-controls input[type="text"] { width: 200px !important; padding: 6px 10px; font-size: 12px; }
  .flowlog-controls select { padding: 6px 10px; font-size: 12px; min-width: 100px; width: auto !important; }
  .flowlog-controls .fl-btn {
    padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 600;
    cursor: pointer; border: 1px solid var(--border); background: var(--bg-tertiary);
    color: var(--text-secondary); transition: all 0.15s; font-family: inherit;
  }
  .flowlog-controls .fl-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
  .flowlog-controls .fl-btn.fl-btn-accent { background: rgba(17,199,230,0.15); color: var(--accent); border-color: rgba(17,199,230,0.3); }
  .flowlog-controls .fl-btn.fl-btn-accent:hover { background: rgba(17,199,230,0.25); }

  .flowlog-filters {
    display: flex; flex-wrap: wrap; align-items: center; gap: 6px;
    padding: 10px 24px; border-bottom: 1px solid var(--border); font-size: 12px;
  }
  .flowlog-filters label { font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.3px; white-space: nowrap; }
  .flowlog-filters select, .flowlog-filters input { padding: 4px 8px; font-size: 12px; width: auto !important; min-width: 0; flex-shrink: 0; }
  .flowlog-filters select { min-width: 80px; max-width: 180px; }
  .flowlog-filters input[type="text"] { width: 120px !important; }
  .fl-filter-sep { width: 1px; height: 20px; background: var(--border); margin: 0 4px; }
  .fl-file-pills { display: flex; flex-wrap: wrap; gap: 4px; padding: 8px 24px; border-bottom: 1px solid var(--border); }
  .fl-file-pill {
    display: inline-flex; align-items: center; gap: 4px; padding: 3px 10px; border-radius: 12px;
    font-size: 11px; background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border);
  }
  .fl-file-pill .fl-pill-nic { color: var(--accent); font-weight: 600; font-family: monospace; font-size: 10px; }
  .fl-file-pill .fl-pill-time { color: var(--text-muted); }
  .fl-file-pill .fl-pill-count { color: var(--text-muted); font-weight: 600; }
  .fl-file-pill .fl-pill-remove { cursor: pointer; color: var(--text-muted); font-size: 13px; margin-left: 2px; }
  .fl-file-pill .fl-pill-remove:hover { color: var(--danger); }

  .flowlog-body { flex: 1; overflow: auto; min-height: 0; }

  /* Drop zone */
  .fl-dropzone {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    padding: 60px 40px; text-align: center; gap: 12px; min-height: 300px;
  }
  .fl-dropzone-icon { font-size: 48px; opacity: 0.4; }
  .fl-dropzone-title { font-size: 15px; font-weight: 600; color: var(--text-primary); }
  .fl-dropzone-subtitle { font-size: 12px; color: var(--text-muted); max-width: 400px; line-height: 1.5; }
  .fl-dropzone-btn {
    margin-top: 8px; padding: 8px 20px; border-radius: 6px; font-size: 13px; font-weight: 600;
    cursor: pointer; background: var(--accent); color: white; border: none; font-family: inherit;
  }
  .fl-dropzone-btn:hover { background: var(--accent-hover); }
  .fl-dropzone.drag-over { background: var(--accent-glow); border: 2px dashed var(--accent); border-radius: 12px; margin: 12px; }

  /* Flow log table */
  .fl-table { min-width: 1100px; width: 100%; border-collapse: collapse; font-size: 12px; }
  .fl-table thead { position: sticky; top: 0; z-index: 2; }
  .fl-table th {
    padding: 8px 10px; text-align: left; font-weight: 600; font-size: 11px;
    text-transform: uppercase; letter-spacing: 0.3px; color: var(--text-muted);
    background: var(--bg-tertiary); border-bottom: 1px solid var(--border);
    white-space: nowrap; cursor: pointer; user-select: none;
  }
  .fl-table th:hover { color: var(--text-primary); }
  .fl-table th .sort-arrow { margin-left: 4px; font-size: 9px; }
  .fl-table td {
    padding: 6px 10px; border-bottom: 1px solid var(--bg-tertiary);
    color: var(--text-secondary); white-space: nowrap; font-family: 'SF Mono', 'Consolas', 'Monaco', monospace; font-size: 11px;
  }
  .fl-table tr:hover td { background: var(--bg-hover); }
  .fl-table tr.fl-row-reject td { color: #f87171; }
  .fl-table tr.fl-row-accept td { }
  .fl-table .fl-action-accept { color: var(--success); font-weight: 600; }
  .fl-table .fl-action-reject { color: var(--danger); font-weight: 600; }
  .fl-table .fl-proto { color: var(--accent); }
  .fl-table tr { cursor: pointer; }
  .fl-table tr.fl-row-highlighted td { background: rgba(17,199,230,0.1); }
  .fl-table .fl-empty { text-align: center; padding: 40px; color: var(--text-muted); font-family: inherit; font-style: italic; }
  .fl-table td:nth-child(2), .fl-table td:nth-child(4) { white-space: nowrap; }
  .fl-ip-tag { display: inline-block; font-size: 9px; padding: 1px 5px; border-radius: 3px; margin-left: 4px; font-weight: 600; vertical-align: middle; opacity: 0.9; }
  .fl-port-label { display: inline-block; font-size: 9px; color: var(--text-muted); margin-left: 3px; font-style: italic; }
  .fl-threat-badge { display: inline-block; font-size: 9px; padding: 1px 5px; border-radius: 3px; background: rgba(248,113,113,0.15); color: #f87171; font-weight: 600; margin-left: 4px; }
  .fl-nic-id { font-size: 9px; color: var(--text-muted); opacity: 0.7; margin-left: 2px; }
  .fl-table td:last-child { white-space: nowrap; }

  /* Flow log context menu */
  .fl-context-menu {
    position: fixed; z-index: 10000; min-width: 200px;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 8px; padding: 4px 0; box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    font-size: 12px; font-family: 'Inter', sans-serif;
    display: none;
  }
  .fl-context-menu.visible { display: block; }
  .fl-ctx-item {
    padding: 7px 14px; cursor: pointer; color: var(--text-secondary);
    display: flex; align-items: center; gap: 8px; transition: background 0.1s;
  }
  .fl-ctx-item:hover { background: var(--bg-hover); color: var(--text-primary); }
  .fl-ctx-item svg { flex-shrink: 0; opacity: 0.6; }
  .fl-ctx-sep { height: 1px; background: var(--border); margin: 4px 0; }

  /* Flow log highlight states on graph */
  .node.hl-dimmed { opacity: 0.15 !important; transition: opacity 0.3s; }
  .node.hl-matched { opacity: 1 !important; filter: drop-shadow(0 0 8px rgba(17,199,230,0.6)); transition: opacity 0.3s, filter 0.3s; }
  .node.hl-path { opacity: 0.85 !important; filter: drop-shadow(0 0 4px rgba(17,199,230,0.3)); transition: opacity 0.3s, filter 0.3s; }

  /* ---- Traffic Heatmap ---- */
  /* Heatmap legend (floating panel on map) */
  .heatmap-legend {
    position: absolute; top: 12px; right: 12px; z-index: 15;
    background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 10px;
    padding: 10px 14px; font-size: 11px; min-width: 200px; max-width: 260px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    backdrop-filter: blur(12px);
  }
  .heatmap-legend.hidden { display: none; }
  .heatmap-legend h4 { font-size: 12px; font-weight: 700; margin-bottom: 8px; color: var(--text-primary); }
  .heatmap-legend .hl-mode-toggle { display: flex; gap: 4px; margin-bottom: 10px; }
  .heatmap-legend .hl-mode-btn {
    flex: 1; padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 600;
    cursor: pointer; border: 1px solid var(--border); background: var(--bg-tertiary);
    color: var(--text-secondary); font-family: inherit; text-align: center; transition: all 0.15s;
  }
  .heatmap-legend .hl-mode-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
  .heatmap-legend .hl-mode-btn:hover:not(.active) { background: var(--bg-hover); }
  .heatmap-gradient { height: 10px; border-radius: 5px; margin: 6px 0 4px; }
  .heatmap-gradient.volume { background: linear-gradient(to right, #1e3a5f, #11C7E6, #10b981, #FFAA00, #ef4444); }
  .heatmap-gradient.security { background: linear-gradient(to right, #10b981, #FFAA00, #ef4444); }
  .heatmap-gradient.billing { background: linear-gradient(to right, #1e3a5f, #4fc3f7, #10b981, #ff8a65, #ef4444); }
  .heatmap-gradient-labels { display: flex; justify-content: space-between; font-size: 9px; color: var(--text-muted); }
  .heatmap-legend .hl-stats { margin-top: 8px; font-size: 10px; color: var(--text-muted); line-height: 1.6; }
  .heatmap-legend .hl-stats span { color: var(--text-secondary); font-weight: 600; }

  /* Flow Logs dropdown in toolbar */
  .flowlog-dropdown-wrapper { position: relative; display: inline-flex; }
  .flowlog-dropdown {
    position: absolute; bottom: calc(100% + 8px); right: 0;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 8px; min-width: 190px; padding: 4px 0;
    box-shadow: 0 -4px 16px rgba(0,0,0,0.35);
    opacity: 0; visibility: hidden; transform: translateY(4px);
    transition: all 0.15s ease; pointer-events: none; z-index: 100;
  }
  .flowlog-dropdown.open { opacity: 1; visibility: visible; transform: translateY(0); pointer-events: auto; }
  .flowlog-dropdown button {
    position: static; display: flex; align-items: center; gap: 8px; width: 100%; padding: 8px 14px;
    background: none; border: none; border-radius: 0;
    color: var(--text-secondary); font-size: 12px; font-family: inherit;
    text-align: left; cursor: pointer; transition: all 0.12s;
  }
  .flowlog-dropdown button:hover { background: var(--bg-tertiary); color: var(--text-primary); }
  .flowlog-dropdown button::after { display: none; content: none; opacity: 0; }
  .flowlog-dropdown button svg { opacity: 0.6; flex-shrink: 0; width: 14px; height: 14px; }
  .flowlog-dropdown button:hover svg { opacity: 1; }
  .flowlog-dropdown .fl-dd-shortcut { margin-left: auto; font-size: 10px; color: var(--text-muted); font-weight: 600; background: var(--bg-tertiary); padding: 1px 5px; border-radius: 3px; }
  .hm-node-halo { pointer-events: none; }

  .flowlog-footer {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 24px; border-top: 1px solid var(--border); font-size: 12px; color: var(--text-muted);
  }
  .flowlog-footer .fl-stats { display: flex; gap: 16px; }
  .flowlog-footer .fl-stat-label { color: var(--text-muted); }
  .flowlog-footer .fl-stat-value { font-weight: 600; color: var(--text-secondary); margin-left: 4px; }
  .fl-stat-accept { color: var(--success) !important; }
  .fl-stat-reject { color: var(--danger) !important; }
  .fl-page-controls { display: flex; align-items: center; gap: 6px; }
  .fl-page-controls button {
    padding: 3px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;
    background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border); font-family: inherit;
  }
  .fl-page-controls button:hover { background: var(--bg-hover); }
  .fl-page-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
</style>
</head>
<body>

<!-- Sidebar -->
<aside class="sidebar">
  <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()" title="Toggle sidebar">&#x25C0;</button>
  <div class="sidebar-header">
    <div class="brand-row">
      <div class="brand-logo">
        <!-- Official IONOS Cloud logo -->
        <svg width="130" height="24" viewBox="0 0 132.26 24" xmlns="http://www.w3.org/2000/svg" aria-label="IONOS Cloud">
          <g fill="currentColor">
            <path d="M76.08,24c-0.41,0-0.82-0.04-1.21-0.12c-1.73-0.35-3.24-1.43-4.15-2.96l-0.02-0.04c-0.45-0.9-0.15-1.95,0.69-2.46c0.28-0.17,0.6-0.26,0.92-0.26c0.66,0,1.26,0.36,1.59,0.93c0.02,0.03,0.04,0.07,0.06,0.1l0.19,0.26l0.26,0.26c0.32,0.28,0.74,0.49,1.18,0.57c0.71,0.14,1.48-0.04,2.04-0.47c0.61-0.44,0.97-1.1,1.03-1.85c0.06-0.74-0.21-1.48-0.71-1.98c0,0-5.49-5.7-5.73-5.96c-0.14-0.15-0.39-0.4-0.66-0.79c-0.77-1.1-1.02-2.39-0.9-3.67c0.06-0.88,0.33-1.76,0.77-2.54c0,0,0.25-0.43,0.33-0.53c0.29-0.42,0.86-0.97,1.25-1.28c0.38-0.29,0.88-0.55,1.05-0.63c1.08-0.52,2.46-0.77,3.82-0.48c1.69,0.36,3.15,1.42,4.01,2.9c0.25,0.41,0.32,0.9,0.19,1.38c-0.13,0.48-0.43,0.87-0.87,1.12c-0.26,0.16-0.57,0.24-0.89,0.24c-0.65,0-1.27-0.36-1.58-0.93c-0.35-0.59-0.92-0.99-1.6-1.13c-0.66-0.13-1.39,0.03-1.94,0.44c-0.53,0.4-0.86,1.02-0.92,1.71c-0.05,0.69,0.18,1.35,0.65,1.85l5.61,5.78c1.22,1.26,1.86,3.01,1.74,4.78c-0.16,1.8-1.05,3.43-2.45,4.48C78.76,23.55,77.43,24,76.08,24"/>
            <path d="M58.33,3.64c-1.32,0-2.39,1.07-2.39,2.39v11.93c0,1.34,1.05,2.39,2.39,2.39c1.32,0,2.39-1.07,2.39-2.39V6.03C60.72,4.74,59.63,3.64,58.33,3.64 M58.33,24c-3.33,0-6.03-2.71-6.03-6.03V6.03C52.3,2.71,55.01,0,58.33,0c3.33,0,6.03,2.71,6.03,6.03v11.93C64.37,21.29,61.66,24,58.33,24"/>
            <path d="M34.73,1.03c0,0-0.01-0.03-0.02-0.03c-0.31-0.61-0.97-0.99-1.65-0.99c-0.13,0-0.25,0.01-0.37,0.04c-0.85,0.17-1.44,0.9-1.44,1.77v0.42L41.28,23c0.33,0.61,0.96,1,1.62,1c0.15,0,0.29-0.02,0.42-0.05c0.84-0.18,1.42-0.9,1.42-1.77v-0.39C44.73,21.78,35,1.59,34.73,1.03 M44.76,19.26V1.82c0-1.02-0.8-1.82-1.82-1.82c-1.02,0-1.82,0.8-1.82,1.82v9.88L44.76,19.26z M34.88,12.31v9.87c0,1.02-0.8,1.82-1.82,1.82c-1.02,0-1.82-0.8-1.82-1.82V4.75L34.88,12.31z"/>
            <path d="M17.61,3.64c-0.64,0-1.24,0.25-1.69,0.7c-0.45,0.45-0.7,1.05-0.7,1.69v11.93c0,0.65,0.25,1.25,0.69,1.7c0.45,0.45,1.05,0.69,1.7,0.69c0.64,0,1.24-0.25,1.69-0.7c0.45-0.45,0.7-1.05,0.7-1.69V6.03c0-0.62-0.25-1.22-0.71-1.68C18.83,3.9,18.24,3.64,17.61,3.64 M17.61,24c-1.61,0-3.12-0.63-4.26-1.77c-1.14-1.14-1.77-2.65-1.77-4.26V6.03c0-1.61,0.63-3.12,1.77-4.26C14.49,0.63,16,0,17.61,0c1.61,0,3.12,0.63,4.26,1.77c1.14,1.14,1.77,2.65,1.77,4.26v11.93c0,1.61-0.63,3.12-1.77,4.26C20.74,23.37,19.22,24,17.61,24"/>
            <path d="M1.98,23.99c-1.11,0-1.98-0.88-1.98-2V1.99l0-0.04C0.02,0.87,0.89,0,1.99,0C2.9,0,3.66,0.59,3.9,1.46C3.91,1.49,3.92,1.54,3.93,1.6l0.01,0.09C3.96,1.8,3.97,1.9,3.97,2c0,0,0,19.75,0,19.98C3.97,23.11,3.1,23.99,1.98,23.99"/>
            <path d="M126.91,20.1c-0.36-0.51-0.54-1.19-0.54-2.04c0-0.9,0.18-1.59,0.53-2.08c0.35-0.49,0.85-0.73,1.5-0.73c0.77,0,1.35,0.29,1.75,0.88v3.85c-0.38,0.59-0.97,0.88-1.75,0.88C127.77,20.87,127.27,20.61,126.91,20.1 M130.15,22v0.67h2.11v-13l-2.11,0.95v3.49c-0.49-0.58-1.18-0.86-2.07-0.86c-1.13,0-2.05,0.43-2.75,1.3c-0.71,0.86-1.06,2.03-1.06,3.51c0,1.51,0.34,2.69,1.03,3.55s1.61,1.28,2.79,1.28C129,22.88,129.69,22.59,130.15,22 M122.56,22.67v-9.2h-2.11v5.29c0,1.4-0.62,2.11-1.85,2.11c-1.15,0-1.73-0.71-1.73-2.14v-5.26h-2.11v5.63c0,1.31,0.31,2.27,0.92,2.87c0.61,0.61,1.4,0.91,2.36,0.91c1.03,0,1.84-0.37,2.41-1.1v0.88H122.56z M107.42,20.12c-0.38-0.5-0.57-1.18-0.57-2.04c0-0.86,0.19-1.55,0.58-2.06c0.38-0.51,0.89-0.77,1.53-0.77c0.66,0,1.18,0.25,1.56,0.76c0.38,0.5,0.57,1.19,0.57,2.07c0,0.88-0.19,1.56-0.57,2.05c-0.38,0.49-0.9,0.74-1.56,0.74C108.32,20.87,107.8,20.62,107.42,20.12 M112.06,21.6c0.76-0.85,1.13-2.03,1.13-3.53c0-1.5-0.38-2.68-1.14-3.54c-0.76-0.86-1.79-1.29-3.09-1.29s-2.32,0.43-3.08,1.29c-0.76,0.86-1.13,2.04-1.13,3.54c0,1.5,0.38,2.68,1.13,3.53s1.78,1.28,3.08,1.28C110.27,22.88,111.3,22.46,112.06,21.6 M103,22.67v-13l-2.11,0.99v12.01H103z M99.31,19.93l-2-0.76c-0.65,1.08-1.45,1.62-2.41,1.62c-0.98,0-1.74-0.44-2.26-1.33c-0.52-0.89-0.78-1.92-0.78-3.1c0-0.53,0.05-1.04,0.15-1.54c0.1-0.5,0.26-0.97,0.49-1.42c0.22-0.45,0.54-0.81,0.95-1.08c0.41-0.27,0.9-0.4,1.45-0.4c0.56,0,1.03,0.12,1.39,0.36c0.37,0.24,0.72,0.62,1.05,1.13l1.94-0.88c-0.3-0.74-0.83-1.38-1.58-1.9c-0.76-0.52-1.69-0.78-2.81-0.78c-0.92,0-1.74,0.2-2.45,0.6c-0.71,0.4-1.26,0.93-1.66,1.58c-0.4,0.65-0.69,1.35-0.88,2.08c-0.19,0.73-0.29,1.48-0.29,2.25c0,0.65,0.06,1.27,0.17,1.87c0.11,0.6,0.3,1.19,0.57,1.76c0.26,0.58,0.59,1.07,0.98,1.49c0.39,0.42,0.89,0.76,1.5,1.01c0.61,0.25,1.3,0.38,2.05,0.38C96.97,22.88,98.44,21.9,99.31,19.93"/>
          </g>
        </svg>
        <div class="brand-subtitle">Network Visualizer</div>
      </div>
      <div class="header-controls">
        <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" data-i18n-tip="theme.toggle" data-tip="Toggle theme">&#9788;</button>
        <div class="locale-dropdown-wrapper">
        <button class="locale-toggle" id="localeToggle" onclick="toggleLocaleMenu()">
          <span class="locale-flag" id="localeFlagDisplay">&#127468;&#127463;</span>
          <span id="localeCodeDisplay">EN</span>
          <span class="locale-caret">&#9662;</span>
        </button>
        <div class="locale-menu" id="localeMenu">
          <button class="locale-btn active" data-lang="en" onclick="setLocale('en')"><span class="locale-flag">&#127468;&#127463;</span> English<span class="locale-check">&#10003;</span></button>
          <button class="locale-btn" data-lang="de" onclick="setLocale('de')"><span class="locale-flag">&#127465;&#127466;</span> Deutsch<span class="locale-check">&#10003;</span></button>
          <button class="locale-btn" data-lang="es" onclick="setLocale('es')"><span class="locale-flag">&#127466;&#127480;</span> Espa&#241;ol<span class="locale-check">&#10003;</span></button>
          <button class="locale-btn" data-lang="fr" onclick="setLocale('fr')"><span class="locale-flag">&#127467;&#127479;</span> Fran&#231;ais<span class="locale-check">&#10003;</span></button>
        </div>
      </div>
      </div><!-- /header-controls -->
    </div><!-- /brand-row -->
  </div><!-- /sidebar-header -->

  <div class="sidebar-section account-section" id="accountSection" style="display:none;">
    <div class="account-info" id="accountInfo"></div>
  </div>

  <div class="sidebar-section">
    <label for="tokenInput" data-i18n="sidebar.apiToken">API Token</label>
    <input type="password" id="tokenInput" placeholder="Paste your IONOS Cloud API token" data-i18n-placeholder="sidebar.tokenPlaceholder">
    <button class="btn btn-primary" id="connectBtn" onclick="connect()" data-i18n="sidebar.connect">Connect</button>
  </div>

  <div class="sidebar-section">
    <label data-i18n="sidebar.viewMode">View Mode</label>
    <div class="view-mode-group">
      <button class="btn btn-primary btn-sm view-mode-btn active" id="viewModeMap" onclick="setViewMode('map')" data-i18n="sidebar.globalMap">Global Map</button>
      <button class="btn btn-secondary btn-sm view-mode-btn" id="viewModeSingle" onclick="setViewMode('single')" data-i18n="sidebar.singleVdc">Single VDC</button>
      <button class="btn btn-secondary btn-sm view-mode-btn" id="viewModeLocation" onclick="setViewMode('location')" data-i18n="sidebar.byLocation">By Location</button>
    </div>
    <div id="mapView">
      <div style="font-size:12px;color:var(--text-secondary);line-height:1.5;padding:4px 0;" data-i18n="sidebar.mapInstruction">
        Click a region bubble on the map to see VDCs at that location, then select a VDC to view its topology.
      </div>
    </div>
    <div id="singleVdcView" style="display:none;">
      <label style="margin-top:4px;" data-i18n="sidebar.vdc">Virtual Data Center</label>
      <div class="vdc-controls-wrapper">
        <select id="dcSelect" disabled onchange="loadVDC(); updatePinButton();">
          <option value="" data-i18n="sidebar.connectFirst">-- Connect first --</option>
        </select>
        <button class="pin-vdc-btn" id="pinVdcBtn" onclick="togglePinVDC()" title="Pin VDC" data-i18n-tip="sidebar.pinVdc" disabled>&#9734;</button>
      </div>
      <button class="btn btn-secondary" id="refreshBtn" onclick="loadVDC()" disabled data-i18n="sidebar.refresh">Refresh</button>
    </div>
    <div id="locationView" style="display:none;">
      <label style="margin-top:4px;" data-i18n="sidebar.location">Location</label>
      <select id="locSelect" disabled onchange="loadLocation()">
        <option value="" data-i18n="sidebar.connectFirst">-- Connect first --</option>
      </select>
      <button class="btn btn-secondary" id="refreshLocBtn" onclick="loadLocation()" disabled data-i18n="sidebar.refresh">Refresh</button>
    </div>
  </div>

  <div class="sidebar-section" id="legendSection" style="display:none;">
    <label><span data-i18n="sidebar.resources">Resources</span> <span id="totalCount" style="float:right;font-weight:400;text-transform:none;letter-spacing:0;"></span></label>
    <ul class="legend-list" id="legendList"></ul>
  </div>

  <div class="sidebar-section" id="ipBlockSection" style="display:none;">
    <label data-i18n="sidebar.publicIps">Public IPs</label>
    <div class="ip-block-panel" id="ipBlockPanel"></div>
  </div>

  <div class="sidebar-section" id="dnsSection" style="display:none;">
    <label><span data-i18n="sidebar.dnsZones">DNS Zones</span> <span id="dnsZoneCount" style="float:right;font-weight:400;text-transform:none;letter-spacing:0;font-size:11px;"></span></label>
    <div class="dns-panel" id="dnsPanel"></div>
  </div>

  <!-- Author Footer -->
  <div class="sidebar-footer">
    <span class="author-text" data-i18n="sidebar.builtBy">Built by Rijesh Haridas</span>
    <div class="author-links">
      <a href="https://www.linkedin.com/in/rijesh-haridas" target="_blank" rel="noopener noreferrer" title="LinkedIn">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
      </a>
      <a href="https://github.com/rijeshharidas" target="_blank" rel="noopener noreferrer" title="GitHub">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      </a>
      <a href="https://github.com/sponsors/rijeshharidas" target="_blank" rel="noopener noreferrer" title="Sponsor">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="#db61a2"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
      </a>
    </div>
  </div>
</aside>

<!-- Main Visualization -->
<div class="main-area" id="mainArea">
  <div id="mapBackground"></div>
  <button class="map-back-btn" id="mapBackBtn" onclick="showMapOverview()" data-i18n="map.allRegions">&#x2190; All Regions</button>
  <div class="map-billing-panel hidden" id="mapBillingPanel"></div>
  <button class="sidebar-expand" id="sidebarExpand" onclick="toggleSidebar()" title="Show sidebar">&#x25B6;</button>
  <div class="canvas-search" id="searchSection" style="display:none;">
    <div class="search-box">
      <svg class="search-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>
      <input type="text" id="searchInput" placeholder="Search resources..." data-i18n-placeholder="search.placeholder" oninput="searchNodes(this.value)">
      <button class="search-clear" id="searchClear" onclick="clearSearch()" style="display:none;">&times;</button>
    </div>
    <div class="search-results" id="searchResults"></div>
  </div>

  <!-- Highlights Overlay -->
  <div class="highlights-overlay" id="highlightsOverlay">
    <div class="hl-title" data-i18n="highlights.title">Highlights</div>
    <div class="highlight-checkbox">
      <input type="checkbox" id="hlFirewall" onchange="applyHighlights()">
      <span class="hl-dot hl-dot-firewall"></span>
      <span data-i18n="highlights.firewall">Firewall Active</span>
    </div>
    <div class="highlight-checkbox">
      <input type="checkbox" id="hlFlowLogs" onchange="applyHighlights()">
      <span class="hl-dot hl-dot-flowlogs"></span>
      <span data-i18n="highlights.flowLogs">Flow Logs</span>
    </div>
    <div class="highlight-checkbox">
      <input type="checkbox" id="hlSecGroups" onchange="applyHighlights()">
      <span class="hl-dot hl-dot-secgroups"></span>
      <span data-i18n="highlights.secGroups">Security Groups</span>
    </div>
    <div class="highlight-checkbox">
      <input type="checkbox" id="hlIPv6" onchange="applyHighlights()">
      <span class="hl-dot hl-dot-ipv6"></span>
      <span data-i18n="highlights.ipv6">IPv6 Enabled</span>
    </div>
    <div class="highlight-checkbox">
      <input type="checkbox" id="hlFailover" onchange="applyHighlights()">
      <span class="hl-dot hl-dot-failover"></span>
      <span data-i18n="highlights.ipFailover">IP Failover</span>
    </div>
    <div class="highlight-checkbox">
      <input type="checkbox" id="hlPCC" onchange="applyHighlights()">
      <span class="hl-dot hl-dot-pcc"></span>
      <span data-i18n="highlights.crossConnect">Cross Connect</span>
    </div>
  </div>

  <!-- Security Posture Overlay -->
  <div class="security-overlay" id="securityOverlay" style="display:none;" onclick="closeSecurityOverlay()" role="dialog" aria-modal="true">
    <div class="security-panel" onclick="event.stopPropagation()">
      <div class="detail-header">
        <h2 data-i18n="security.title">Security Posture</h2>
        <button class="detail-close" onclick="closeSecurityOverlay()">&times;</button>
      </div>
      <div class="security-metrics" id="securityMetrics"></div>
    </div>
  </div>

  <div class="empty-state" id="emptyState">
    <div class="onboarding">
      <div class="onboarding-header">
        <!-- Official IONOS Cloud logo (onboarding) -->
        <svg width="180" height="32" viewBox="0 0 132.26 24" xmlns="http://www.w3.org/2000/svg" aria-label="IONOS Cloud" style="width:180px;height:auto;">
          <g fill="currentColor">
            <path d="M1.98,23.99c-1.11,0-1.98-0.88-1.98-2V1.99l0-0.04C0.02,0.87,0.89,0,1.99,0C2.9,0,3.66,0.59,3.9,1.46C3.91,1.49,3.92,1.54,3.93,1.6l0.01,0.09C3.96,1.8,3.97,1.9,3.97,2c0,0,0,19.75,0,19.98C3.97,23.11,3.1,23.99,1.98,23.99"/>
            <path d="M17.61,3.64c-0.64,0-1.24,0.25-1.69,0.7c-0.45,0.45-0.7,1.05-0.7,1.69v11.93c0,0.65,0.25,1.25,0.69,1.7c0.45,0.45,1.05,0.69,1.7,0.69c0.64,0,1.24-0.25,1.69-0.7c0.45-0.45,0.7-1.05,0.7-1.69V6.03c0-0.62-0.25-1.22-0.71-1.68C18.83,3.9,18.24,3.64,17.61,3.64 M17.61,24c-1.61,0-3.12-0.63-4.26-1.77c-1.14-1.14-1.77-2.65-1.77-4.26V6.03c0-1.61,0.63-3.12,1.77-4.26C14.49,0.63,16,0,17.61,0c1.61,0,3.12,0.63,4.26,1.77c1.14,1.14,1.77,2.65,1.77,4.26v11.93c0,1.61-0.63,3.12-1.77,4.26C20.74,23.37,19.22,24,17.61,24"/>
            <path d="M34.73,1.03c0,0-0.01-0.03-0.02-0.03c-0.31-0.61-0.97-0.99-1.65-0.99c-0.13,0-0.25,0.01-0.37,0.04c-0.85,0.17-1.44,0.9-1.44,1.77v0.42L41.28,23c0.33,0.61,0.96,1,1.62,1c0.15,0,0.29-0.02,0.42-0.05c0.84-0.18,1.42-0.9,1.42-1.77v-0.39C44.73,21.78,35,1.59,34.73,1.03 M44.76,19.26V1.82c0-1.02-0.8-1.82-1.82-1.82c-1.02,0-1.82,0.8-1.82,1.82v9.88L44.76,19.26z M34.88,12.31v9.87c0,1.02-0.8,1.82-1.82,1.82c-1.02,0-1.82-0.8-1.82-1.82V4.75L34.88,12.31z"/>
            <path d="M58.33,3.64c-1.32,0-2.39,1.07-2.39,2.39v11.93c0,1.34,1.05,2.39,2.39,2.39c1.32,0,2.39-1.07,2.39-2.39V6.03C60.72,4.74,59.63,3.64,58.33,3.64 M58.33,24c-3.33,0-6.03-2.71-6.03-6.03V6.03C52.3,2.71,55.01,0,58.33,0c3.33,0,6.03,2.71,6.03,6.03v11.93C64.37,21.29,61.66,24,58.33,24"/>
            <path d="M76.08,24c-0.41,0-0.82-0.04-1.21-0.12c-1.73-0.35-3.24-1.43-4.15-2.96l-0.02-0.04c-0.45-0.9-0.15-1.95,0.69-2.46c0.28-0.17,0.6-0.26,0.92-0.26c0.66,0,1.26,0.36,1.59,0.93c0.02,0.03,0.04,0.07,0.06,0.1l0.19,0.26l0.26,0.26c0.32,0.28,0.74,0.49,1.18,0.57c0.71,0.14,1.48-0.04,2.04-0.47c0.61-0.44,0.97-1.1,1.03-1.85c0.06-0.74-0.21-1.48-0.71-1.98c0,0-5.49-5.7-5.73-5.96c-0.14-0.15-0.39-0.4-0.66-0.79c-0.77-1.1-1.02-2.39-0.9-3.67c0.06-0.88,0.33-1.76,0.77-2.54c0,0,0.25-0.43,0.33-0.53c0.29-0.42,0.86-0.97,1.25-1.28c0.38-0.29,0.88-0.55,1.05-0.63c1.08-0.52,2.46-0.77,3.82-0.48c1.69,0.36,3.15,1.42,4.01,2.9c0.25,0.41,0.32,0.9,0.19,1.38c-0.13,0.48-0.43,0.87-0.87,1.12c-0.26,0.16-0.57,0.24-0.89,0.24c-0.65,0-1.27-0.36-1.58-0.93c-0.35-0.59-0.92-0.99-1.6-1.13c-0.66-0.13-1.39,0.03-1.94,0.44c-0.53,0.4-0.86,1.02-0.92,1.71c-0.05,0.69,0.18,1.35,0.65,1.85l5.61,5.78c1.22,1.26,1.86,3.01,1.74,4.78c-0.16,1.8-1.05,3.43-2.45,4.48C78.76,23.55,77.43,24,76.08,24"/>
            <path d="M126.91,20.1c-0.36-0.51-0.54-1.19-0.54-2.04c0-0.9,0.18-1.59,0.53-2.08c0.35-0.49,0.85-0.73,1.5-0.73c0.77,0,1.35,0.29,1.75,0.88v3.85c-0.38,0.59-0.97,0.88-1.75,0.88C127.77,20.87,127.27,20.61,126.91,20.1 M130.15,22v0.67h2.11v-13l-2.11,0.95v3.49c-0.49-0.58-1.18-0.86-2.07-0.86c-1.13,0-2.05,0.43-2.75,1.3c-0.71,0.86-1.06,2.03-1.06,3.51c0,1.51,0.34,2.69,1.03,3.55s1.61,1.28,2.79,1.28C129,22.88,129.69,22.59,130.15,22 M122.56,22.67v-9.2h-2.11v5.29c0,1.4-0.62,2.11-1.85,2.11c-1.15,0-1.73-0.71-1.73-2.14v-5.26h-2.11v5.63c0,1.31,0.31,2.27,0.92,2.87c0.61,0.61,1.4,0.91,2.36,0.91c1.03,0,1.84-0.37,2.41-1.1v0.88H122.56z M107.42,20.12c-0.38-0.5-0.57-1.18-0.57-2.04c0-0.86,0.19-1.55,0.58-2.06c0.38-0.51,0.89-0.77,1.53-0.77c0.66,0,1.18,0.25,1.56,0.76c0.38,0.5,0.57,1.19,0.57,2.07c0,0.88-0.19,1.56-0.57,2.05c-0.38,0.49-0.9,0.74-1.56,0.74C108.32,20.87,107.8,20.62,107.42,20.12 M112.06,21.6c0.76-0.85,1.13-2.03,1.13-3.53c0-1.5-0.38-2.68-1.14-3.54c-0.76-0.86-1.79-1.29-3.09-1.29s-2.32,0.43-3.08,1.29c-0.76,0.86-1.13,2.04-1.13,3.54c0,1.5,0.38,2.68,1.13,3.53s1.78,1.28,3.08,1.28C110.27,22.88,111.3,22.46,112.06,21.6 M103,22.67v-13l-2.11,0.99v12.01H103z M99.31,19.93l-2-0.76c-0.65,1.08-1.45,1.62-2.41,1.62c-0.98,0-1.74-0.44-2.26-1.33c-0.52-0.89-0.78-1.92-0.78-3.1c0-0.53,0.05-1.04,0.15-1.54c0.1-0.5,0.26-0.97,0.49-1.42c0.22-0.45,0.54-0.81,0.95-1.08c0.41-0.27,0.9-0.4,1.45-0.4c0.56,0,1.03,0.12,1.39,0.36c0.37,0.24,0.72,0.62,1.05,1.13l1.94-0.88c-0.3-0.74-0.83-1.38-1.58-1.9c-0.76-0.52-1.69-0.78-2.81-0.78c-0.92,0-1.74,0.2-2.45,0.6c-0.71,0.4-1.26,0.93-1.66,1.58c-0.4,0.65-0.69,1.35-0.88,2.08c-0.19,0.73-0.29,1.48-0.29,2.25c0,0.65,0.06,1.27,0.17,1.87c0.11,0.6,0.3,1.19,0.57,1.76c0.26,0.58,0.59,1.07,0.98,1.49c0.39,0.42,0.89,0.76,1.5,1.01c0.61,0.25,1.3,0.38,2.05,0.38C96.97,22.88,98.44,21.9,99.31,19.93"/>
          </g>
        </svg>
        <div class="onboarding-appname" data-i18n="onboarding.title">Network Visualizer</div>
        <p data-i18n="onboarding.subtitle">Visualize, analyze, and get AI-powered insights for your IONOS Cloud infrastructure</p>
      </div>
      <div class="onboarding-steps">
        <div class="onboarding-step">
          <div class="step-number">1</div>
          <div class="step-content">
            <div class="step-title" data-i18n="onboarding.step1Title">Get API Token</div>
            <div class="step-desc" data-i18n-html="onboarding.step1Desc">Generate a token at <a href="https://dcd.ionos.com" target="_blank" style="color:var(--accent);">dcd.ionos.com</a> under Management → Token Manager</div>
          </div>
        </div>
        <div class="onboarding-step">
          <div class="step-number">2</div>
          <div class="step-content">
            <div class="step-title" data-i18n="onboarding.step2Title">Connect</div>
            <div class="step-desc" data-i18n="onboarding.step2Desc">Paste the token in the sidebar and click Connect</div>
          </div>
        </div>
        <div class="onboarding-step">
          <div class="step-number">3</div>
          <div class="step-content">
            <div class="step-title" data-i18n="onboarding.step3Title">Explore</div>
            <div class="step-desc" data-i18n="onboarding.step3Desc">Navigate topology, inspect flow logs, view data transfer, and export</div>
          </div>
        </div>
      </div>

      <!-- Feature carousel -->
      <div class="feature-carousel" id="featureCarousel">
        <div class="feature-carousel-track" id="featureCarouselTrack">
          <div class="feature-slide">
            <div class="feature-slide-icon">🤖</div>
            <div class="feature-slide-content">
              <div class="feature-slide-title">AI Cloud Assistant</div>
              <div class="feature-slide-desc">Ask your infrastructure anything — security audits, cost optimization, traffic analysis. Powered by IONOS AI Model Hub.</div>
            </div>
          </div>
          <div class="feature-slide">
            <div class="feature-slide-icon">🗺️</div>
            <div class="feature-slide-content">
              <div class="feature-slide-title">Global Traffic Map</div>
              <div class="feature-slide-desc">See all your regions on an interactive map with data transfer volumes, VDC clusters, and drill-down to topology.</div>
            </div>
          </div>
          <div class="feature-slide">
            <div class="feature-slide-icon">📡</div>
            <div class="feature-slide-content">
              <div class="feature-slide-title">DNS & CDN Discovery</div>
              <div class="feature-slide-desc">Automatic DNS zone resolution, reverse DNS enrichment, CDN distribution detection — all mapped to your topology.</div>
            </div>
          </div>
          <div class="feature-slide">
            <div class="feature-slide-icon">📜</div>
            <div class="feature-slide-content">
              <div class="feature-slide-title">Flow Log Explorer</div>
              <div class="feature-slide-desc">Drag-and-drop flow logs for traffic analysis with path tracing, threat detection, and AI-powered insights.</div>
            </div>
          </div>
          <div class="feature-slide">
            <div class="feature-slide-icon">📊</div>
            <div class="feature-slide-content">
              <div class="feature-slide-title">Billing & Data Transfer</div>
              <div class="feature-slide-desc">Per-VDC and per-server transfer metrics, 30-day trends, and cost-aware heatmaps from the IONOS Billing API.</div>
            </div>
          </div>
        </div>
        <div class="feature-carousel-dots" id="featureCarouselDots"></div>
      </div>

      <div class="onboarding-footer" data-i18n-html="onboarding.shortcutHint">
        Press <kbd>?</kbd> for keyboard shortcuts
      </div>
    </div>
  </div>

  <svg id="graphSvg"></svg>

  <!-- Post-connect progressive loading screen -->
  <div class="connect-loading-overlay" id="connectLoadingOverlay">
    <div class="connect-loading-title">Setting up your cloud view</div>
    <div class="connect-loading-subtitle">Loading services in the background — your dashboard will be ready in a moment</div>
    <div class="connect-loading-checklist" id="connectLoadingChecklist">
      <div class="connect-loading-item" data-step="auth">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Authenticating & loading contracts</div>
      </div>
      <div class="connect-loading-item" data-step="datacenters">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Discovering data centers</div>
      </div>
      <div class="connect-loading-item" data-step="map">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Building global map</div>
      </div>
      <div class="connect-loading-item" data-step="billing">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Fetching billing & data transfer</div>
      </div>
      <div class="connect-loading-item" data-step="dns">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Resolving DNS zones & CDN</div>
      </div>
      <div class="connect-loading-item" data-step="ready">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">AI Assistant ready</div>
      </div>
    </div>
    <div class="connect-loading-progress"><div class="connect-loading-progress-fill" id="connectLoadingProgressFill"></div></div>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="connect-loading-title" id="vdcLoadingTitle">Loading data center</div>
    <div class="connect-loading-subtitle" id="vdcLoadingSubtitle">Fetching resources and building topology</div>
    <div class="connect-loading-checklist" id="vdcLoadingChecklist">
      <div class="connect-loading-item" data-step="servers">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Fetching servers, LANs & managed services</div>
      </div>
      <div class="connect-loading-item" data-step="nics">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Resolving network interfaces</div>
      </div>
      <div class="connect-loading-item" data-step="k8s">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Loading Kubernetes node pools</div>
      </div>
      <div class="connect-loading-item" data-step="graph">
        <div class="connect-loading-item-icon">
          <div class="connect-loading-spinner"></div>
          <svg class="connect-loading-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>
        </div>
        <div class="connect-loading-item-text">Building topology visualization</div>
      </div>
    </div>
    <div class="connect-loading-progress"><div class="connect-loading-progress-fill" id="vdcLoadingProgressFill"></div></div>
  </div>

  <div class="toolbar" id="toolbar" style="display:none;">
    <button onclick="zoomIn()" aria-label="Zoom in" data-tip="Zoom in (+)" data-i18n-tip="toolbar.zoomIn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35M8 11h6M11 8v6"/></svg>
    </button>
    <button onclick="zoomOut()" aria-label="Zoom out" data-tip="Zoom out (-)" data-i18n-tip="toolbar.zoomOut">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35M8 11h6"/></svg>
    </button>
    <button onclick="toggleLabels()" aria-label="Toggle labels" data-tip="Toggle labels (L)" data-i18n-tip="toolbar.labels">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>
    </button>
    <button onclick="toggleIPView()" id="ipViewBtn" aria-label="Toggle IP view" data-tip="IP view (I)" data-i18n-tip="toolbar.ipView">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2"><path d="M4 9V4h16v5M4 15v5h16v-5"/><text x="12" y="13.5" text-anchor="middle" font-size="8" font-weight="700" font-family="monospace" fill="currentColor" stroke="none">IP</text></svg>
    </button>
    <button onclick="toggleComputeView()" id="computeViewBtn" aria-label="Toggle compute view" data-tip="Compute view (C)" data-i18n-tip="toolbar.computeView">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="12" rx="2"/><path d="M8 20h8M12 16v4"/><text x="12" y="12" text-anchor="middle" font-size="7" font-weight="700" font-family="monospace" fill="currentColor" stroke="none">CPU</text></svg>
    </button>
    <button onclick="toggleHighlightsOverlay()" id="hlOverlayBtn" aria-label="Toggle highlights" data-tip="Highlights (H)" data-i18n-tip="toolbar.highlights">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
    </button>
    <button onclick="toggleMapBackground()" id="mapToggleBtn" class="active" aria-label="Toggle map background" data-tip="Map background (M)" data-i18n-tip="toolbar.mapBg">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/></svg>
    </button>
    <button onclick="openSecurityOverlay()" id="securityBtn" aria-label="Security posture" data-tip="Security posture (S)" data-i18n-tip="toolbar.security">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="M9 12l2 2 4-4"/></svg>
    </button>
    <button onclick="openTableView()" id="tableViewBtn" aria-label="Table view" data-tip="Table view (T)" data-i18n-tip="toolbar.tableView">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M3 15h18M9 3v18M15 3v18"/></svg>
    </button>
    <button onclick="toggleAiPanel()" id="aiToggleBtn" aria-label="AI Assistant" data-tip="AI Cloud Assistant (A)" style="display:none;">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M12 2l2.09 6.26L20 10.27l-4.91 3.82L16.18 22 12 18.27 7.82 22l1.09-7.91L4 10.27l5.91-2.01L12 2z"/></svg>
    </button>
    <div class="flowlog-dropdown-wrapper">
      <button onclick="toggleFlowLogMenu()" id="flowlogMenuBtn" aria-label="Flow Logs" data-tip="Flow Logs" data-i18n-tip="toolbar.flowlogsMenu">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
      </button>
      <div class="flowlog-dropdown" id="flowlogDropdown">
        <button onclick="closeFlowLogMenu(); openFlowLogExplorer();">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
          Flow Log Explorer <span class="fl-dd-shortcut">W</span>
        </button>
        <button onclick="closeFlowLogMenu(); toggleHeatmap();" id="heatmapMenuBtn">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/><circle cx="12" cy="12" r="4" fill="currentColor" opacity="0.3"/></svg>
          Traffic Heatmap <span class="fl-dd-shortcut">X</span>
        </button>
      </div>
    </div>
    <button onclick="setHeatmapMode('billing'); if(!heatmapActive) toggleHeatmap(); else applyHeatmap();" id="billingHeatmapBtn" aria-label="Data Transfer Heatmap" data-tip="Data Transfer Heatmap (B)" data-i18n-tip="shortcuts.billingHeatmap">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><line x1="2" y1="10" x2="22" y2="10"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
    </button>
    <span class="toolbar-divider"></span>
    <div class="export-dropdown-wrapper">
      <button onclick="toggleExportMenu()" id="exportMenuBtn" aria-label="Export" data-tip="Export" data-i18n-tip="toolbar.export">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>
      </button>
      <div class="export-dropdown" id="exportDropdown">
        <div class="export-section-label" data-i18n="export.diagram">Diagram</div>
        <button onclick="exportPNG()" data-i18n="export.png">PNG Image</button>
        <button onclick="exportSVG()" data-i18n="export.svg">SVG Vector</button>
        <div class="export-sep"></div>
        <div class="export-section-label" data-i18n="export.data">Data</div>
        <button onclick="exportJSON()" data-i18n="export.json">JSON Topology</button>
        <button onclick="exportCSV()" data-i18n="export.csv">CSV Table</button>
        <button onclick="exportXLSX()" data-i18n="export.xlsx">XLSX Workbook</button>
        <div class="export-sep"></div>
        <div class="export-section-label" data-i18n="export.report">Report</div>
        <button onclick="exportPDF()" data-i18n="export.pdf">PDF Report</button>
      </div>
    </div>
    <span class="toolbar-divider"></span>
    <button onclick="resetView()" aria-label="Reset view" data-tip="Reset & fit view (R)" data-i18n-tip="toolbar.resetView">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 00-2 2v3m18 0V5a2 2 0 00-2-2h-3m0 18h3a2 2 0 002-2v-3M3 16v3a2 2 0 002 2h3"/></svg>
    </button>
    <span class="toolbar-divider"></span>
    <button onclick="setViewMode('map')" aria-label="Global map view" data-tip="Global map (G)" data-i18n-tip="toolbar.globalMap">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10A15.3 15.3 0 0112 2z"/></svg>
    </button>
  </div>
</div>

<!-- Detail Panel -->
<div class="detail-panel" id="detailPanel">
  <div class="detail-content" id="detailContent"></div>
</div>

<!-- AI Assistant Panel -->
<div class="ai-panel" id="aiPanel">
  <div class="ai-header">
    <div class="ai-title">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#a855f7" stroke-width="2" stroke-linecap="round"><path d="M12 2l2.09 6.26L20 10.27l-4.91 3.82L16.18 22 12 18.27 7.82 22l1.09-7.91L4 10.27l5.91-2.01L12 2z"/></svg>
      <span>AI Cloud Assistant</span>
    </div>
    <div class="ai-controls">
      <label class="ai-docs-toggle" title="Search IONOS documentation for relevant context">
        <input type="checkbox" id="aiDocsToggle" checked onchange="aiDocsSearchEnabled=this.checked">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 014 19.5v-15A2.5 2.5 0 016.5 2z"/></svg>
        <span>Docs</span>
      </label>
      <select id="aiModelSelect" onchange="aiSelectedModel=this.value" title="Select AI model"></select>
      <button class="detail-close" onclick="closeAiPanel()" title="Close">&times;</button>
    </div>
  </div>
  <div class="ai-cost-banner" id="aiCostBanner">
    <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 1L1 14h14L8 1z"/><line x1="8" y1="6" x2="8" y2="9"/><circle cx="8" cy="11.5" r="0.5" fill="currentColor"/></svg>
    <span>AI queries use the <strong>IONOS AI Model Hub</strong> and may incur costs on your account.</span>
    <button onclick="dismissAiCostBanner()">Understood</button>
  </div>
  <div class="ai-messages" id="aiMessages">
    <div class="ai-welcome">
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#a855f7" stroke-width="1.5" stroke-linecap="round"><path d="M12 2l2.09 6.26L20 10.27l-4.91 3.82L16.18 22 12 18.27 7.82 22l1.09-7.91L4 10.27l5.91-2.01L12 2z"/></svg>
      <div>Ask about your cloud infrastructure — topology, security posture, billing, traffic, or flow log analysis.<br>The AI receives a context summary of all loaded data.</div>
    </div>
  </div>
  <div class="ai-suggestions" id="aiSuggestions"></div>
  <div class="ai-input-area">
    <textarea id="aiInput" rows="2" placeholder="Ask about your infrastructure..." onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendAiMessage();}"></textarea>
    <button id="aiSendBtn" onclick="sendAiMessage()">Send</button>
  </div>
</div>

<!-- Tooltip -->
<div class="tooltip" id="tooltip"></div>

<!-- Heatmap Legend -->
<div class="heatmap-legend hidden" id="heatmapLegend">
  <h4 id="hmTitle">Traffic Heatmap</h4>
  <div class="hl-mode-toggle">
    <button class="hl-mode-btn active" id="hmModeVolume" onclick="setHeatmapMode('volume')">Volume</button>
    <button class="hl-mode-btn" id="hmModeSecurity" onclick="setHeatmapMode('security')">Security</button>
    <button class="hl-mode-btn" id="hmModeBilling" onclick="setHeatmapMode('billing')">Transfer</button>
  </div>
  <div class="heatmap-gradient volume" id="hmGradient"></div>
  <div class="heatmap-gradient-labels" id="hmGradientLabels">
    <span>Low</span><span>High</span>
  </div>
  <div class="hl-stats" id="hmStats"></div>
</div>

<!-- Toast Container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Shortcuts Overlay -->
<div class="shortcuts-overlay" id="shortcutsOverlay" style="display:none;" onclick="this.style.display='none'" role="dialog" aria-modal="true" aria-label="Keyboard shortcuts">
  <div class="shortcuts-dialog" onclick="event.stopPropagation()">
    <div class="detail-header">
      <h2 data-i18n="shortcuts.title">Keyboard Shortcuts</h2>
      <button class="detail-close" onclick="document.getElementById('shortcutsOverlay').style.display='none'">&times;</button>
    </div>
    <table class="detail-table">
      <tr><th>Esc</th><td data-i18n="shortcuts.close">Close panel / overlay</td></tr>
      <tr><th>Ctrl+F</th><td data-i18n="shortcuts.search">Focus search bar</td></tr>
      <tr><th>+ / -</th><td data-i18n="shortcuts.zoomInOut">Zoom in / out</td></tr>
      <tr><th>L</th><td data-i18n="shortcuts.labels">Toggle labels</td></tr>
      <tr><th>I</th><td data-i18n="shortcuts.ipView">Toggle IP view</td></tr>
      <tr><th>C</th><td data-i18n="shortcuts.computeView">Toggle compute view</td></tr>
      <tr><th>H</th><td data-i18n="shortcuts.highlights">Toggle highlights</td></tr>
      <tr><th>M</th><td data-i18n="shortcuts.mapBg">Toggle map background</td></tr>
      <tr><th>G</th><td data-i18n="shortcuts.globalMap">Global map view</td></tr>
      <tr><th>T</th><td data-i18n="shortcuts.tableView">Resource table view</td></tr>
      <tr><th>F / R</th><td data-i18n="shortcuts.resetView">Reset & fit to view</td></tr>
      <tr><th>S</th><td data-i18n="shortcuts.security">Security posture</td></tr>
      <tr><th>W</th><td data-i18n="shortcuts.flowlogs">Flow Log Explorer</td></tr>
      <tr><th>X</th><td data-i18n="shortcuts.heatmap">Traffic Heatmap</td></tr>
      <tr><th>B</th><td data-i18n="shortcuts.billingHeatmap">Data Transfer Heatmap</td></tr>
      <tr><th>A</th><td data-i18n="shortcuts.aiAssistant">AI Cloud Assistant</td></tr>
      <tr><th>?</th><td data-i18n="shortcuts.help">Show this help</td></tr>
    </table>
  </div>
</div>

<!-- Table View Overlay -->
<div class="table-overlay" id="tableOverlay" style="display:none;" onclick="closeTableView()" role="dialog" aria-modal="true" aria-label="Resource table">
  <div class="table-dialog" onclick="event.stopPropagation()">
    <div class="table-header">
      <h2 data-i18n="table.title">Resource Table</h2>
      <div class="table-controls">
        <input type="text" id="tableSearch" placeholder="Search resources..." data-i18n-placeholder="table.searchPlaceholder" oninput="filterTable()">
        <button class="table-csv-btn" onclick="exportTableCSV()">&#8681; CSV</button>
        <button class="detail-close" onclick="closeTableView()">&times;</button>
      </div>
    </div>
    <div class="table-filters" id="tableFilters"></div>
    <div class="table-scroll">
      <table class="resource-table" id="resourceTable">
        <thead id="resourceTableHead"></thead>
        <tbody id="resourceTableBody"></tbody>
      </table>
    </div>
    <div class="table-footer" id="tableFooter"></div>
  </div>
</div>

<!-- Flow Log Context Menu -->
<div class="fl-context-menu" id="flContextMenu">
  <div class="fl-ctx-item" data-action="copy-row"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy Row</div>
  <div class="fl-ctx-item" data-action="copy-src-ip"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy Source IP</div>
  <div class="fl-ctx-item" data-action="copy-dst-ip"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy Dest IP</div>
  <div class="fl-ctx-item" data-action="copy-nic"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy NIC UUID</div>
  <div class="fl-ctx-sep"></div>
  <div class="fl-ctx-item" data-action="copy-json"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2h5l4 4v8a1 1 0 01-1 1H4a1 1 0 01-1-1V3a1 1 0 011-1z"/><path d="M9 2v4h4"/></svg>Copy as JSON</div>
  <div class="fl-ctx-item" data-action="filter-src"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M1 3h14M3 7h10M5 11h6"/></svg>Filter by Source IP</div>
  <div class="fl-ctx-item" data-action="filter-dst"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M1 3h14M3 7h10M5 11h6"/></svg>Filter by Dest IP</div>
</div>

<!-- Flow Log Explorer Overlay -->
<div class="flowlog-overlay" id="flowlogOverlay" style="display:none;" role="dialog" aria-modal="true" aria-label="Flow Log Explorer">
  <div class="flowlog-dialog" id="flowlogDialog">
    <div class="fl-dock-resize" id="flDockResize"></div>
    <div class="flowlog-header">
      <h2>
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
        Flow Log Explorer
        <span class="fl-count" id="flRecordCount"></span>
        <span class="fl-drag-hint">&#x2725; drag to move</span>
      </h2>
      <div class="flowlog-controls">
        <input type="text" id="flSearch" placeholder="Search IPs, ports..." oninput="filterFlowLogs()">
        <button class="fl-btn fl-btn-accent" onclick="document.getElementById('flFileInput').click()">+ Add Files</button>
        <button class="fl-btn" onclick="exportFlowLogCSV()" id="flExportBtn" style="display:none;">&#8681; CSV</button>
        <button class="fl-btn" onclick="clearFlowLogs()" id="flClearBtn" style="display:none;">Clear</button>
        <button class="fl-btn fl-btn-dock" onclick="toggleFlowLogDock()" id="flDockBtn" title="Dock to bottom (see map while browsing)">
          <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="1" width="14" height="14" rx="2"/><line x1="1" y1="9" x2="15" y2="9"/></svg>
        </button>
        <button class="fl-btn" onclick="popOutFlowLogExplorer()" id="flPopoutBtn" title="Open in separate window (drag to second monitor)">
          <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="4" width="11" height="11" rx="2"/><polyline points="7 1 15 1 15 9"/><line x1="15" y1="1" x2="9" y2="7"/></svg>
        </button>
        <button class="detail-close" onclick="closeFlowLogExplorer()">&times;</button>
      </div>
    </div>
    <div class="flowlog-filters" id="flFilters" style="display:none;">
      <label>Action:</label>
      <select id="flFilterAction" onchange="filterFlowLogs()">
        <option value="">All</option>
        <option value="ACCEPT">ACCEPT</option>
        <option value="REJECT">REJECT</option>
      </select>
      <span class="fl-filter-sep"></span>
      <label>Protocol:</label>
      <select id="flFilterProto" onchange="filterFlowLogs()">
        <option value="">All</option>
        <option value="6">TCP (6)</option>
        <option value="17">UDP (17)</option>
        <option value="1">ICMP (1)</option>
      </select>
      <span class="fl-filter-sep"></span>
      <label>Src IP:</label>
      <input type="text" id="flFilterSrc" placeholder="e.g. 10.0.0" oninput="filterFlowLogs()">
      <span class="fl-filter-sep"></span>
      <label>Dst IP:</label>
      <input type="text" id="flFilterDst" placeholder="e.g. 192.168" oninput="filterFlowLogs()">
      <span class="fl-filter-sep"></span>
      <label>Port:</label>
      <input type="text" id="flFilterPort" placeholder="e.g. 443" oninput="filterFlowLogs()" style="width:70px;">
      <span class="fl-filter-sep"></span>
      <label>NIC:</label>
      <select id="flFilterNic" onchange="filterFlowLogs()">
        <option value="">All NICs</option>
      </select>
    </div>
    <div class="fl-file-pills" id="flFilePills" style="display:none;"></div>
    <div class="flowlog-body" id="flBody">
      <div class="fl-dropzone" id="flDropzone">
        <div class="fl-dropzone-icon">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
        </div>
        <div class="fl-dropzone-title">Drop .log.gz files here</div>
        <div class="fl-dropzone-subtitle">
          Upload IONOS Flow Log files to explore traffic records. Files are parsed locally in your browser — nothing is uploaded to any server.
          <br><br>
          File format: <code style="color:var(--accent); font-size:11px;">{nic-uuid}-{epoch}.log.gz</code>
        </div>
        <button class="fl-dropzone-btn" onclick="document.getElementById('flFileInput').click()">Browse Files</button>
      </div>
    </div>
    <input type="file" id="flFileInput" multiple accept=".gz,.log,.log.gz" style="display:none;" onchange="handleFlowLogFiles(this.files)">
    <div class="flowlog-footer" id="flFooter" style="display:none;">
      <div class="fl-stats">
        <span><span class="fl-stat-label">Records:</span><span class="fl-stat-value" id="flStatTotal">0</span></span>
        <span><span class="fl-stat-label">Accepted:</span><span class="fl-stat-value fl-stat-accept" id="flStatAccept">0</span></span>
        <span><span class="fl-stat-label">Rejected:</span><span class="fl-stat-value fl-stat-reject" id="flStatReject">0</span></span>
        <span><span class="fl-stat-label">Files:</span><span class="fl-stat-value" id="flStatFiles">0</span></span>
        <span><span class="fl-stat-label">Shown:</span><span class="fl-stat-value" id="flStatShown">0</span></span>
        <span><span class="fl-stat-label">Tagged:</span><span class="fl-stat-value" id="flStatTagged" style="color:var(--accent)">0</span></span>
      </div>
      <div class="fl-page-controls">
        <button onclick="flPagePrev()" id="flPrevBtn" disabled>&laquo; Prev</button>
        <span id="flPageInfo">Page 1</span>
        <button onclick="flPageNext()" id="flNextBtn">Next &raquo;</button>
      </div>
    </div>
    <div class="fl-resize-handle"><svg width="10" height="10" viewBox="0 0 10 10"><path d="M9 1L1 9M9 4L4 9M9 7L7 9" stroke="currentColor" stroke-width="1" opacity="0.5"/></svg></div>
  </div>
</div>

<script>
/**
 * IONOS Cloud Network Visualizer
 *
 * Interactive force-directed graph visualization of IONOS Cloud
 * Virtual Data Center resources and their network connections.
 *
 * @requires D3.js v7
 * @see https://api.ionos.com/docs/cloud/v6/
 * @license Apache-2.0
 */

// ============================== CONFIG ==============================
// API endpoints: most services use centralized URLs, while regional services
// (MariaDB, VPN) use location-based subdomains (e.g., mariadb.de/fra.ionos.com)
const API_BASES = {
  cloud: 'https://api.ionos.com/cloudapi/v6',
  dbaas_pg: 'https://api.ionos.com/databases/postgresql',
  dbaas_mongo: 'https://api.ionos.com/databases/mongodb',
  dbaas_mysql: 'https://api.ionos.com/databases/mysql',
  dbaas_mariadb: (loc) => `https://mariadb.${loc}.ionos.com`,
  nfs: 'https://api.ionos.com/nfs',
  vpn: (loc) => `https://vpn.${loc}.ionos.com`,
  kafka: (loc) => `https://kafka.${loc}.ionos.com`,
  k8s: 'https://api.ionos.com/cloudapi/v6',
  dns: 'https://dns.de-fra.ionos.com',
  cdn: 'https://cdn.de-fra.ionos.com',
  billing: 'https://api.ionos.com/billing',
  ai: 'https://openai.inference.de-txl.ionos.com/v1',
};

// ============================== AI MODEL HUB ==============================
const AI_MODELS = [
  { id: 'meta-llama/Meta-Llama-3.1-8B-Instruct', label: 'Llama 3.1 8B' },
  { id: 'mistralai/Mistral-Small-24B-Instruct-2501', label: 'Mistral Small 24B' },
  { id: 'meta-llama/Meta-Llama-3.3-70B-Instruct', label: 'Llama 3.3 70B' },
];
let aiSelectedModel = AI_MODELS[0].id;
let aiConversationHistory = [];
let aiPanelOpen = false;
let aiAbortController = null;
let aiLastRequestTime = 0;
const AI_COOLDOWN_MS = 2000;       // min interval between requests
const AI_TIMEOUT_MS = 45000;       // 45s timeout for LLM inference
const AI_MAX_CONTEXT_CHARS = 12000; // truncate context if too large
let aiDocsSearchEnabled = true;    // search IONOS docs for context
let mcpSessionId = null;           // MCP session header for GitBook
let mcpInitialized = false;        // whether MCP session is established

// ============================== LOCATION FLAGS ==============================
const LOCATION_CITIES = {
  'de/fra': 'Frankfurt', 'de/txl': 'Berlin',
  'us/las': 'Las Vegas', 'us/ewr': 'Newark', 'us/mci': 'Lenexa',
  'gb/lhr': 'London', 'gb/bhx': 'Worcester',
  'es/vit': 'Logrono', 'fr/par': 'Paris',
  'fr/nlb': 'Niederlauterbach',
};

// Coordinates [lat, lon] and zoom level for each IONOS region
const LOCATION_COORDS = {
  'de/fra': [50.1109, 8.6821, 10],   // Frankfurt (+ Frankfurt East de/fra/2)
  'de/txl': [52.5200, 13.4050, 10],   // Berlin
  'us/las': [36.1699, -115.1398, 10], // Las Vegas
  'us/ewr': [40.6895, -74.1745, 10],  // Newark
  'us/mci': [38.9720, -94.7347, 10],  // Lenexa
  'gb/lhr': [51.5074, -0.1278, 10],   // London
  'gb/bhx': [52.1920, -2.2214, 10],   // Worcester
  'es/vit': [42.4627, -2.4500, 10],   // Logrono
  'fr/par': [48.8566, 2.3522, 10],    // Paris
  'fr/nlb': [48.9706, 8.0825, 10],    // Niederlauterbach (Private Cloud only)
};

// Cloud type classification per DC location
const DC_CLOUD_TYPE = {
  'de/fra': 'public',
  'de/txl': 'both',
  'us/las': 'public',
  'us/ewr': 'public',
  'us/mci': 'public',
  'gb/lhr': 'public',
  'gb/bhx': 'both',
  'es/vit': 'both',
  'fr/par': 'public',
  'fr/nlb': 'private',
};

// Cloud type label for tooltips
function cloudLabel(region) {
  const ct = DC_CLOUD_TYPE[region] || 'public';
  return ct === 'both' ? 'Public & Private Cloud' : ct === 'private' ? 'Private Cloud' : 'Public Cloud';
}

// ==================== TRANSLATIONS (i18n) ====================
const TRANSLATIONS = {
  en: {
    // Sidebar
    'sidebar.apiToken': 'API Token',
    'sidebar.tokenPlaceholder': 'Paste your IONOS Cloud API token',
    'sidebar.connect': 'Connect',
    'sidebar.disconnect': 'Disconnect',
    'sidebar.viewMode': 'View Mode',
    'sidebar.globalMap': 'Global Map',
    'sidebar.singleVdc': 'Single VDC',
    'sidebar.byLocation': 'By Location',
    'sidebar.mapInstruction': 'Click a region bubble on the map to see VDCs at that location, then select a VDC to view its topology.',
    'sidebar.vdc': 'Virtual Data Center',
    'sidebar.location': 'Location',
    'sidebar.connectFirst': '-- Connect first --',
    'sidebar.refresh': 'Refresh',
    'sidebar.resources': 'Resources',
    'sidebar.publicIps': 'Public IPs',
    'sidebar.dnsZones': 'DNS Zones',
    'sidebar.builtBy': 'Built by Rijesh Haridas',
    'sidebar.pinVdc': 'Pin / Unpin VDC',
    // Account
    'account.email': 'Email',
    'account.contract': 'Contract',
    // Toolbar
    'toolbar.zoomIn': 'Zoom in (+)',
    'toolbar.zoomOut': 'Zoom out (-)',
    'toolbar.fitView': 'Reset & fit view (F)',
    'toolbar.labels': 'Toggle labels (L)',
    'toolbar.ipView': 'IP view (I)',
    'toolbar.computeView': 'Compute view (C)',
    'toolbar.highlights': 'Highlights (H)',
    'toolbar.mapBg': 'Map background (M)',
    'toolbar.tableView': 'Table view (T)',
    'toolbar.export': 'Export',
    'toolbar.resetView': 'Reset & fit view (R)',
    'toolbar.globalMap': 'Global map (G)',
    // Onboarding
    'onboarding.title': 'Network Visualizer',
    'onboarding.subtitle': 'Visualize, analyze, and get AI-powered insights for your IONOS Cloud infrastructure',
    'onboarding.step1Title': 'Get API Token',
    'onboarding.step1Desc': 'Generate a token at <a href="https://dcd.ionos.com" target="_blank" style="color:var(--accent);">dcd.ionos.com</a> under Management \u2192 Token Manager',
    'onboarding.step2Title': 'Connect',
    'onboarding.step2Desc': 'Paste the token in the sidebar and click Connect',
    'onboarding.step3Title': 'Explore',
    'onboarding.step3Desc': 'Navigate topology, inspect flow logs, view data transfer, and export',
    'onboarding.shortcutHint': 'Press <kbd>?</kbd> for keyboard shortcuts',
    // Shortcuts
    'shortcuts.title': 'Keyboard Shortcuts',
    'shortcuts.close': 'Close panel / overlay',
    'shortcuts.search': 'Focus search bar',
    'shortcuts.zoomInOut': 'Zoom in / out',
    'shortcuts.fitView': 'Reset & fit to view',
    'shortcuts.labels': 'Toggle labels',
    'shortcuts.ipView': 'Toggle IP view',
    'shortcuts.computeView': 'Toggle compute view',
    'shortcuts.highlights': 'Toggle highlights',
    'shortcuts.mapBg': 'Toggle map background',
    'shortcuts.globalMap': 'Global map view',
    'shortcuts.tableView': 'Resource table view',
    'shortcuts.resetView': 'Reset & fit to view',
    'shortcuts.help': 'Show this help',
    'shortcuts.flowlogs': 'Flow Log Explorer',
    'shortcuts.heatmap': 'Traffic Heatmap',
    'shortcuts.billingHeatmap': 'Data Transfer Heatmap',
    // Flow Log Explorer
    'toolbar.flowlogs': 'Flow Log Explorer (W)',
    'toolbar.flowlogsMenu': 'Flow Logs',
    'toolbar.heatmap': 'Traffic Heatmap (X)',
    // Security
    'toolbar.security': 'Security posture (S)',
    'security.title': 'Security Posture',
    'security.firewall': 'Firewall Coverage',
    'security.firewallGood': 'Excellent — most servers have active firewall rules',
    'security.firewallWarn': 'Moderate — consider enabling firewalls on more servers',
    'security.firewallBad': 'Low — many servers lack firewall protection',
    'security.flowlogs': 'Flow Logs',
    'security.flowlogsGood': 'Good flow log coverage for traffic monitoring',
    'security.flowlogsWarn': 'Limited flow log coverage — consider enabling for visibility',
    'security.secgroups': 'Security Groups',
    'security.secgroupsGood': 'Most servers are protected by security groups',
    'security.secgroupsWarn': 'Some servers lack security group protection',
    'security.secgroupsBad': 'Many servers have no security groups assigned',
    'security.privateLans': 'Private LANs',
    'security.privateLansDesc': 'Private LANs reduce exposure to the public internet',
    'security.natGwActive': '{count} NAT Gateway(s) detected \u2014 private LANs have secure outbound access',
    'security.natGwSuggest': 'Tip: Add a NAT Gateway for secure outbound internet access from private LANs',
    'security.ipv6': 'IPv6 Adoption',
    'security.ipv6Good': 'Strong IPv6 adoption across your LANs',
    'security.ipv6Bad': 'Low IPv6 adoption — consider enabling for future-readiness',
    'security.highlightEnabled': '{name} highlight enabled',
    'shortcuts.security': 'Security posture',
    'toast.noVdcLoaded': 'Load a VDC first to view security posture',
    // Highlights
    'highlights.title': 'Highlights',
    'highlights.firewall': 'Firewall Active',
    'highlights.flowLogs': 'Flow Logs',
    'highlights.secGroups': 'Security Groups',
    'highlights.ipv6': 'IPv6 Enabled',
    'highlights.ipFailover': 'IP Failover',
    'highlights.crossConnect': 'Cross Connect',
    // Table
    'table.title': 'Resource Table',
    'table.searchPlaceholder': 'Search resources...',
    'table.csv': 'CSV',
    'table.name': 'Name',
    'table.type': 'Type',
    'table.state': 'State',
    'table.details': 'Details',
    'table.ips': 'IPs',
    'table.showing': 'Showing {count} of {total} resources',
    'table.noMatch': 'No resources match the current filters',
    // Export
    'export.diagram': 'Diagram',
    'export.data': 'Data',
    'export.report': 'Report',
    'export.png': 'PNG Image',
    'export.svg': 'SVG Vector',
    'export.json': 'JSON Topology',
    'export.csv': 'CSV Table',
    'export.xlsx': 'XLSX Workbook',
    'export.pdf': 'PDF Report',
    // Toast
    'toast.pngExported': 'PNG exported',
    'toast.pngFailed': 'PNG export failed \u2014 try a smaller zoom level',
    'toast.svgExported': 'SVG exported',
    'toast.jsonExported': 'JSON topology exported',
    'toast.csvExported': 'CSV exported ({count} rows)',
    'toast.xlsxExported': 'XLSX workbook exported',
    'toast.pdfExported': 'PDF report exported',
    'toast.pdfFailed': 'PDF export failed \u2014 try a smaller zoom level',
    'toast.noData': 'No data to export',
    'toast.noRows': 'No rows to export',
    'toast.noDisplay': 'No data to display',
    'toast.enterToken': 'Please enter an API token',
    'toast.noDataCenters': 'No data centers found',
    'toast.foundDcs': 'Found {count} data center(s)',
    'toast.connectionFailed': 'Connection failed: {error}',
    'toast.disconnected': 'Disconnected',
    'toast.loadedResources': 'Loaded {count} resources',
    'toast.loadFailed': 'Failed to load VDC: {error}',
    'toast.noVdcsLocation': 'No VDCs at this location',
    'toast.loadedLocation': 'Loaded {dcCount} VDC(s) with {nodeCount} total resources',
    'toast.locationFailed': 'Failed to load location: {error}',
    'toast.contractSwitched': 'Switched to Contract {id}',
    'toast.contractFailed': 'Failed to switch contract: {error}',
    'toast.xlsxNotLoaded': 'XLSX library not loaded',
    'toast.pdfNotLoaded': 'PDF library not loaded',
    // Detail
    'detail.connectedResources': 'Connected Resources',
    'detail.networkMetrics': 'Network Metrics',
    'detail.billingTraffic': 'Data Transfer (30d)',
    'detail.noBillingData': 'No data transfer data available',
    'detail.nics': 'Network Interfaces (NICs)',
    'detail.securityRules': 'Security Group Rules',
    'detail.noRules': 'No rules defined',
    'detail.ruleDir': 'Dir',
    'detail.ruleProto': 'Protocol',
    'detail.rulePorts': 'Ports',
    'detail.ruleSource': 'Source',
    'detail.ruleTarget': 'Target',
    'detail.ruleAll': 'All',
    'detail.ruleAny': 'Any',
    'detail.loading': 'Loading...',
    'detail.lanId': 'LAN ID',
    'detail.public': 'Public',
    'detail.ipv4Cidr': 'IPv4 CIDR',
    'detail.ipv6Cidr': 'IPv6 CIDR',
    'detail.crossConnect': 'Cross Connect',
    'detail.ipFailover': 'IP Failover',
    'detail.state': 'State',
    'detail.type': 'Type',
    'detail.cores': 'Cores',
    'detail.ram': 'RAM',
    'detail.cpu': 'CPU',
    'detail.vmState': 'VM State',
    'detail.version': 'Version',
    'detail.instances': 'Instances',
    'detail.storage': 'Storage',
    'detail.dns': 'DNS',
    'detail.publicIps': 'Public IPs',
    'detail.privateIps': 'Private IPs',
    'detail.listenerLan': 'Listener LAN',
    'detail.targetLan': 'Target LAN',
    'detail.pccId': 'PCC ID',
    'detail.cluster': 'Cluster',
    'detail.k8sVersion': 'K8s Version',
    'detail.nodes': 'Nodes',
    'detail.coresPerNode': 'Cores/Node',
    'detail.ramPerNode': 'RAM/Node',
    'detail.size': 'Size',
    'detail.gatewayIp': 'Gateway IP',
    'detail.ifaceIpv4': 'Interface IPv4',
    'detail.ifaceIpv6': 'Interface IPv6',
    'detail.dnsNames': 'DNS Names',
    'detail.reverseDns': 'Reverse DNS',
    'detail.yes': 'Yes',
    'detail.no': 'No',
    'detail.noData': 'No data',
    // Loading
    'loading.authenticating': 'Authenticating',
    'loading.serversLans': 'Servers & LANs',
    'loading.managedServices': 'Managed Services',
    'loading.buildingGraph': 'Building Graph',
    'loading.resources': 'Loading resources...',
    'loading.fetchingDetails': 'Fetching data center details...',
    'loading.fetchingServers': 'Fetching servers, LANs, and managed services...',
    'loading.resolvingNics': 'Resolving server NICs...',
    'loading.fetchingK8s': 'Fetching Kubernetes node pools...',
    'loading.buildingViz': 'Building visualization...',
    'loading.loadingVdcs': 'Loading {count} VDC(s) at {location}...',
    'loading.fetchingShared': 'Fetching shared managed services...',
    'loading.fetchingVdc': 'Fetching VDC {index}/{total}: {name}...',
    'loading.mergingGraphs': 'Merging VDC graphs...',
    // Search
    'search.placeholder': 'Search resources...',
    'search.noMatches': 'No matches found',
    'search.matchCount': '{count} match(es)',
    'search.andMore': '...and {count} more',
    // Map
    'map.allRegions': '\u2190 All Regions',
    // Misc
    'theme.toggle': 'Toggle theme',
    'total': 'total',
  },
  de: {
    'sidebar.apiToken': 'API-Token',
    'sidebar.tokenPlaceholder': 'IONOS Cloud API-Token hier einf\u00fcgen',
    'sidebar.connect': 'Verbinden',
    'sidebar.disconnect': 'Trennen',
    'sidebar.viewMode': 'Ansicht',
    'sidebar.globalMap': 'Weltkarte',
    'sidebar.singleVdc': 'Einzelnes VDC',
    'sidebar.byLocation': 'Nach Standort',
    'sidebar.mapInstruction': 'Klicken Sie auf eine Region, um die VDCs an diesem Standort anzuzeigen, und w\u00e4hlen Sie dann ein VDC aus.',
    'sidebar.vdc': 'Virtuelles Rechenzentrum',
    'sidebar.location': 'Standort',
    'sidebar.connectFirst': '-- Zuerst verbinden --',
    'sidebar.refresh': 'Aktualisieren',
    'sidebar.resources': 'Ressourcen',
    'sidebar.publicIps': '\u00d6ffentliche IPs',
    'sidebar.dnsZones': 'DNS-Zonen',
    'sidebar.builtBy': 'Erstellt von Rijesh Haridas',
    'sidebar.pinVdc': 'VDC anheften / lösen',
    'account.email': 'E-Mail',
    'account.contract': 'Vertrag',
    'toolbar.zoomIn': 'Vergr\u00f6\u00dfern (+)',
    'toolbar.zoomOut': 'Verkleinern (-)',
    'toolbar.fitView': 'Zur\u00fccksetzen & Einpassen (F)',
    'toolbar.labels': 'Beschriftungen (L)',
    'toolbar.ipView': 'IP-Ansicht (I)',
    'toolbar.computeView': 'Compute-Ansicht (C)',
    'toolbar.highlights': 'Hervorhebungen (H)',
    'toolbar.mapBg': 'Kartenhintergrund (M)',
    'toolbar.tableView': 'Tabellenansicht (T)',
    'toolbar.export': 'Exportieren',
    'toolbar.resetView': 'Zur\u00fccksetzen & Einpassen (R)',
    'toolbar.globalMap': 'Weltkarte (G)',
    'onboarding.title': 'Netzwerk-Visualizer',
    'onboarding.subtitle': 'Visualisieren, analysieren und KI-gest\u00fctzte Einblicke in Ihre IONOS Cloud-Infrastruktur',
    'onboarding.step1Title': 'API-Token erhalten',
    'onboarding.step1Desc': 'Erstellen Sie einen Token auf <a href="https://dcd.ionos.com" target="_blank" style="color:var(--accent);">dcd.ionos.com</a> unter Verwaltung \u2192 Token-Manager',
    'onboarding.step2Title': 'Verbinden',
    'onboarding.step2Desc': 'F\u00fcgen Sie den Token in die Seitenleiste ein und klicken Sie auf Verbinden',
    'onboarding.step3Title': 'Erkunden',
    'onboarding.step3Desc': 'Topologie navigieren, Flow-Logs pr\u00fcfen, Datentransfer einsehen und exportieren',
    'onboarding.shortcutHint': 'Dr\u00fccken Sie <kbd>?</kbd> f\u00fcr Tastaturk\u00fcrzel',
    'shortcuts.title': 'Tastaturk\u00fcrzel',
    'shortcuts.close': 'Panel / Overlay schlie\u00dfen',
    'shortcuts.search': 'Suchleiste fokussieren',
    'shortcuts.zoomInOut': 'Vergr\u00f6\u00dfern / Verkleinern',
    'shortcuts.fitView': 'Zur\u00fccksetzen & Einpassen',
    'shortcuts.labels': 'Beschriftungen umschalten',
    'shortcuts.ipView': 'IP-Ansicht umschalten',
    'shortcuts.computeView': 'Compute-Ansicht umschalten',
    'shortcuts.highlights': 'Hervorhebungen umschalten',
    'shortcuts.mapBg': 'Kartenhintergrund umschalten',
    'shortcuts.globalMap': 'Weltkarte',
    'shortcuts.tableView': 'Ressourcentabelle',
    'shortcuts.resetView': 'Zur\u00fccksetzen & Einpassen',
    'shortcuts.help': 'Hilfe anzeigen',
    'shortcuts.flowlogs': 'Flow-Log-Explorer',
    'shortcuts.heatmap': 'Verkehrs-Heatmap',
    'shortcuts.billingHeatmap': 'Datentransfer-Heatmap',
    // Flow Log Explorer
    'toolbar.flowlogs': 'Flow-Log-Explorer (W)',
    'toolbar.flowlogsMenu': 'Flow-Logs',
    'toolbar.heatmap': 'Verkehrs-Heatmap (X)',
    // Security
    'toolbar.security': 'Sicherheitsstatus (S)',
    'security.title': 'Sicherheitsstatus',
    'security.firewall': 'Firewall-Abdeckung',
    'security.firewallGood': 'Ausgezeichnet — die meisten Server haben aktive Firewall-Regeln',
    'security.firewallWarn': 'Mäßig — erwägen Sie Firewalls auf mehr Servern zu aktivieren',
    'security.firewallBad': 'Niedrig — vielen Servern fehlt Firewall-Schutz',
    'security.flowlogs': 'Flow Logs',
    'security.flowlogsGood': 'Gute Flow-Log-Abdeckung für Verkehrsüberwachung',
    'security.flowlogsWarn': 'Begrenzte Flow-Log-Abdeckung — erwägen Sie die Aktivierung',
    'security.secgroups': 'Sicherheitsgruppen',
    'security.secgroupsGood': 'Die meisten Server sind durch Sicherheitsgruppen geschützt',
    'security.secgroupsWarn': 'Einigen Servern fehlt Sicherheitsgruppen-Schutz',
    'security.secgroupsBad': 'Vielen Servern sind keine Sicherheitsgruppen zugewiesen',
    'security.privateLans': 'Private LANs',
    'security.privateLansDesc': 'Private LANs reduzieren die Exposition zum öffentlichen Internet',
    'security.natGwActive': '{count} NAT-Gateway(s) erkannt \u2014 private LANs haben sicheren ausgehenden Zugang',
    'security.natGwSuggest': 'Tipp: F\u00fcgen Sie ein NAT-Gateway f\u00fcr sicheren ausgehenden Internetzugang von privaten LANs hinzu',
    'security.ipv6': 'IPv6-Einführung',
    'security.ipv6Good': 'Starke IPv6-Einführung in Ihren LANs',
    'security.ipv6Bad': 'Geringe IPv6-Einführung — erwägen Sie die Aktivierung',
    'security.highlightEnabled': '{name} Hervorhebung aktiviert',
    'shortcuts.security': 'Sicherheitsstatus',
    'toast.noVdcLoaded': 'Laden Sie zuerst ein VDC, um den Sicherheitsstatus anzuzeigen',
    'highlights.title': 'Hervorhebungen',
    'highlights.firewall': 'Firewall aktiv',
    'highlights.flowLogs': 'Flow Logs',
    'highlights.secGroups': 'Sicherheitsgruppen',
    'highlights.ipv6': 'IPv6 aktiviert',
    'highlights.ipFailover': 'IP-Failover',
    'highlights.crossConnect': 'Cross Connect',
    'table.title': 'Ressourcentabelle',
    'table.searchPlaceholder': 'Ressourcen suchen...',
    'table.csv': 'CSV',
    'table.name': 'Name',
    'table.type': 'Typ',
    'table.state': 'Status',
    'table.details': 'Details',
    'table.ips': 'IPs',
    'table.showing': '{count} von {total} Ressourcen',
    'table.noMatch': 'Keine Ressourcen entsprechen den aktuellen Filtern',
    'export.diagram': 'Diagramm',
    'export.data': 'Daten',
    'export.report': 'Bericht',
    'export.png': 'PNG-Bild',
    'export.svg': 'SVG-Vektor',
    'export.json': 'JSON-Topologie',
    'export.csv': 'CSV-Tabelle',
    'export.xlsx': 'XLSX-Arbeitsmappe',
    'export.pdf': 'PDF-Bericht',
    'toast.pngExported': 'PNG exportiert',
    'toast.pngFailed': 'PNG-Export fehlgeschlagen \u2014 versuchen Sie eine kleinere Zoomstufe',
    'toast.svgExported': 'SVG exportiert',
    'toast.jsonExported': 'JSON-Topologie exportiert',
    'toast.csvExported': 'CSV exportiert ({count} Zeilen)',
    'toast.xlsxExported': 'XLSX-Arbeitsmappe exportiert',
    'toast.pdfExported': 'PDF-Bericht exportiert',
    'toast.pdfFailed': 'PDF-Export fehlgeschlagen \u2014 versuchen Sie eine kleinere Zoomstufe',
    'toast.noData': 'Keine Daten zum Exportieren',
    'toast.noRows': 'Keine Zeilen zum Exportieren',
    'toast.noDisplay': 'Keine Daten vorhanden',
    'toast.enterToken': 'Bitte API-Token eingeben',
    'toast.noDataCenters': 'Keine Rechenzentren gefunden',
    'toast.foundDcs': '{count} Rechenzentrum/en gefunden',
    'toast.connectionFailed': 'Verbindung fehlgeschlagen: {error}',
    'toast.disconnected': 'Verbindung getrennt',
    'toast.loadedResources': '{count} Ressourcen geladen',
    'toast.loadFailed': 'VDC laden fehlgeschlagen: {error}',
    'toast.noVdcsLocation': 'Keine VDCs an diesem Standort',
    'toast.loadedLocation': '{dcCount} VDC(s) mit {nodeCount} Ressourcen geladen',
    'toast.locationFailed': 'Standort laden fehlgeschlagen: {error}',
    'toast.contractSwitched': 'Zu Vertrag {id} gewechselt',
    'toast.contractFailed': 'Vertragswechsel fehlgeschlagen: {error}',
    'toast.xlsxNotLoaded': 'XLSX-Bibliothek nicht geladen',
    'toast.pdfNotLoaded': 'PDF-Bibliothek nicht geladen',
    'detail.connectedResources': 'Verbundene Ressourcen',
    'detail.networkMetrics': 'Netzwerk-Metriken',
    'detail.billingTraffic': 'Datentransfer (30T)',
    'detail.noBillingData': 'Keine Datentransfer-Daten verf\u00fcgbar',
    'detail.nics': 'Netzwerk-Interfaces (NICs)',
    'detail.securityRules': 'Sicherheitsgruppen-Regeln',
    'detail.noRules': 'Keine Regeln definiert',
    'detail.ruleDir': 'Richt.',
    'detail.ruleProto': 'Protokoll',
    'detail.rulePorts': 'Ports',
    'detail.ruleSource': 'Quelle',
    'detail.ruleTarget': 'Ziel',
    'detail.ruleAll': 'Alle',
    'detail.ruleAny': 'Alle',
    'detail.loading': 'Laden...',
    'detail.lanId': 'LAN-ID',
    'detail.public': '\u00d6ffentlich',
    'detail.ipv4Cidr': 'IPv4-CIDR',
    'detail.ipv6Cidr': 'IPv6-CIDR',
    'detail.crossConnect': 'Cross Connect',
    'detail.ipFailover': 'IP-Failover',
    'detail.state': 'Status',
    'detail.type': 'Typ',
    'detail.cores': 'Kerne',
    'detail.ram': 'RAM',
    'detail.cpu': 'CPU',
    'detail.vmState': 'VM-Status',
    'detail.version': 'Version',
    'detail.instances': 'Instanzen',
    'detail.storage': 'Speicher',
    'detail.dns': 'DNS',
    'detail.publicIps': '\u00d6ffentliche IPs',
    'detail.privateIps': 'Private IPs',
    'detail.listenerLan': 'Listener-LAN',
    'detail.targetLan': 'Ziel-LAN',
    'detail.pccId': 'PCC-ID',
    'detail.cluster': 'Cluster',
    'detail.k8sVersion': 'K8s-Version',
    'detail.nodes': 'Knoten',
    'detail.coresPerNode': 'Kerne/Knoten',
    'detail.ramPerNode': 'RAM/Knoten',
    'detail.size': 'Gr\u00f6\u00dfe',
    'detail.gatewayIp': 'Gateway-IP',
    'detail.ifaceIpv4': 'Interface IPv4',
    'detail.ifaceIpv6': 'Interface IPv6',
    'detail.dnsNames': 'DNS-Namen',
    'detail.reverseDns': 'Reverse DNS',
    'detail.yes': 'Ja',
    'detail.no': 'Nein',
    'detail.noData': 'Keine Daten',
    'loading.authenticating': 'Authentifizierung',
    'loading.serversLans': 'Server & LANs',
    'loading.managedServices': 'Managed Services',
    'loading.buildingGraph': 'Graph erstellen',
    'loading.resources': 'Ressourcen laden...',
    'loading.fetchingDetails': 'Rechenzentrum-Details abrufen...',
    'loading.fetchingServers': 'Server, LANs und Managed Services abrufen...',
    'loading.resolvingNics': 'Server-NICs aufl\u00f6sen...',
    'loading.fetchingK8s': 'Kubernetes-Node-Pools abrufen...',
    'loading.buildingViz': 'Visualisierung erstellen...',
    'loading.loadingVdcs': '{count} VDC(s) an {location} laden...',
    'loading.fetchingShared': 'Gemeinsame Managed Services abrufen...',
    'loading.fetchingVdc': 'VDC {index}/{total} abrufen: {name}...',
    'loading.mergingGraphs': 'VDC-Graphen zusammenf\u00fchren...',
    'search.placeholder': 'Ressourcen suchen...',
    'search.noMatches': 'Keine Treffer',
    'search.matchCount': '{count} Treffer',
    'search.andMore': '...und {count} weitere',
    'map.allRegions': '\u2190 Alle Regionen',
    'theme.toggle': 'Design umschalten',
    'total': 'Gesamt',
  },
  es: {
    'sidebar.apiToken': 'Token API',
    'sidebar.tokenPlaceholder': 'Pegue su token de la API de IONOS Cloud',
    'sidebar.connect': 'Conectar',
    'sidebar.disconnect': 'Desconectar',
    'sidebar.viewMode': 'Vista',
    'sidebar.globalMap': 'Mapa global',
    'sidebar.singleVdc': 'VDC individual',
    'sidebar.byLocation': 'Por ubicaci\u00f3n',
    'sidebar.mapInstruction': 'Haga clic en una regi\u00f3n del mapa para ver los VDCs en esa ubicaci\u00f3n y seleccione uno para ver su topolog\u00eda.',
    'sidebar.vdc': 'Centro de datos virtual',
    'sidebar.location': 'Ubicaci\u00f3n',
    'sidebar.connectFirst': '-- Conectar primero --',
    'sidebar.refresh': 'Actualizar',
    'sidebar.resources': 'Recursos',
    'sidebar.publicIps': 'IPs p\u00fablicas',
    'sidebar.dnsZones': 'Zonas DNS',
    'sidebar.builtBy': 'Creado por Rijesh Haridas',
    'sidebar.pinVdc': 'Fijar / Desfijar VDC',
    'account.email': 'Correo',
    'account.contract': 'Contrato',
    'toolbar.zoomIn': 'Acercar (+)',
    'toolbar.zoomOut': 'Alejar (-)',
    'toolbar.fitView': 'Restablecer y ajustar (F)',
    'toolbar.labels': 'Etiquetas (L)',
    'toolbar.ipView': 'Vista IP (I)',
    'toolbar.computeView': 'Vista de c\u00f3mputo (C)',
    'toolbar.highlights': 'Resaltados (H)',
    'toolbar.mapBg': 'Fondo de mapa (M)',
    'toolbar.tableView': 'Vista de tabla (T)',
    'toolbar.export': 'Exportar',
    'toolbar.resetView': 'Restablecer y ajustar (R)',
    'toolbar.globalMap': 'Mapa global (G)',
    'onboarding.title': 'Visualizador de Red',
    'onboarding.subtitle': 'Visualice, analice y obtenga informaci\u00f3n con IA de su infraestructura IONOS Cloud',
    'onboarding.step1Title': 'Obtener token API',
    'onboarding.step1Desc': 'Genere un token en <a href="https://dcd.ionos.com" target="_blank" style="color:var(--accent);">dcd.ionos.com</a> en Gesti\u00f3n \u2192 Token Manager',
    'onboarding.step2Title': 'Conectar',
    'onboarding.step2Desc': 'Pegue el token en la barra lateral y haga clic en Conectar',
    'onboarding.step3Title': 'Explorar',
    'onboarding.step3Desc': 'Navegue la topolog\u00eda, inspeccione flujos, vea transferencias y exporte',
    'onboarding.shortcutHint': 'Pulse <kbd>?</kbd> para ver atajos de teclado',
    'shortcuts.title': 'Atajos de teclado',
    'shortcuts.close': 'Cerrar panel / superposici\u00f3n',
    'shortcuts.search': 'Enfocar barra de b\u00fasqueda',
    'shortcuts.zoomInOut': 'Acercar / Alejar',
    'shortcuts.fitView': 'Restablecer y ajustar vista',
    'shortcuts.labels': 'Alternar etiquetas',
    'shortcuts.ipView': 'Alternar vista IP',
    'shortcuts.computeView': 'Alternar vista de c\u00f3mputo',
    'shortcuts.highlights': 'Alternar resaltados',
    'shortcuts.mapBg': 'Alternar fondo de mapa',
    'shortcuts.globalMap': 'Vista de mapa global',
    'shortcuts.tableView': 'Tabla de recursos',
    'shortcuts.resetView': 'Restablecer y ajustar vista',
    'shortcuts.help': 'Mostrar esta ayuda',
    'shortcuts.flowlogs': 'Explorador de Flow Logs',
    'shortcuts.heatmap': 'Mapa de calor de tráfico',
    'shortcuts.billingHeatmap': 'Mapa de calor de transferencia',
    // Flow Log Explorer
    'toolbar.flowlogs': 'Explorador de Flow Logs (W)',
    'toolbar.flowlogsMenu': 'Flow Logs',
    'toolbar.heatmap': 'Mapa de calor de tráfico (X)',
    // Security
    'toolbar.security': 'Postura de seguridad (S)',
    'security.title': 'Postura de Seguridad',
    'security.firewall': 'Cobertura de Firewall',
    'security.firewallGood': 'Excelente — la mayoría de los servidores tienen reglas de firewall activas',
    'security.firewallWarn': 'Moderada — considere activar firewalls en más servidores',
    'security.firewallBad': 'Baja — muchos servidores carecen de protección de firewall',
    'security.flowlogs': 'Flow Logs',
    'security.flowlogsGood': 'Buena cobertura de flow logs para monitoreo de tráfico',
    'security.flowlogsWarn': 'Cobertura limitada de flow logs — considere habilitarlos',
    'security.secgroups': 'Grupos de Seguridad',
    'security.secgroupsGood': 'La mayoría de los servidores están protegidos por grupos de seguridad',
    'security.secgroupsWarn': 'Algunos servidores carecen de protección de grupos de seguridad',
    'security.secgroupsBad': 'Muchos servidores no tienen grupos de seguridad asignados',
    'security.privateLans': 'LANs Privadas',
    'security.privateLansDesc': 'Las LANs privadas reducen la exposición a internet público',
    'security.natGwActive': '{count} NAT Gateway(s) detectados \u2014 las LANs privadas tienen acceso saliente seguro',
    'security.natGwSuggest': 'Consejo: A\u00f1ada un NAT Gateway para acceso seguro a internet desde LANs privadas',
    'security.ipv6': 'Adopción de IPv6',
    'security.ipv6Good': 'Fuerte adopción de IPv6 en sus LANs',
    'security.ipv6Bad': 'Baja adopción de IPv6 — considere habilitarlo',
    'security.highlightEnabled': 'Resaltado de {name} activado',
    'shortcuts.security': 'Postura de seguridad',
    'toast.noVdcLoaded': 'Cargue primero un VDC para ver la postura de seguridad',
    'highlights.title': 'Resaltados',
    'highlights.firewall': 'Firewall activo',
    'highlights.flowLogs': 'Flow Logs',
    'highlights.secGroups': 'Grupos de seguridad',
    'highlights.ipv6': 'IPv6 habilitado',
    'highlights.ipFailover': 'IP Failover',
    'highlights.crossConnect': 'Cross Connect',
    'table.title': 'Tabla de recursos',
    'table.searchPlaceholder': 'Buscar recursos...',
    'table.csv': 'CSV',
    'table.name': 'Nombre',
    'table.type': 'Tipo',
    'table.state': 'Estado',
    'table.details': 'Detalles',
    'table.ips': 'IPs',
    'table.showing': 'Mostrando {count} de {total} recursos',
    'table.noMatch': 'Ning\u00fan recurso coincide con los filtros actuales',
    'export.diagram': 'Diagrama',
    'export.data': 'Datos',
    'export.report': 'Informe',
    'export.png': 'Imagen PNG',
    'export.svg': 'Vector SVG',
    'export.json': 'Topolog\u00eda JSON',
    'export.csv': 'Tabla CSV',
    'export.xlsx': 'Libro XLSX',
    'export.pdf': 'Informe PDF',
    'toast.pngExported': 'PNG exportado',
    'toast.pngFailed': 'Exportaci\u00f3n PNG fallida \u2014 pruebe un nivel de zoom menor',
    'toast.svgExported': 'SVG exportado',
    'toast.jsonExported': 'Topolog\u00eda JSON exportada',
    'toast.csvExported': 'CSV exportado ({count} filas)',
    'toast.xlsxExported': 'Libro XLSX exportado',
    'toast.pdfExported': 'Informe PDF exportado',
    'toast.pdfFailed': 'Exportaci\u00f3n PDF fallida \u2014 pruebe un nivel de zoom menor',
    'toast.noData': 'No hay datos para exportar',
    'toast.noRows': 'No hay filas para exportar',
    'toast.noDisplay': 'No hay datos para mostrar',
    'toast.enterToken': 'Introduzca un token API',
    'toast.noDataCenters': 'No se encontraron centros de datos',
    'toast.foundDcs': '{count} centro(s) de datos encontrado(s)',
    'toast.connectionFailed': 'Conexi\u00f3n fallida: {error}',
    'toast.disconnected': 'Desconectado',
    'toast.loadedResources': '{count} recursos cargados',
    'toast.loadFailed': 'Error al cargar VDC: {error}',
    'toast.noVdcsLocation': 'No hay VDCs en esta ubicaci\u00f3n',
    'toast.loadedLocation': '{dcCount} VDC(s) con {nodeCount} recursos cargados',
    'toast.locationFailed': 'Error al cargar ubicaci\u00f3n: {error}',
    'toast.contractSwitched': 'Cambiado al contrato {id}',
    'toast.contractFailed': 'Error al cambiar contrato: {error}',
    'toast.xlsxNotLoaded': 'Biblioteca XLSX no cargada',
    'toast.pdfNotLoaded': 'Biblioteca PDF no cargada',
    'detail.connectedResources': 'Recursos conectados',
    'detail.networkMetrics': 'M\u00e9tricas de red',
    'detail.billingTraffic': 'Transferencia de datos (30d)',
    'detail.noBillingData': 'No hay datos de transferencia disponibles',
    'detail.nics': 'Interfaces de red (NICs)',
    'detail.securityRules': 'Reglas de grupo de seguridad',
    'detail.noRules': 'Sin reglas definidas',
    'detail.ruleDir': 'Dir',
    'detail.ruleProto': 'Protocolo',
    'detail.rulePorts': 'Puertos',
    'detail.ruleSource': 'Origen',
    'detail.ruleTarget': 'Destino',
    'detail.ruleAll': 'Todos',
    'detail.ruleAny': 'Cualquiera',
    'detail.loading': 'Cargando...',
    'detail.lanId': 'ID de LAN',
    'detail.public': 'P\u00fablica',
    'detail.ipv4Cidr': 'CIDR IPv4',
    'detail.ipv6Cidr': 'CIDR IPv6',
    'detail.crossConnect': 'Cross Connect',
    'detail.ipFailover': 'IP Failover',
    'detail.state': 'Estado',
    'detail.type': 'Tipo',
    'detail.cores': 'N\u00facleos',
    'detail.ram': 'RAM',
    'detail.cpu': 'CPU',
    'detail.vmState': 'Estado VM',
    'detail.version': 'Versi\u00f3n',
    'detail.instances': 'Instancias',
    'detail.storage': 'Almacenamiento',
    'detail.dns': 'DNS',
    'detail.publicIps': 'IPs p\u00fablicas',
    'detail.privateIps': 'IPs privadas',
    'detail.listenerLan': 'LAN de escucha',
    'detail.targetLan': 'LAN de destino',
    'detail.pccId': 'ID PCC',
    'detail.cluster': 'Cl\u00faster',
    'detail.k8sVersion': 'Versi\u00f3n K8s',
    'detail.nodes': 'Nodos',
    'detail.coresPerNode': 'N\u00facleos/Nodo',
    'detail.ramPerNode': 'RAM/Nodo',
    'detail.size': 'Tama\u00f1o',
    'detail.gatewayIp': 'IP de puerta de enlace',
    'detail.ifaceIpv4': 'Interfaz IPv4',
    'detail.ifaceIpv6': 'Interfaz IPv6',
    'detail.dnsNames': 'Nombres DNS',
    'detail.reverseDns': 'DNS inverso',
    'detail.yes': 'S\u00ed',
    'detail.no': 'No',
    'detail.noData': 'Sin datos',
    'loading.authenticating': 'Autenticando',
    'loading.serversLans': 'Servidores y LANs',
    'loading.managedServices': 'Servicios gestionados',
    'loading.buildingGraph': 'Construyendo grafo',
    'loading.resources': 'Cargando recursos...',
    'loading.fetchingDetails': 'Obteniendo detalles del centro de datos...',
    'loading.fetchingServers': 'Obteniendo servidores, LANs y servicios gestionados...',
    'loading.resolvingNics': 'Resolviendo NICs de servidores...',
    'loading.fetchingK8s': 'Obteniendo pools de nodos Kubernetes...',
    'loading.buildingViz': 'Construyendo visualizaci\u00f3n...',
    'loading.loadingVdcs': 'Cargando {count} VDC(s) en {location}...',
    'loading.fetchingShared': 'Obteniendo servicios gestionados compartidos...',
    'loading.fetchingVdc': 'Obteniendo VDC {index}/{total}: {name}...',
    'loading.mergingGraphs': 'Fusionando grafos de VDC...',
    'search.placeholder': 'Buscar recursos...',
    'search.noMatches': 'Sin coincidencias',
    'search.matchCount': '{count} coincidencia(s)',
    'search.andMore': '...y {count} m\u00e1s',
    'map.allRegions': '\u2190 Todas las regiones',
    'theme.toggle': 'Cambiar tema',
    'total': 'total',
  },
  fr: {
    'sidebar.apiToken': 'Jeton API',
    'sidebar.tokenPlaceholder': 'Collez votre jeton API IONOS Cloud',
    'sidebar.connect': 'Connecter',
    'sidebar.disconnect': 'Déconnecter',
    'sidebar.viewMode': 'Mode de vue',
    'sidebar.globalMap': 'Carte mondiale',
    'sidebar.singleVdc': 'VDC unique',
    'sidebar.byLocation': 'Par site',
    'sidebar.mapInstruction': 'Cliquez sur une r\u00e9gion de la carte pour voir les VDCs \u00e0 cet emplacement, puis s\u00e9lectionnez un VDC pour afficher sa topologie.',
    'sidebar.vdc': 'Centre de donn\u00e9es virtuel',
    'sidebar.location': 'Site',
    'sidebar.connectFirst': '-- Connecter d\'abord --',
    'sidebar.refresh': 'Actualiser',
    'sidebar.resources': 'Ressources',
    'sidebar.publicIps': 'IPs publiques',
    'sidebar.dnsZones': 'Zones DNS',
    'sidebar.builtBy': 'Cr\u00e9\u00e9 par Rijesh Haridas',
    'sidebar.pinVdc': '\u00c9pingler / D\u00e9tacher VDC',
    'account.email': 'E-mail',
    'account.contract': 'Contrat',
    'toolbar.zoomIn': 'Zoom avant (+)',
    'toolbar.zoomOut': 'Zoom arri\u00e8re (-)',
    'toolbar.fitView': 'R\u00e9initialiser et ajuster (F)',
    'toolbar.labels': '\u00c9tiquettes (L)',
    'toolbar.ipView': 'Vue IP (I)',
    'toolbar.computeView': 'Vue calcul (C)',
    'toolbar.highlights': 'Mises en \u00e9vidence (H)',
    'toolbar.mapBg': 'Fond de carte (M)',
    'toolbar.tableView': 'Vue tableau (T)',
    'toolbar.export': 'Exporter',
    'toolbar.resetView': 'R\u00e9initialiser et ajuster (R)',
    'toolbar.globalMap': 'Carte mondiale (G)',
    'onboarding.title': 'Visualiseur R\u00e9seau',
    'onboarding.subtitle': 'Visualisez, analysez et obtenez des informations IA sur votre infrastructure IONOS Cloud',
    'onboarding.step1Title': 'Obtenir un jeton API',
    'onboarding.step1Desc': 'G\u00e9n\u00e9rez un jeton sur <a href="https://dcd.ionos.com" target="_blank" style="color:var(--accent);">dcd.ionos.com</a> sous Gestion \u2192 Token Manager',
    'onboarding.step2Title': 'Connecter',
    'onboarding.step2Desc': 'Collez le jeton dans la barre lat\u00e9rale et cliquez sur Connecter',
    'onboarding.step3Title': 'Explorer',
    'onboarding.step3Desc': 'Parcourez la topologie, inspectez les flux, consultez les transferts et exportez',
    'onboarding.shortcutHint': 'Appuyez sur <kbd>?</kbd> pour les raccourcis clavier',
    'shortcuts.title': 'Raccourcis clavier',
    'shortcuts.close': 'Fermer panneau / superposition',
    'shortcuts.search': 'Focus barre de recherche',
    'shortcuts.zoomInOut': 'Zoom avant / arri\u00e8re',
    'shortcuts.fitView': 'R\u00e9initialiser et ajuster la vue',
    'shortcuts.labels': 'Basculer \u00e9tiquettes',
    'shortcuts.ipView': 'Basculer vue IP',
    'shortcuts.computeView': 'Basculer vue calcul',
    'shortcuts.highlights': 'Basculer mises en \u00e9vidence',
    'shortcuts.mapBg': 'Basculer fond de carte',
    'shortcuts.globalMap': 'Vue carte mondiale',
    'shortcuts.tableView': 'Tableau des ressources',
    'shortcuts.resetView': 'R\u00e9initialiser et ajuster la vue',
    'shortcuts.help': 'Afficher cette aide',
    'shortcuts.flowlogs': 'Explorateur de Flow Logs',
    'shortcuts.heatmap': 'Carte thermique du trafic',
    'shortcuts.billingHeatmap': 'Carte thermique de transfert',
    // Flow Log Explorer
    'toolbar.flowlogs': 'Explorateur de Flow Logs (W)',
    'toolbar.flowlogsMenu': 'Flow Logs',
    'toolbar.heatmap': 'Carte thermique du trafic (X)',
    // Security
    'toolbar.security': 'Posture de sécurité (S)',
    'security.title': 'Posture de Sécurité',
    'security.firewall': 'Couverture Pare-feu',
    'security.firewallGood': 'Excellent — la plupart des serveurs ont des règles pare-feu actives',
    'security.firewallWarn': 'Modérée — envisagez d\'activer les pare-feux sur plus de serveurs',
    'security.firewallBad': 'Faible — de nombreux serveurs manquent de protection pare-feu',
    'security.flowlogs': 'Flow Logs',
    'security.flowlogsGood': 'Bonne couverture flow logs pour la surveillance du trafic',
    'security.flowlogsWarn': 'Couverture flow logs limitée — envisagez l\'activation',
    'security.secgroups': 'Groupes de Sécurité',
    'security.secgroupsGood': 'La plupart des serveurs sont protégés par des groupes de sécurité',
    'security.secgroupsWarn': 'Certains serveurs manquent de protection par groupes de sécurité',
    'security.secgroupsBad': 'De nombreux serveurs n\'ont pas de groupes de sécurité',
    'security.privateLans': 'LANs Privés',
    'security.privateLansDesc': 'Les LANs priv\u00e9s r\u00e9duisent l\'exposition \u00e0 l\'internet public',
    'security.natGwActive': '{count} passerelle(s) NAT d\u00e9tect\u00e9e(s) \u2014 les LANs priv\u00e9s ont un acc\u00e8s sortant s\u00e9curis\u00e9',
    'security.natGwSuggest': 'Astuce : Ajoutez une passerelle NAT pour un acc\u00e8s internet sortant s\u00e9curis\u00e9 depuis les LANs priv\u00e9s',
    'security.ipv6': 'Adoption IPv6',
    'security.ipv6Good': 'Forte adoption IPv6 dans vos LANs',
    'security.ipv6Bad': 'Faible adoption IPv6 — envisagez l\'activation',
    'security.highlightEnabled': 'Surbrillance {name} activée',
    'shortcuts.security': 'Posture de sécurité',
    'toast.noVdcLoaded': 'Chargez d\'abord un VDC pour voir la posture de sécurité',
    'highlights.title': 'Mises en \u00e9vidence',
    'highlights.firewall': 'Pare-feu actif',
    'highlights.flowLogs': 'Flow Logs',
    'highlights.secGroups': 'Groupes de s\u00e9curit\u00e9',
    'highlights.ipv6': 'IPv6 activ\u00e9',
    'highlights.ipFailover': 'IP Failover',
    'highlights.crossConnect': 'Cross Connect',
    'table.title': 'Tableau des ressources',
    'table.searchPlaceholder': 'Rechercher des ressources...',
    'table.csv': 'CSV',
    'table.name': 'Nom',
    'table.type': 'Type',
    'table.state': '\u00c9tat',
    'table.details': 'D\u00e9tails',
    'table.ips': 'IPs',
    'table.showing': '{count} sur {total} ressources',
    'table.noMatch': 'Aucune ressource ne correspond aux filtres actuels',
    'export.diagram': 'Diagramme',
    'export.data': 'Donn\u00e9es',
    'export.report': 'Rapport',
    'export.png': 'Image PNG',
    'export.svg': 'Vecteur SVG',
    'export.json': 'Topologie JSON',
    'export.csv': 'Tableau CSV',
    'export.xlsx': 'Classeur XLSX',
    'export.pdf': 'Rapport PDF',
    'toast.pngExported': 'PNG export\u00e9',
    'toast.pngFailed': '\u00c9chec de l\'export PNG \u2014 essayez un zoom plus petit',
    'toast.svgExported': 'SVG export\u00e9',
    'toast.jsonExported': 'Topologie JSON export\u00e9e',
    'toast.csvExported': 'CSV export\u00e9 ({count} lignes)',
    'toast.xlsxExported': 'Classeur XLSX export\u00e9',
    'toast.pdfExported': 'Rapport PDF export\u00e9',
    'toast.pdfFailed': '\u00c9chec de l\'export PDF \u2014 essayez un zoom plus petit',
    'toast.noData': 'Aucune donn\u00e9e \u00e0 exporter',
    'toast.noRows': 'Aucune ligne \u00e0 exporter',
    'toast.noDisplay': 'Aucune donn\u00e9e \u00e0 afficher',
    'toast.enterToken': 'Veuillez entrer un jeton API',
    'toast.noDataCenters': 'Aucun centre de donn\u00e9es trouv\u00e9',
    'toast.foundDcs': '{count} centre(s) de donn\u00e9es trouv\u00e9(s)',
    'toast.connectionFailed': '\u00c9chec de la connexion : {error}',
    'toast.disconnected': 'Déconnecté',
    'toast.loadedResources': '{count} ressources charg\u00e9es',
    'toast.loadFailed': '\u00c9chec du chargement VDC : {error}',
    'toast.noVdcsLocation': 'Aucun VDC \u00e0 cet emplacement',
    'toast.loadedLocation': '{dcCount} VDC(s) avec {nodeCount} ressources charg\u00e9(e)s',
    'toast.locationFailed': '\u00c9chec du chargement du site : {error}',
    'toast.contractSwitched': 'Contrat {id} s\u00e9lectionn\u00e9',
    'toast.contractFailed': '\u00c9chec du changement de contrat : {error}',
    'toast.xlsxNotLoaded': 'Biblioth\u00e8que XLSX non charg\u00e9e',
    'toast.pdfNotLoaded': 'Biblioth\u00e8que PDF non charg\u00e9e',
    'detail.connectedResources': 'Ressources connect\u00e9es',
    'detail.networkMetrics': 'M\u00e9triques r\u00e9seau',
    'detail.billingTraffic': 'Transfert de donn\u00e9es (30j)',
    'detail.noBillingData': 'Aucune donn\u00e9e de transfert disponible',
    'detail.nics': 'Interfaces r\u00e9seau (NICs)',
    'detail.securityRules': 'R\u00e8gles de groupe de s\u00e9curit\u00e9',
    'detail.noRules': 'Aucune r\u00e8gle d\u00e9finie',
    'detail.ruleDir': 'Dir',
    'detail.ruleProto': 'Protocole',
    'detail.rulePorts': 'Ports',
    'detail.ruleSource': 'Source',
    'detail.ruleTarget': 'Cible',
    'detail.ruleAll': 'Tous',
    'detail.ruleAny': 'Tout',
    'detail.loading': 'Chargement...',
    'detail.lanId': 'ID LAN',
    'detail.public': 'Publique',
    'detail.ipv4Cidr': 'CIDR IPv4',
    'detail.ipv6Cidr': 'CIDR IPv6',
    'detail.crossConnect': 'Cross Connect',
    'detail.ipFailover': 'IP Failover',
    'detail.state': '\u00c9tat',
    'detail.type': 'Type',
    'detail.cores': 'C\u0153urs',
    'detail.ram': 'RAM',
    'detail.cpu': 'CPU',
    'detail.vmState': '\u00c9tat VM',
    'detail.version': 'Version',
    'detail.instances': 'Instances',
    'detail.storage': 'Stockage',
    'detail.dns': 'DNS',
    'detail.publicIps': 'IPs publiques',
    'detail.privateIps': 'IPs priv\u00e9es',
    'detail.listenerLan': 'LAN d\'\u00e9coute',
    'detail.targetLan': 'LAN cible',
    'detail.pccId': 'ID PCC',
    'detail.cluster': 'Cluster',
    'detail.k8sVersion': 'Version K8s',
    'detail.nodes': 'N\u0153uds',
    'detail.coresPerNode': 'C\u0153urs/N\u0153ud',
    'detail.ramPerNode': 'RAM/N\u0153ud',
    'detail.size': 'Taille',
    'detail.gatewayIp': 'IP passerelle',
    'detail.ifaceIpv4': 'Interface IPv4',
    'detail.ifaceIpv6': 'Interface IPv6',
    'detail.dnsNames': 'Noms DNS',
    'detail.reverseDns': 'DNS inverse',
    'detail.yes': 'Oui',
    'detail.no': 'Non',
    'detail.noData': 'Pas de donn\u00e9es',
    'loading.authenticating': 'Authentification',
    'loading.serversLans': 'Serveurs et LANs',
    'loading.managedServices': 'Services g\u00e9r\u00e9s',
    'loading.buildingGraph': 'Construction du graphe',
    'loading.resources': 'Chargement des ressources...',
    'loading.fetchingDetails': 'R\u00e9cup\u00e9ration des d\u00e9tails du centre de donn\u00e9es...',
    'loading.fetchingServers': 'R\u00e9cup\u00e9ration des serveurs, LANs et services g\u00e9r\u00e9s...',
    'loading.resolvingNics': 'R\u00e9solution des NICs serveurs...',
    'loading.fetchingK8s': 'R\u00e9cup\u00e9ration des pools Kubernetes...',
    'loading.buildingViz': 'Construction de la visualisation...',
    'loading.loadingVdcs': 'Chargement de {count} VDC(s) \u00e0 {location}...',
    'loading.fetchingShared': 'R\u00e9cup\u00e9ration des services g\u00e9r\u00e9s partag\u00e9s...',
    'loading.fetchingVdc': 'R\u00e9cup\u00e9ration VDC {index}/{total} : {name}...',
    'loading.mergingGraphs': 'Fusion des graphes VDC...',
    'search.placeholder': 'Rechercher des ressources...',
    'search.noMatches': 'Aucun r\u00e9sultat',
    'search.matchCount': '{count} r\u00e9sultat(s)',
    'search.andMore': '...et {count} de plus',
    'map.allRegions': '\u2190 Toutes les r\u00e9gions',
    'theme.toggle': 'Changer de thème',
    'total': 'total',
  },
};
let currentLocale = 'en';

function t(key, params) {
  const str = TRANSLATIONS[currentLocale]?.[key] || TRANSLATIONS.en[key] || key;
  if (!params) return str;
  return str.replace(/\{(\w+)\}/g, (_, k) => params[k] != null ? params[k] : '');
}

function setLocale(lang) {
  if (!TRANSLATIONS[lang]) return;
  currentLocale = lang;
  try { localStorage.setItem('ionos-viz-locale', lang); } catch(e) {}
  translatePage();
  updateLocaleButtons();
}

function detectLocale() {
  try {
    const saved = localStorage.getItem('ionos-viz-locale');
    if (saved && TRANSLATIONS[saved]) return saved;
  } catch(e) {}
  const browserLang = (navigator.language || '').substring(0, 2).toLowerCase();
  return TRANSLATIONS[browserLang] ? browserLang : 'en';
}

function translatePage() {
  document.querySelectorAll('[data-i18n]').forEach(el => {
    el.textContent = t(el.dataset.i18n);
  });
  document.querySelectorAll('[data-i18n-html]').forEach(el => {
    el.innerHTML = t(el.dataset.i18nHtml);
  });
  document.querySelectorAll('[data-i18n-tip]').forEach(el => {
    el.setAttribute('data-tip', t(el.dataset.i18nTip));
  });
  document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
    el.placeholder = t(el.dataset.i18nPlaceholder);
  });
  document.querySelectorAll('[data-i18n-aria]').forEach(el => {
    el.setAttribute('aria-label', t(el.dataset.i18nAria));
  });
}

const LOCALE_FLAGS = { en: '\u{1F1EC}\u{1F1E7}', de: '\u{1F1E9}\u{1F1EA}', es: '\u{1F1EA}\u{1F1F8}', fr: '\u{1F1EB}\u{1F1F7}' };

function updateLocaleButtons() {
  document.querySelectorAll('.locale-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.lang === currentLocale);
  });
  const flagEl = document.getElementById('localeFlagDisplay');
  const codeEl = document.getElementById('localeCodeDisplay');
  if (flagEl) flagEl.textContent = LOCALE_FLAGS[currentLocale] || LOCALE_FLAGS.en;
  if (codeEl) codeEl.textContent = currentLocale.toUpperCase();
  closeLocaleMenu();
}

function toggleLocaleMenu() {
  const menu = document.getElementById('localeMenu');
  const isOpen = menu.classList.toggle('open');
  if (isOpen) {
    setTimeout(() => document.addEventListener('click', _closeLocaleOutside), 0);
  } else {
    document.removeEventListener('click', _closeLocaleOutside);
  }
}
function closeLocaleMenu() {
  const menu = document.getElementById('localeMenu');
  if (menu) menu.classList.remove('open');
  document.removeEventListener('click', _closeLocaleOutside);
}
function _closeLocaleOutside(e) {
  const wrapper = document.querySelector('.locale-dropdown-wrapper');
  if (wrapper && !wrapper.contains(e.target)) closeLocaleMenu();
}

// ============================== THEME ==============================
let currentTheme = 'dark';

function detectTheme() {
  try {
    const saved = localStorage.getItem('ionos-viz-theme');
    if (saved === 'light' || saved === 'dark') return saved;
  } catch(e) {}
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) return 'light';
  return 'dark';
}

function applyTheme(theme) {
  currentTheme = theme;
  if (theme === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
  } else {
    document.documentElement.removeAttribute('data-theme');
  }
  updateThemeButton();
  updateMapTheme();
}

function toggleTheme() {
  const next = currentTheme === 'dark' ? 'light' : 'dark';
  try { localStorage.setItem('ionos-viz-theme', next); } catch(e) {}
  applyTheme(next);
}

function updateThemeButton() {
  const btn = document.getElementById('themeToggle');
  if (btn) btn.textContent = currentTheme === 'dark' ? '\u2600' : '\u{1F319}';
}

// ============================== VDC FAVORITES ==============================
let vdcFavorites = [];

function loadFavorites() {
  try {
    const saved = localStorage.getItem('ionos-viz-favorites');
    vdcFavorites = saved ? JSON.parse(saved) : [];
    if (!Array.isArray(vdcFavorites)) vdcFavorites = [];
  } catch(e) { vdcFavorites = []; }
}

function saveFavorites() {
  try { localStorage.setItem('ionos-viz-favorites', JSON.stringify(vdcFavorites)); } catch(e) {}
}

function isFavorite(vdcId) {
  return vdcFavorites.includes(vdcId);
}

function togglePinVDC() {
  const sel = document.getElementById('dcSelect');
  const vdcId = sel.value;
  if (!vdcId) return;
  if (isFavorite(vdcId)) {
    vdcFavorites = vdcFavorites.filter(id => id !== vdcId);
  } else {
    vdcFavorites.push(vdcId);
  }
  saveFavorites();
  reorderVDCOptions();
  updatePinButton();
}

function updatePinButton() {
  const btn = document.getElementById('pinVdcBtn');
  const sel = document.getElementById('dcSelect');
  if (!btn) return;
  const vdcId = sel.value;
  btn.disabled = !vdcId;
  if (vdcId && isFavorite(vdcId)) {
    btn.classList.add('pinned');
    btn.textContent = '\u2605'; // filled star
  } else {
    btn.classList.remove('pinned');
    btn.textContent = '\u2606'; // outline star
  }
}

function reorderVDCOptions() {
  const sel = document.getElementById('dcSelect');
  if (!sel) return;
  const currentVal = sel.value;
  const opts = Array.from(sel.options);
  const placeholder = opts.find(o => !o.value);
  const favOpts = opts.filter(o => o.value && isFavorite(o.value));
  const normalOpts = opts.filter(o => o.value && !isFavorite(o.value));

  sel.innerHTML = '';
  if (placeholder) sel.appendChild(placeholder);

  favOpts.forEach(o => sel.appendChild(o));

  if (favOpts.length > 0 && normalOpts.length > 0) {
    const sep = document.createElement('option');
    sep.disabled = true;
    sep.textContent = '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500';
    sel.appendChild(sep);
  }

  normalOpts.forEach(o => sel.appendChild(o));
  sel.value = currentVal;
}


// ============================== SECURITY POSTURE ==============================
function getSecurityPosture() {
  if (!graphData || !graphData.nodes) return null;
  const servers = graphData.nodes.filter(n => n.type === 'server' || n.type === 'cube' || n.type === 'vcpu');
  const lans = graphData.nodes.filter(n => n.type === 'lan');

  let fwActive = 0, flowLogsActive = 0, sgActive = 0;
  servers.forEach(s => {
    let hasFw = false, hasFL = false, hasSG = false;
    if (s.data && s.data.nics) {
      s.data.nics.forEach(nic => {
        if (nic.firewall) hasFw = true;
        if (nic.flowLogsEnabled) hasFL = true;
      });
    }
    if (s.data && (s.data.securityGroupCount > 0 || (s.data.securityGroups && s.data.securityGroups.length > 0))) hasSG = true;
    if (hasFw) fwActive++;
    if (hasFL) flowLogsActive++;
    if (hasSG) sgActive++;
  });

  let privateLans = 0, ipv6Lans = 0;
  lans.forEach(l => {
    if (l.data && !l.data.isPublic) privateLans++;
    if (l.data && l.data.ipv6Cidr) ipv6Lans++;
  });

  const natGateways = graphData.nodes.filter(n => n.type === 'nat');

  return {
    firewall: { count: fwActive, total: servers.length },
    flowLogs: { count: flowLogsActive, total: servers.length },
    secGroups: { count: sgActive, total: servers.length },
    privateLans: { count: privateLans, total: lans.length, natCount: natGateways.length },
    ipv6: { count: ipv6Lans, total: lans.length },
  };
}

function metricLevel(pct, invert) {
  if (invert) { return pct <= 30 ? 'good' : pct <= 60 ? 'warning' : 'danger'; }
  return pct >= 80 ? 'good' : pct >= 50 ? 'warning' : 'danger';
}

function renderSecurityPosture() {
  const container = document.getElementById('securityMetrics');
  if (!container) return;
  const data = getSecurityPosture();
  if (!data) { container.innerHTML = '<p style="color:var(--text-muted);">' + t('toast.noDisplay') + '</p>'; return; }

  const metrics = [
    { key: 'firewall', label: t('security.firewall'), count: data.firewall.count, total: data.firewall.total, highlight: 'hlFirewall' },
    { key: 'flowLogs', label: t('security.flowlogs'), count: data.flowLogs.count, total: data.flowLogs.total, highlight: 'hlFlowLogs' },
    { key: 'secGroups', label: t('security.secgroups'), count: data.secGroups.count, total: data.secGroups.total, highlight: 'hlSecGroups' },
    { key: 'privateLans', label: t('security.privateLans'), count: data.privateLans.count, total: data.privateLans.total, invert: false, natCount: data.privateLans.natCount },
    { key: 'ipv6', label: t('security.ipv6'), count: data.ipv6.count, total: data.ipv6.total, highlight: 'hlIPv6' },
  ];

  container.innerHTML = '';
  metrics.forEach(m => {
    const pct = m.total > 0 ? Math.round((m.count / m.total) * 100) : 0;
    const level = m.total === 0 ? 'good' : metricLevel(pct, m.invert);
    const card = document.createElement('div');
    card.className = 'security-metric metric-' + level;
    card.innerHTML =
      '<div class="metric-header">' +
        '<span class="metric-label">' + m.label + '</span>' +
        '<span class="metric-value ' + level + '">' + m.count + ' / ' + m.total + ' (' + pct + '%)</span>' +
      '</div>' +
      '<div class="metric-bar-container"><div class="metric-bar ' + level + '" style="width:' + pct + '%"></div></div>' +
      '<div class="metric-desc">' + getMetricDesc(m.key, pct, level, m) + '</div>';
    if (m.highlight) {
      card.style.cursor = 'pointer';
      card.onclick = function() {
        const cb = document.getElementById(m.highlight);
        if (cb) { cb.checked = true; applyHighlights(); }
        closeSecurityOverlay();
        toast(t('security.highlightEnabled', { name: m.label }), 'info');
      };
    }
    container.appendChild(card);
  });
}

function getMetricDesc(key, pct, level, metric) {
  if (key === 'firewall') return level === 'good' ? t('security.firewallGood') : level === 'warning' ? t('security.firewallWarn') : t('security.firewallBad');
  if (key === 'flowLogs') return level === 'good' ? t('security.flowlogsGood') : t('security.flowlogsWarn');
  if (key === 'secGroups') return level === 'good' ? t('security.secgroupsGood') : level === 'warning' ? t('security.secgroupsWarn') : t('security.secgroupsBad');
  if (key === 'privateLans') {
    let desc = t('security.privateLansDesc');
    const natCount = metric && metric.natCount != null ? metric.natCount : 0;
    if (natCount > 0) {
      desc += '<br><span style="color:var(--success);font-weight:600;">\u2714 ' + t('security.natGwActive', { count: natCount }) + '</span>';
    } else if (metric && metric.count > 0) {
      desc += '<br><span style="color:var(--warning);font-weight:600;">\u26A0 ' + t('security.natGwSuggest') + '</span>';
    }
    return desc;
  }
  if (key === 'ipv6') return level === 'good' ? t('security.ipv6Good') : t('security.ipv6Bad');
  return '';
}

function openSecurityOverlay() {
  if (!graphData || !graphData.nodes || graphData.nodes.length === 0) {
    toast(t('toast.noVdcLoaded'), 'error');
    return;
  }
  renderSecurityPosture();
  document.getElementById('securityOverlay').style.display = '';
}

function closeSecurityOverlay() {
  document.getElementById('securityOverlay').style.display = 'none';
}

// Extract base region from location: "de/fra/1" → "de/fra", "de/fra" → "de/fra"
function locationRegion(location) {
  const parts = (location || '').split('/');
  return parts.length >= 2 ? parts.slice(0, 2).join('/') : location || '';
}

function countryFlag(location) {
  if (!location) return '';
  const cc = location.split('/')[0].toLowerCase();
  if (cc.length !== 2) return '';
  return String.fromCodePoint(...[...cc].map(c => 0x1F1E6 + c.charCodeAt(0) - 97));
}

function locationLabel(location) {
  const flag = countryFlag(location);
  // Handle numbered locations: e.g. "de/fra/1" → "Frankfurt 1", "de/fra/2" → "Frankfurt 2"
  const parts = (location || '').split('/');
  let city;
  if (parts.length >= 3) {
    const base = parts.slice(0, 2).join('/');
    const num = parts.slice(2).join('/');
    city = LOCATION_CITIES[base] ? `${LOCATION_CITIES[base]} ${num}` : location;
  } else {
    city = LOCATION_CITIES[location] || location;
  }
  return `${flag} ${city}`;
}

// ============================== NODE TYPES ==============================
const NODE_TYPES = {
  internet:  { color: '#fbbf24', label: 'Internet',     radius: 26 },
  lan:       { color: '#3b82f6', label: 'LAN',           radius: 40 },
  server:    { color: '#10b981', label: 'Server',        radius: 28 },
  cube:      { color: '#10b981', label: 'Cube Server',   radius: 28 },
  postgres:  { color: '#336791', label: 'PostgreSQL',    radius: 30 },
  mongodb:   { color: '#47A248', label: 'MongoDB',       radius: 30 },
  mysql:     { color: '#00758f', label: 'MySQL',         radius: 30 },
  mariadb:   { color: '#c0765a', label: 'MariaDB',       radius: 30 },
  nfs:       { color: '#a855f7', label: 'NFS',           radius: 28 },
  vpn_wg:    { color: '#f43f5e', label: 'VPN WireGuard', radius: 28 },
  vpn_ipsec: { color: '#fb7185', label: 'VPN IPSec',     radius: 28 },
  nat:       { color: '#d97706', label: 'NAT Gateway',   radius: 28 },
  alb:       { color: '#f97316', label: 'App LB',        radius: 30 },
  nlb:       { color: '#06b6d4', label: 'Network LB',    radius: 30 },
  k8s_np:    { color: '#8b5cf6', label: 'K8s NodePool',  radius: 30 },
  kafka:     { color: '#231f20', label: 'Kafka',         radius: 30 },
  pcc:       { color: '#ec4899', label: 'Cross Connect', radius: 28 },
};

// ============================== LINK TYPES ==============================
const LINK_TYPES = {
  nic:             { color: '#3b82f6', dash: '0',   label: 'NIC Connection' },
  'cross-connect': { color: '#ec4899', dash: '6,3', label: 'Cross Connect' },
  managed:         { color: '#FFAA00', dash: '3,3', label: 'Managed Service' },
  gateway:         { color: '#d97706', dash: '0',   label: 'Gateway' },
  'public':        { color: '#fbbf24', dash: '4,2', label: 'Internet' },
};

// ============================== STATUS COLORS ==============================
const STATUS_COLORS = {
  AVAILABLE: '#10b981', RUNNING: '#10b981', ACTIVE: '#10b981',
  BUSY: '#FFAA00', DEPLOYING: '#FFAA00', PROVISIONING: '#3b82f6',
  INACTIVE: '#6b7280', SHUTOFF: '#6b7280', SUSPENDED: '#6b7280',
  ERROR: '#ef4444', FAILED: '#ef4444',
};

// ============================== SVG ICON DRAWERS ==============================
// Drawing convention: Each function draws an icon centered at (0,0) with scale parameter `s`
// and stroke color `c`. Icons are composed of SVG primitives (circles, paths, lines) appended
// to the provided D3 selection `g`. Use scale `s` for all dimensions to enable responsive sizing.
const ICON_DRAW = {
  internet(g, s, c) {
    // Globe: circle + vertical ellipse + horizontal lines
    g.append('circle').attr('r', s).attr('fill','none').attr('stroke',c).attr('stroke-width',1.6);
    g.append('ellipse').attr('rx', s*0.5).attr('ry', s).attr('fill','none').attr('stroke',c).attr('stroke-width',1.2);
    g.append('line').attr('x1',-s).attr('x2',s).attr('y1',0).attr('y2',0).attr('stroke',c).attr('stroke-width',1.2);
    g.append('line').attr('x1',-s*0.85).attr('x2',s*0.85).attr('y1',-s*0.55).attr('y2',-s*0.55).attr('stroke',c).attr('stroke-width',0.8);
    g.append('line').attr('x1',-s*0.85).attr('x2',s*0.85).attr('y1',s*0.55).attr('y2',s*0.55).attr('stroke',c).attr('stroke-width',0.8);
  },

  lan(g, s, c) {
    // Network switch: horizontal bar with ports dropping down
    const w = s * 0.85, bh = s * 0.22;
    // Switch body (horizontal bar)
    g.append('rect').attr('x', -w).attr('y', -bh - s*0.1).attr('width', w*2).attr('height', bh)
      .attr('rx', 2).attr('fill', c).attr('fill-opacity', 0.15).attr('stroke', c).attr('stroke-width', 1.5);
    // Port LEDs on the switch bar
    const ports = 4;
    for (let i = 0; i < ports; i++) {
      const px = -w + (w * 2) * (i + 0.5) / ports;
      g.append('circle').attr('cx', px).attr('cy', -s*0.1).attr('r', s*0.06).attr('fill', c);
    }
    // Cables dropping down from ports to endpoints
    const drops = 3;
    for (let i = 0; i < drops; i++) {
      const px = -w * 0.7 + (w * 1.4) * i / (drops - 1);
      const ey = s * 0.55;
      g.append('line').attr('x1', px).attr('y1', bh - s*0.1).attr('x2', px).attr('y2', ey)
        .attr('stroke', c).attr('stroke-width', 1.2).attr('stroke-opacity', 0.6);
      g.append('rect').attr('x', px - s*0.12).attr('y', ey - s*0.06).attr('width', s*0.24).attr('height', s*0.12)
        .attr('rx', 1).attr('fill', c).attr('fill-opacity', 0.4);
    }
  },

  server(g, s, c) {
    // Server rack: two stacked units with status LEDs and vents
    const w = s*0.85, gap = s*0.08;
    const h = s*0.42;
    [-1, 1].forEach(dir => {
      const y = dir * (h/2 + gap/2);
      g.append('rect').attr('x',-w).attr('y',y - h/2).attr('width',w*2).attr('height',h)
        .attr('rx',3).attr('fill','none').attr('stroke',c).attr('stroke-width',1.6);
      g.append('circle').attr('cx',-w+s*0.22).attr('cy',y).attr('r',s*0.07).attr('fill',c);
      g.append('line').attr('x1',-w+s*0.42).attr('x2',w-s*0.15).attr('y1',y).attr('y2',y)
        .attr('stroke',c).attr('stroke-width',0.8).attr('stroke-opacity',0.5);
    });
  },

  cube(g, s, c) {
    // Cube: isometric cube outline
    const h = s*0.55, w = s*0.7;
    g.append('path')
      .attr('d', `M0,${-h} L${w},${-h*0.35} L${w},${h*0.35} L0,${h} L${-w},${h*0.35} L${-w},${-h*0.35}Z`)
      .attr('fill','none').attr('stroke',c).attr('stroke-width',1.6);
    g.append('line').attr('x1',0).attr('y1',-h).attr('x2',0).attr('y2',h*0.05)
      .attr('stroke',c).attr('stroke-width',1);
    g.append('line').attr('x1',0).attr('y1',h*0.05).attr('x2',w).attr('y2',-h*0.35+h*0.05)
      .attr('stroke',c).attr('stroke-width',1);
    g.append('line').attr('x1',0).attr('y1',h*0.05).attr('x2',-w).attr('y2',-h*0.35+h*0.05)
      .attr('stroke',c).attr('stroke-width',1);
  },

  postgres(g, s, c) {
    // PostgreSQL elephant: simplified side-profile elephant head
    const p = s * 0.07;
    // Head & body
    g.append('path')
      .attr('d', `M${-2*p},${7*p} Q${-5*p},${4*p} ${-6*p},${0} Q${-6*p},${-5*p} ${-3*p},${-7*p} Q${0},${-9*p} ${4*p},${-7*p} Q${7*p},${-5*p} ${7*p},${-1*p} Q${7*p},${3*p} ${4*p},${5*p} Q${3*p},${6*p} ${2*p},${7*p}`)
      .attr('fill','none').attr('stroke',c).attr('stroke-width',1.8).attr('stroke-linecap','round');
    // Trunk
    g.append('path')
      .attr('d', `M${-6*p},${0} Q${-8*p},${2*p} ${-7*p},${5*p} Q${-6*p},${7*p} ${-4*p},${7*p}`)
      .attr('fill','none').attr('stroke',c).attr('stroke-width',1.5).attr('stroke-linecap','round');
    // Eye
    g.append('circle').attr('cx', 2*p).attr('cy', -3*p).attr('r', p*1.1).attr('fill',c);
    // Ear notch
    g.append('path')
      .attr('d', `M${-3*p},${-7*p} Q${-4*p},${-8.5*p} ${-1.5*p},${-7.5*p}`)
      .attr('fill','none').attr('stroke',c).attr('stroke-width',1.2);
  },

  mongodb(g, s, c) {
    // MongoDB leaf: symmetric leaf with center vein
    const h = s*0.9, w = s*0.55;
    g.append('path')
      .attr('d', `M0,${h} Q0,${h*0.5} ${-w},${-h*0.1} Q${-w*0.8},${-h*0.7} 0,${-h} Q${w*0.8},${-h*0.7} ${w},${-h*0.1} Q0,${h*0.5} 0,${h}Z`)
      .attr('fill',c).attr('fill-opacity',0.15).attr('stroke',c).attr('stroke-width',1.8);
    // Center vein
    g.append('line').attr('x1',0).attr('y1',-h*0.8).attr('x2',0).attr('y2',h*0.7)
      .attr('stroke',c).attr('stroke-width',1.2);
    // Small lines off vein
    [-0.4, -0.1, 0.2].forEach(f => {
      const y = h * f;
      g.append('line').attr('x1',0).attr('y1',y).attr('x2',-w*0.4).attr('y2',y-h*0.12)
        .attr('stroke',c).attr('stroke-width',0.8);
      g.append('line').attr('x1',0).attr('y1',y).attr('x2',w*0.4).attr('y2',y-h*0.12)
        .attr('stroke',c).attr('stroke-width',0.8);
    });
  },

  mysql(g, s, c) {
    // MySQL: database cylinder with dolphin-inspired curve
    const w = s*0.7, h = s*0.65, ry = s*0.2;
    // Cylinder body
    g.append('ellipse').attr('rx',w).attr('ry',ry).attr('cy',-h/2)
      .attr('fill',c).attr('fill-opacity',0.1).attr('stroke',c).attr('stroke-width',1.6);
    g.append('rect').attr('x',-w).attr('y',-h/2).attr('width',w*2).attr('height',h)
      .attr('fill',c).attr('fill-opacity',0.08).attr('stroke','none');
    g.append('line').attr('x1',-w).attr('y1',-h/2).attr('x2',-w).attr('y2',h/2).attr('stroke',c).attr('stroke-width',1.6);
    g.append('line').attr('x1',w).attr('y1',-h/2).attr('x2',w).attr('y2',h/2).attr('stroke',c).attr('stroke-width',1.6);
    g.append('ellipse').attr('rx',w).attr('ry',ry).attr('cy',h/2)
      .attr('fill',c).attr('fill-opacity',0.1).attr('stroke',c).attr('stroke-width',1.6);
    // Middle ring
    g.append('ellipse').attr('rx',w).attr('ry',ry*0.7).attr('cy',0)
      .attr('fill','none').attr('stroke',c).attr('stroke-width',0.8).attr('stroke-opacity',0.5);
  },

  mariadb(g, s, c) {
    // MariaDB: database cylinder with "M" badge
    const w = s*0.7, h = s*0.65, ry = s*0.2;
    g.append('ellipse').attr('rx',w).attr('ry',ry).attr('cy',-h/2)
      .attr('fill',c).attr('fill-opacity',0.1).attr('stroke',c).attr('stroke-width',1.6);
    g.append('rect').attr('x',-w).attr('y',-h/2).attr('width',w*2).attr('height',h)
      .attr('fill',c).attr('fill-opacity',0.08).attr('stroke','none');
    g.append('line').attr('x1',-w).attr('y1',-h/2).attr('x2',-w).attr('y2',h/2).attr('stroke',c).attr('stroke-width',1.6);
    g.append('line').attr('x1',w).attr('y1',-h/2).attr('x2',w).attr('y2',h/2).attr('stroke',c).attr('stroke-width',1.6);
    g.append('ellipse').attr('rx',w).attr('ry',ry).attr('cy',h/2)
      .attr('fill',c).attr('fill-opacity',0.1).attr('stroke',c).attr('stroke-width',1.6);
    // "M" letter in center
    const mw = s*0.32, mh = s*0.3;
    g.append('path')
      .attr('d', `M${-mw},${mh/2} L${-mw},${-mh/2} L0,${mh*0.15} L${mw},${-mh/2} L${mw},${mh/2}`)
      .attr('fill','none').attr('stroke',c).attr('stroke-width',2).attr('stroke-linecap','round').attr('stroke-linejoin','round');
  },

  nfs(g, s, c) {
    // NFS: folder with network dots
    const w = s*0.85, h = s*0.6;
    g.append('path')
      .attr('d', `M${-w},${-h*0.3} L${-w},${-h} L${-w*0.2},${-h} L${-w*0.05},${-h*0.55} L${w},${-h*0.55} L${w},${h} L${-w},${h}Z`)
      .attr('fill',c).attr('fill-opacity',0.12).attr('stroke',c).attr('stroke-width',1.6).attr('stroke-linejoin','round');
    // Network dots inside folder
    [[-0.3,0.1],[0.1,0.1],[0.5,0.1],[-0.1,0.5],[0.3,0.5]].forEach(([fx,fy]) => {
      g.append('circle').attr('cx',w*fx).attr('cy',h*fy).attr('r',s*0.07).attr('fill',c).attr('fill-opacity',0.6);
    });
    g.append('line').attr('x1',w*-0.3).attr('y1',h*0.1).attr('x2',w*0.1).attr('y2',h*0.1).attr('stroke',c).attr('stroke-width',0.7);
    g.append('line').attr('x1',w*0.1).attr('y1',h*0.1).attr('x2',w*0.5).attr('y2',h*0.1).attr('stroke',c).attr('stroke-width',0.7);
    g.append('line').attr('x1',w*0.1).attr('y1',h*0.1).attr('x2',w*-0.1).attr('y2',h*0.5).attr('stroke',c).attr('stroke-width',0.7);
    g.append('line').attr('x1',w*0.1).attr('y1',h*0.1).attr('x2',w*0.3).attr('y2',h*0.5).attr('stroke',c).attr('stroke-width',0.7);
  },

  vpn_wg(g, s, c) { ICON_DRAW._shield(g, s, c); ICON_DRAW._lock(g, s*0.3, c); },
  vpn_ipsec(g, s, c) { ICON_DRAW._shield(g, s, c); ICON_DRAW._key(g, s*0.3, c); },

  _shield(g, s, c) {
    // Shield shape
    g.append('path')
      .attr('d', `M0,${-s*0.9} L${s*0.75},${-s*0.5} L${s*0.75},${s*0.15} Q${s*0.6},${s*0.7} 0,${s*0.9} Q${-s*0.6},${s*0.7} ${-s*0.75},${s*0.15} L${-s*0.75},${-s*0.5}Z`)
      .attr('fill',c).attr('fill-opacity',0.12).attr('stroke',c).attr('stroke-width',1.8);
  },

  _lock(g, s, c) {
    // Small lock inside shield
    g.append('rect').attr('x',-s).attr('y',-s*0.2).attr('width',s*2).attr('height',s*1.6).attr('rx',2).attr('fill',c).attr('fill-opacity',0.4);
    g.append('path').attr('d', `M${-s*0.6},${-s*0.2} L${-s*0.6},${-s*0.8} Q${-s*0.6},${-s*1.5} 0,${-s*1.5} Q${s*0.6},${-s*1.5} ${s*0.6},${-s*0.8} L${s*0.6},${-s*0.2}`)
      .attr('fill','none').attr('stroke',c).attr('stroke-width',1.5);
  },

  _key(g, s, c) {
    // Small key inside shield
    g.append('circle').attr('cx',-s*0.5).attr('cy',0).attr('r',s*0.8).attr('fill','none').attr('stroke',c).attr('stroke-width',1.5);
    g.append('line').attr('x1',s*0.3).attr('x2',s*2).attr('y1',0).attr('y2',0).attr('stroke',c).attr('stroke-width',1.5);
    g.append('line').attr('x1',s*1.5).attr('x2',s*1.5).attr('y1',0).attr('y2',s*0.7).attr('stroke',c).attr('stroke-width',1.2);
  },

  nat(g, s, c) {
    // NAT Gateway: router/gateway icon — central circle with 4 directional arrows
    const r = s * 0.28;
    g.append('circle').attr('r', r).attr('fill', c).attr('fill-opacity', 0.15)
      .attr('stroke', c).attr('stroke-width', 1.8);
    // "NAT" label inside circle
    g.append('text').attr('text-anchor', 'middle').attr('dy', '0.35em')
      .attr('font-size', s * 0.2).attr('font-weight', '700').attr('fill', c)
      .attr('font-family', 'Inter, sans-serif').text('N');
    // Four directional arrows (up, down, left, right)
    const arrowLen = s * 0.35, arrowStart = r + s * 0.06, headSize = s * 0.1;
    [[0, -1], [0, 1], [-1, 0], [1, 0]].forEach(([dx, dy]) => {
      const x1 = dx * arrowStart, y1 = dy * arrowStart;
      const x2 = dx * (arrowStart + arrowLen), y2 = dy * (arrowStart + arrowLen);
      g.append('line').attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2)
        .attr('stroke', c).attr('stroke-width', 1.5);
      // Arrowhead
      if (dx !== 0) {
        g.append('path').attr('d', `M${x2},${y2} l${-dx*headSize},${-headSize*0.5} l0,${headSize}Z`).attr('fill', c);
      } else {
        g.append('path').attr('d', `M${x2},${y2} l${-headSize*0.5},${-dy*headSize} l${headSize},0Z`).attr('fill', c);
      }
    });
  },

  alb(g, s, c) {
    // Application Load Balancer: layered distribution icon (L7)
    const lx = -s*0.65, rx = s*0.65;
    // Incoming
    g.append('circle').attr('cx',lx).attr('cy',0).attr('r',s*0.2).attr('fill',c).attr('fill-opacity',0.3).attr('stroke',c).attr('stroke-width',1.5);
    // Split into 3 outgoing
    [-s*0.55, 0, s*0.55].forEach(ty => {
      g.append('line').attr('x1',lx+s*0.2).attr('y1',0).attr('x2',rx-s*0.15).attr('y2',ty)
        .attr('stroke',c).attr('stroke-width',1.3);
      g.append('circle').attr('cx',rx).attr('cy',ty).attr('r',s*0.13).attr('fill',c).attr('fill-opacity',0.4);
    });
    // L7 label
    g.append('text').attr('x',lx).attr('y',s*0.05).attr('text-anchor','middle')
      .attr('font-size', s*0.28).attr('font-weight','700').attr('fill',c).text('L7');
  },

  nlb(g, s, c) {
    // Network Load Balancer: similar to ALB but with lightning (L4)
    const lx = -s*0.65, rx = s*0.65;
    g.append('circle').attr('cx',lx).attr('cy',0).attr('r',s*0.2).attr('fill',c).attr('fill-opacity',0.3).attr('stroke',c).attr('stroke-width',1.5);
    [-s*0.55, 0, s*0.55].forEach(ty => {
      g.append('line').attr('x1',lx+s*0.2).attr('y1',0).attr('x2',rx-s*0.15).attr('y2',ty)
        .attr('stroke',c).attr('stroke-width',1.3);
      g.append('circle').attr('cx',rx).attr('cy',ty).attr('r',s*0.13).attr('fill',c).attr('fill-opacity',0.4);
    });
    // L4 label
    g.append('text').attr('x',lx).attr('y',s*0.05).attr('text-anchor','middle')
      .attr('font-size', s*0.28).attr('font-weight','700').attr('fill',c).text('L4');
  },

  k8s_np(g, s, c) {
    // Kubernetes: official 7-spoke helm wheel
    const spokes = 7;
    const outerR = s * 0.88;
    const innerR = s * 0.32;
    const dotR = s * 0.1;
    // Draw spokes
    for (let i = 0; i < spokes; i++) {
      const angle = (Math.PI * 2 / spokes) * i - Math.PI / 2;
      const ox = outerR * Math.cos(angle);
      const oy = outerR * Math.sin(angle);
      const ix = innerR * Math.cos(angle);
      const iy = innerR * Math.sin(angle);
      g.append('line').attr('x1',ix).attr('y1',iy).attr('x2',ox).attr('y2',oy)
        .attr('stroke',c).attr('stroke-width',1.8);
      g.append('circle').attr('cx',ox).attr('cy',oy).attr('r',dotR).attr('fill',c);
    }
    // Outer heptagon connecting the dots
    const heptPts = [];
    for (let i = 0; i < spokes; i++) {
      const angle = (Math.PI * 2 / spokes) * i - Math.PI / 2;
      heptPts.push([outerR * Math.cos(angle), outerR * Math.sin(angle)]);
    }
    g.append('polygon')
      .attr('points', heptPts.map(p => p.join(',')).join(' '))
      .attr('fill','none').attr('stroke',c).attr('stroke-width',1.3).attr('stroke-opacity',0.5);
    // Center circle
    g.append('circle').attr('r',innerR).attr('fill',c).attr('fill-opacity',0.3).attr('stroke',c).attr('stroke-width',1.5);
  },

  kafka(g, s, c) {
    // Kafka: streaming / event bus icon — three horizontal flow lines with arrow heads
    const lw = s * 0.65, gap = s * 0.28, hw = s * 0.12;
    [-1, 0, 1].forEach(row => {
      const y = row * gap;
      g.append('line').attr('x1', -lw).attr('y1', y).attr('x2', lw - hw).attr('y2', y)
        .attr('stroke', c).attr('stroke-width', 2).attr('stroke-linecap', 'round');
      g.append('path')
        .attr('d', `M${lw - hw * 1.5},${y - hw * 0.7} L${lw},${y} L${lw - hw * 1.5},${y + hw * 0.7}`)
        .attr('fill', 'none').attr('stroke', c).attr('stroke-width', 1.8).attr('stroke-linecap', 'round').attr('stroke-linejoin', 'round');
    });
    // Small "K" letter at left side
    const kx = -lw - s * 0.2, ky = 0, kh = s * 0.3;
    g.append('text').attr('x', kx).attr('y', ky + kh * 0.35)
      .attr('text-anchor', 'middle').attr('font-size', s * 0.35).attr('font-weight', '800')
      .attr('fill', c).attr('font-family', 'Inter, sans-serif').text('K');
  },

  pcc(g, s, c) {
    // Private Cross Connect: bridge with bidirectional arrows
    const w = s * 0.7, gap = s * 0.22;
    // Two horizontal lines (the "bridge")
    g.append('line').attr('x1', -w).attr('x2', w).attr('y1', -gap).attr('y2', -gap)
      .attr('stroke', c).attr('stroke-width', 2);
    g.append('line').attr('x1', -w).attr('x2', w).attr('y1', gap).attr('y2', gap)
      .attr('stroke', c).attr('stroke-width', 2);
    // Vertical connectors at ends
    g.append('line').attr('x1', -w).attr('x2', -w).attr('y1', -gap).attr('y2', gap)
      .attr('stroke', c).attr('stroke-width', 1.5);
    g.append('line').attr('x1', w).attr('x2', w).attr('y1', -gap).attr('y2', gap)
      .attr('stroke', c).attr('stroke-width', 1.5);
    // Right arrow in center
    const ax = s * 0.2;
    g.append('path').attr('d', `M${-ax},0 L${ax},0 M${ax-s*0.12},${-s*0.1} L${ax},0 L${ax-s*0.12},${s*0.1}`)
      .attr('fill', 'none').attr('stroke', c).attr('stroke-width', 1.5).attr('stroke-linecap', 'round');
  },
};

// ============================== SIMULATION CONFIG ==============================
const SIM_CONFIG = {
  linkDistance:      { lan: 170, default: 130 },
  charge:           { pcc: -900, lan: -600, default: -350 },
  collisionPadding: { lan: 35, default: 25 },
  xStrength:        { pcc: 0.02, lan: 0.15, lanChild: 0.12, unattached: 0.04 },
  yPosition:        { pcc: 0.08, internet: 0.08, nat: 0.24, lan: 0.38, lb: 0.53, default: 0.68 },
  yStrength:        0.15,
  lanAlignStrength: 0.08,
  labelPosition:    { sourceWeight: 0.7, targetWeight: 0.3, yOffset: -5 },
};

// ============================== STATE ==============================
let apiToken = '';
let currentContract = '';
let userContracts = [];
let datacenters = [];
let currentDC = null;
let graphData = { nodes: [], links: [] };
let simulation = null;
let svgGroup = null;
let zoomBehavior = null;
let showLabels = true;
let highlightedTypes = new Set(Object.keys(NODE_TYPES));
let currentUser = null;
let activeHighlights = new Set();
let currentAbortController = null;

// ============================== API LAYER ==============================
function useProxy() {
  return window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
}

async function apiFetch(url, { signal } = {}) {
  const opts = {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'Content-Type': 'application/json',
    },
  };
  if (signal) opts.signal = signal;
  let fetchUrl = url;
  if (currentContract) opts.headers['X-Contract-Number'] = currentContract;
  if (useProxy()) {
    fetchUrl = `/proxy?url=${encodeURIComponent(url)}`;
    opts.headers['X-Token'] = apiToken;
  }
  const resp = await fetch(fetchUrl, opts);
  if (!resp.ok) {
    if (resp.status === 404) return null;
    const text = await resp.text();
    throw new Error(`API ${resp.status}: ${text.substring(0, 200)}`);
  }
  return resp.json();
}

async function safeFetch(url, opts) {
  try { return await apiFetch(url, opts); }
  catch (e) {
    if (e.name === 'AbortError') throw e;  // Propagate abort — don't swallow
    console.warn(`Fetch failed for ${url}:`, e.message); return null;
  }
}


// ============================ FETCH CONTRACTS =============================

async function fetchContracts() {
  const data = await apiFetch('https://api.ionos.com/cloudapi/v6/contracts');
  return (data && data.items) ? data.items : [];
}

async function handleContractChange(val) {
  currentContract = val;
  toast(t('toast.contractSwitched', {id: val}), 'info');
  // Re-fetch datacenters for the new contract context
  try {
    await connect(true);
  } catch (e) {
    console.error('Failed to switch contract:', e);
    toast(t('toast.contractFailed', {error: e && e.message ? e.message : e}), 'error');
  }
}


// ============================== DATA FETCHING ==============================

async function fetchDatacenters() {
  const data = await apiFetch(`${API_BASES.cloud}/datacenters?depth=1`);
  return (data && data.items) ? data.items : [];
}

async function fetchLocations() {
  return await safeFetch(`${API_BASES.cloud}/locations?depth=1`);
}

// Format API location name: "lasvegas" → "Las Vegas", "frankfurt-east" → "Frankfurt East"
function formatLocationName(apiName) {
  if (!apiName) return '';
  // Known compound names the API returns without separators
  const KNOWN_NAMES = {
    'lasvegas': 'Las Vegas',
    'newyork': 'New York',
    'losangeles': 'Los Angeles',
    'sanfrancisco': 'San Francisco',
  };
  const lower = apiName.toLowerCase();
  if (KNOWN_NAMES[lower]) return KNOWN_NAMES[lower];
  // Handle hyphenated names: "frankfurt-east" → "Frankfurt East"
  return apiName.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
}

// Dynamically update LOCATION_CITIES from the /locations API
async function loadDynamicLocations() {
  try {
    const data = await fetchLocations();
    if (!data || !data.items) return;

    let newRegions = [];
    data.items.forEach(loc => {
      const id = loc.id; // e.g. "de/fra", "de/txl", "de/fra/2"
      if (!id) return;
      const region = locationRegion(id);
      const rawName = loc.properties?.name || '';
      const name = formatLocationName(rawName);
      // Add city name if we don't already have one for this region
      if (!LOCATION_CITIES[region] && name) {
        LOCATION_CITIES[region] = name;
      }
      // Track regions that have no map coordinates (future-proofing)
      if (!LOCATION_COORDS[region] && !newRegions.includes(region)) {
        newRegions.push(region);
      }
    });

    if (newRegions.length > 0) {
      console.warn(`[VDC-Viz] New region(s) without map coordinates: ${newRegions.join(', ')}. Add coords to LOCATION_COORDS to show on map.`);
    }
    console.log(`[VDC-Viz] Loaded ${data.items.length} location(s) from API`);
  } catch (e) {
    console.warn('[VDC-Viz] Could not load dynamic locations:', e.message);
  }
}

async function fetchDCDetails(dcId) {
  return await apiFetch(`${API_BASES.cloud}/datacenters/${dcId}?depth=5`);
}

async function fetchServerNICs(dcId, serverId) {
  return await safeFetch(`${API_BASES.cloud}/datacenters/${dcId}/servers/${serverId}/nics?depth=2`);
}

async function fetchNatGateways(dcId) {
  return await safeFetch(`${API_BASES.cloud}/datacenters/${dcId}/natgateways?depth=2`);
}

async function fetchALBs(dcId) {
  return await safeFetch(`${API_BASES.cloud}/datacenters/${dcId}/applicationloadbalancers?depth=2`);
}

async function fetchNLBs(dcId) {
  return await safeFetch(`${API_BASES.cloud}/datacenters/${dcId}/networkloadbalancers?depth=2`);
}

async function fetchPostgresClusters() {
  return await safeFetch(`${API_BASES.dbaas_pg}/clusters`);
}

async function fetchMongoClusters() {
  return await safeFetch(`${API_BASES.dbaas_mongo}/clusters`);
}

async function fetchMySQLClusters() {
  return await safeFetch(`${API_BASES.dbaas_mysql}/clusters`);
}

async function fetchMariaDBClusters(location) {
  if (!location) { console.warn('[VDC-Viz] No location for MariaDB fetch'); return null; }
  const loc = location.replace('/', '-');
  const base = API_BASES.dbaas_mariadb(loc);
  return await safeFetch(`${base}/clusters`);
}

async function fetchK8sClusters() {
  return await safeFetch(`${API_BASES.k8s}/k8s?depth=0`);
}

async function fetchK8sNodePools(clusterId) {
  return await safeFetch(`${API_BASES.k8s}/k8s/${clusterId}/nodepools?depth=1`);
}

async function fetchNFSClusters(location) {
  const loc = location.replace('/', '-');
  const urls = [
    `https://nfs.${loc}.ionos.com/clusters`,
    `https://api.ionos.com/nfs/v1/clusters`,
  ];
  // Try both URLs in parallel — return whichever succeeds first
  const results = await Promise.allSettled(urls.map(u => safeFetch(u)));
  for (const r of results) {
    if (r.status === 'fulfilled' && r.value) return r.value;
  }
  return null;
}

async function fetchVPNGateways(location) {
  const loc = location.replace('/', '-');
  const base = `https://vpn.${loc}.ionos.com`;
  const [wg, ipsec] = await Promise.all([
    safeFetch(`${base}/wireguardgateways`),
    safeFetch(`${base}/ipsecgateways`),
  ]);
  return { wireguard: wg, ipsec: ipsec };
}

async function fetchKafkaClusters(location) {
  const loc = location.replace('/', '-');
  return safeFetch(`https://kafka.${loc}.ionos.com/clusters`);
}

async function fetchIPBlocks() {
  return safeFetch(`${API_BASES.cloud}/ipblocks?depth=2`);
}

async function fetchSecurityGroups(dcId) {
  return safeFetch(`${API_BASES.cloud}/datacenters/${dcId}/securitygroups?depth=3`);
}

async function fetchDNSZones() {
  return safeFetch(`${API_BASES.dns}/zones`);
}

async function fetchDNSRecords(zoneId) {
  return safeFetch(`${API_BASES.dns}/zones/${zoneId}/records`);
}

async function fetchReverseDNS() {
  return safeFetch(`${API_BASES.dns}/reverserecords`);
}

async function fetchCDNDistributions() {
  return safeFetch(`${API_BASES.cdn}/distributions`);
}

// Billing traffic state
let _billingTraffic = null;     // raw /traffic/ response
let _billingUtilization = null; // raw /utilization/ response
let _billingByServer = new Map(); // serverId → { totalIn, totalOut, daily: [{date, inGB, outGB}] }
let _billingByVdc = new Map();    // vdcUUID → { name, totalIn, totalOut }

async function fetchBillingTraffic() {
  if (!currentContract) return null;
  return safeFetch(`${API_BASES.billing}/${currentContract}/traffic/?output=all`);
}

async function fetchBillingUtilization() {
  if (!currentContract) return null;
  return safeFetch(`${API_BASES.billing}/${currentContract}/utilization?type=traffic`);
}

// ============================== GRAPH BUILDER ==============================
// Robust LAN map: stores both string and number keys for type-safe lookup
function lanLookup(lanMap, lanId) {
  return lanMap.get(lanId) || lanMap.get(String(lanId)) || lanMap.get(Number(lanId));
}

function buildGraph(dcData, natGWs, albs, nlbs, pgClusters, mongoClusters, mysqlClusters, mariadbClusters, k8sNodePools, nfsClusters, vpnGateways, kafkaClusters) {
  const nodes = [];
  const links = [];
  const dcId = dcData.id;
  const nodeMap = new Map();

  function addNode(id, type, name, data, extra = {}) {
    if (nodeMap.has(id)) return nodeMap.get(id);
    const node = { id, type, name, data, ...extra };
    nodes.push(node);
    nodeMap.set(id, node);
    return node;
  }

  function addLink(source, target, label = '', meta = {}) {
    links.push({ source, target, label, ...meta });
  }

  // 1. LANs
  const lans = dcData.entities?.lans?.items || [];
  const lanMap = new Map();
  lans.forEach(lan => {
    const lanId = lan.id;
    const name = lan.properties?.name || `LAN ${lanId}`;
    const isPublic = lan.properties?.public || false;
    const cidr = lan.properties?.ipv4Cidr || lan.properties?.ipv4CidrBlock || '';
    const ipv6Cidr = lan.properties?.ipv6Cidr || lan.properties?.ipv6CidrBlock || '';
    const pcc = lan.properties?.pcc || null;
    const ipFailover = lan.properties?.ipFailover || [];
    addNode(`lan-${lanId}`, 'lan', name, {
      lanId, isPublic, cidr, ipv6Cidr, pcc, ipFailover,
      state: lan.metadata?.state,
    });
    // Store under multiple key types for robust lookup
    lanMap.set(String(lanId), `lan-${lanId}`);
    lanMap.set(Number(lanId), `lan-${lanId}`);

    if (isPublic) {
      // Single shared Internet node per VDC — created on first public LAN
      if (!nodeMap.has('inet')) addNode('inet', 'internet', 'Internet', {});
      addLink('inet', `lan-${lanId}`, '', { linkType: 'public' });
    }
  });

  // 1b. Private Cross Connects — group LANs sharing the same PCC
  const pccMap = new Map();
  lans.forEach(lan => {
    const pcc = lan.properties?.pcc;
    if (pcc) {
      if (!pccMap.has(pcc)) pccMap.set(pcc, []);
      pccMap.get(pcc).push(lan.id);
    }
  });
  pccMap.forEach((lanIds, pccId) => {
    const shortId = pccId.substring(0, 8);
    addNode(`pcc-${pccId}`, 'pcc', `PCC ${shortId}`, { pccId });
    lanIds.forEach(lanId => {
      addLink(`lan-${lanId}`, `pcc-${pccId}`, 'cross-connect', { linkType: 'cross-connect' });
    });
  });

  // 2. Servers - with full NIC details on links
  const servers = dcData.entities?.servers?.items || [];
  servers.forEach(srv => {
    const srvId = srv.id;
    const name = srv.properties?.name || srvId;
    const type = srv.properties?.type === 'CUBE' ? 'cube' : 'server';
    // Server-level security groups (attached directly to the VM)
    const srvSecGroups = srv.entities?.securitygroups?.items || [];
    const srvSecGroupIds = srvSecGroups.map(sg => sg.id);
    const srvNode = addNode(`srv-${srvId}`, type, name, {
      cores: srv.properties?.cores,
      ram: srv.properties?.ram,
      cpuFamily: srv.properties?.cpuFamily,
      type: srv.properties?.type,
      state: srv.metadata?.state,
      vmState: srv.properties?.vmState,
      securityGroupCount: srvSecGroups.length,
      securityGroupIds: srvSecGroupIds,
    });
    if (srvSecGroups.length > 0) console.log(`[VDC-Viz] Server "${name}" has ${srvSecGroups.length} server-level SecGroup(s): ${srvSecGroupIds.join(', ')}`);

    // NICs -> LAN connections (explicit NIC data on each link)
    const nics = srv.entities?.nics?.items || [];
    console.log(`[VDC-Viz] buildGraph: Server "${name}" has ${nics.length} NIC(s)`);
    nics.forEach(nic => {
      const nicLanId = nic.properties?.lan;
      const ips = nic.properties?.ips || [];
      const ipv6 = nic.properties?.ipv6Ips || [];
      const mac = nic.properties?.mac || '';
      const nicName = nic.properties?.name || '';
      const flowLogsEnabled = (nic.entities?.flowlogs?.items?.length || 0) > 0;
      const secGroupItems = nic.entities?.securitygroups?.items || [];
      const securityGroupCount = secGroupItems.length;
      const securityGroupIds = secGroupItems.map(sg => sg.id);
      const multiQueue = nic.properties?.nicMultiQueue === true;
      console.log(`[VDC-Viz]   NIC "${nicName}" -> LAN ${nicLanId}, IPs: ${ips.join(',')}, flowLogs: ${flowLogsEnabled}, secGroups: ${securityGroupCount}, multiQ: ${multiQueue}`);
      const lanNodeId = lanLookup(lanMap, nicLanId);
      if (lanNodeId) {
        const ipLabel = ips.length > 0 ? ips[0] : '';
        const nicLabel = ipLabel;
        addLink(`srv-${srvId}`, lanNodeId, nicLabel, {
          nicId: nic.id, nicName, ips, ipv6, mac,
          dhcp: nic.properties?.dhcp,
          firewall: nic.properties?.firewallActive,
          flowLogsEnabled, securityGroupCount, securityGroupIds, multiQueue,
          linkType: 'nic',
        });
      } else {
        console.warn(`[VDC-Viz]   WARNING: No LAN node found for NIC "${nicName}" -> LAN ${nicLanId}. Available LAN keys:`, [...lanMap.keys()]);
      }
      // Store NIC info on server node
      if (!srvNode.data.nics) srvNode.data.nics = [];
      srvNode.data.nics.push({ nicId: nic.id, name: nicName, lanId: nicLanId, ips, ipv6, mac, dhcp: nic.properties?.dhcp, firewall: nic.properties?.firewallActive, flowLogsEnabled, securityGroupCount, securityGroupIds, multiQueue });
    });
  });

  // 3. NAT Gateways
  const natItems = natGWs?.items || [];
  natItems.forEach(gw => {
    const gwId = gw.id;
    const name = gw.properties?.name || `NAT GW ${gwId}`;
    addNode(`nat-${gwId}`, 'nat', name, {
      publicIps: gw.properties?.publicIps,
      lans: gw.properties?.lans,
      state: gw.metadata?.state,
    });
    const gwLans = gw.properties?.lans || [];
    gwLans.forEach(l => {
      const lanNodeId = lanLookup(lanMap, l.id);
      if (lanNodeId) addLink(`nat-${gwId}`, lanNodeId, l.gatewayIps?.join(', ') || '', { linkType: 'gateway' });
    });
    // Reuse single shared Internet node
    if (!nodeMap.has('inet')) addNode('inet', 'internet', 'Internet', {});
    addLink(`nat-${gwId}`, 'inet', gw.properties?.publicIps?.join(', ') || '', { linkType: 'gateway' });
  });

  // 4. ALBs
  const albItems = albs?.items || [];
  albItems.forEach(lb => {
    const lbId = lb.id;
    const name = lb.properties?.name || `ALB ${lbId}`;
    const publicIps = lb.properties?.ips || [];
    const privateIps = lb.properties?.lbPrivateIps || [];
    console.log(`[VDC-Viz] ALB "${name}": ips=${JSON.stringify(publicIps)}, lbPrivateIps=${JSON.stringify(privateIps)}`);
    addNode(`alb-${lbId}`, 'alb', name, {
      listenerLan: lb.properties?.listenerLan,
      targetLan: lb.properties?.targetLan,
      ips: publicIps,
      lbPrivateIps: privateIps,
      state: lb.metadata?.state,
    });
    const listenerLan = lanLookup(lanMap, lb.properties?.listenerLan);
    if (listenerLan) addLink(`alb-${lbId}`, listenerLan, 'listener', { linkType: 'gateway' });
    const targetLan = lanLookup(lanMap, lb.properties?.targetLan);
    if (targetLan) addLink(`alb-${lbId}`, targetLan, 'target', { linkType: 'gateway' });
  });

  // 5. NLBs
  const nlbItems = nlbs?.items || [];
  nlbItems.forEach(lb => {
    const lbId = lb.id;
    const name = lb.properties?.name || `NLB ${lbId}`;
    // Collect listener IPs from forwarding rules as fallback
    const fwRules = lb.entities?.forwardingrules?.items || [];
    const fwIps = [...new Set(fwRules.map(r => r.properties?.listenerIp).filter(Boolean))];
    const publicIps = lb.properties?.ips || fwIps || [];
    const privateIps = lb.properties?.lbPrivateIps || [];
    console.log(`[VDC-Viz] NLB "${name}": ips=${JSON.stringify(publicIps)}, lbPrivateIps=${JSON.stringify(privateIps)}, fwRuleIps=${JSON.stringify(fwIps)}`);
    addNode(`nlb-${lbId}`, 'nlb', name, {
      listenerLan: lb.properties?.listenerLan,
      targetLan: lb.properties?.targetLan,
      ips: publicIps,
      lbPrivateIps: privateIps,
      state: lb.metadata?.state,
    });
    const listenerLan = lanLookup(lanMap, lb.properties?.listenerLan);
    if (listenerLan) addLink(`nlb-${lbId}`, listenerLan, 'listener', { linkType: 'gateway' });
    const targetLan = lanLookup(lanMap, lb.properties?.targetLan);
    if (targetLan) addLink(`nlb-${lbId}`, targetLan, 'target', { linkType: 'gateway' });
  });

  // 6. DBaaS PostgreSQL
  const pgItems = pgClusters?.items || [];
  console.log(`[VDC-Viz] PostgreSQL clusters fetched: ${pgItems.length}`);
  pgItems.forEach(cluster => {
    const conns = cluster.properties?.connections || [];
    console.log(`[VDC-Viz]   PG "${cluster.properties?.displayName || cluster.id}": ${conns.length} connection(s), DCs: ${conns.map(c=>c.datacenterId).join(',')}, target DC: ${dcId}`);
    conns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const cId = cluster.id;
        const name = cluster.properties?.displayName || `PG ${cId}`;
        const nodeId = `pg-${cId}`;
        const existingNode = nodes.find(n => n.id === nodeId);
        if (!existingNode) {
          addNode(nodeId, 'postgres', name, {
            version: cluster.properties?.postgresVersion,
            instances: cluster.properties?.instances,
            connections: conns, state: cluster.metadata?.state || cluster.properties?.status,
            dnsName: cluster.properties?.dnsName,
            ram: cluster.properties?.ram, cores: cluster.properties?.cores,
            storageSize: cluster.properties?.storageSize,
            connectionIps: [],
          });
        }
        if (conn.cidr) {
          const n = nodes.find(n => n.id === nodeId);
          if (n && !n.data.connectionIps.includes(conn.cidr)) n.data.connectionIps.push(conn.cidr);
        }
        const lanNodeId = lanLookup(lanMap, conn.lanId);
        if (lanNodeId) addLink(nodeId, lanNodeId, conn.cidr || '', { linkType: 'managed' });
      }
    });
  });

  // 7. DBaaS MongoDB
  const mongoItems = mongoClusters?.items || [];
  console.log(`[VDC-Viz] MongoDB clusters fetched: ${mongoItems.length}`);
  mongoItems.forEach(cluster => {
    const conns = cluster.properties?.connections || [];
    console.log(`[VDC-Viz]   Mongo "${cluster.properties?.displayName || cluster.id}": ${conns.length} connection(s), DCs: ${conns.map(c=>c.datacenterId).join(',')}, target DC: ${dcId}`);
    conns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const cId = cluster.id;
        const name = cluster.properties?.displayName || `Mongo ${cId}`;
        const nodeId = `mongo-${cId}`;
        const existingNode = nodes.find(n => n.id === nodeId);
        if (!existingNode) {
          addNode(nodeId, 'mongodb', name, {
            version: cluster.properties?.mongoDBVersion,
            instances: cluster.properties?.instances,
            connections: conns, state: cluster.metadata?.state || cluster.properties?.status,
            templateId: cluster.properties?.templateId, type: cluster.properties?.type,
            connectionIps: [],
          });
        }
        if (conn.cidr) {
          const n = nodes.find(n => n.id === nodeId);
          if (n && !n.data.connectionIps.includes(conn.cidr)) n.data.connectionIps.push(conn.cidr);
        }
        const lanNodeId = lanLookup(lanMap, conn.lanId);
        if (lanNodeId) addLink(nodeId, lanNodeId, conn.cidr || '', { linkType: 'managed' });
      }
    });
  });

  // 8. DBaaS MySQL
  const mysqlItems = mysqlClusters?.items || [];
  console.log(`[VDC-Viz] MySQL clusters fetched: ${mysqlItems.length}`);
  mysqlItems.forEach(cluster => {
    const conns = cluster.properties?.connections || [];
    console.log(`[VDC-Viz]   MySQL "${cluster.properties?.displayName || cluster.id}": ${conns.length} connection(s), DCs: ${conns.map(c=>c.datacenterId).join(',')}, target DC: ${dcId}`);
    conns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const cId = cluster.id;
        const name = cluster.properties?.displayName || `MySQL ${cId}`;
        const nodeId = `mysql-${cId}`;
        const existingNode = nodes.find(n => n.id === nodeId);
        if (!existingNode) {
          addNode(nodeId, 'mysql', name, {
            version: cluster.properties?.mysqlVersion,
            instances: cluster.properties?.instances,
            connections: conns, state: cluster.metadata?.state || cluster.properties?.status,
            connectionIps: [],
          });
        }
        if (conn.cidr) {
          const n = nodes.find(n => n.id === nodeId);
          if (n && !n.data.connectionIps.includes(conn.cidr)) n.data.connectionIps.push(conn.cidr);
        }
        const lanNodeId = lanLookup(lanMap, conn.lanId);
        if (lanNodeId) addLink(nodeId, lanNodeId, conn.cidr || '', { linkType: 'managed' });
      }
    });
  });

  // 8b. DBaaS MariaDB
  const mariaItems = mariadbClusters?.items || [];
  console.log(`[VDC-Viz] MariaDB clusters fetched: ${mariaItems.length}`);
  mariaItems.forEach(cluster => {
    const conns = cluster.properties?.connections || [];
    console.log(`[VDC-Viz]   MariaDB "${cluster.properties?.displayName || cluster.id}": ${conns.length} connection(s), DCs: ${conns.map(c=>c.datacenterId).join(',')}`);
    conns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const cId = cluster.id;
        const name = cluster.properties?.displayName || cluster.properties?.name || `MariaDB ${cId}`;
        const nodeId = `mariadb-${cId}`;
        const existingNode = nodes.find(n => n.id === nodeId);
        if (!existingNode) {
          addNode(nodeId, 'mariadb', name, {
            version: cluster.properties?.mariadbVersion,
            instances: cluster.properties?.instances,
            connections: conns, state: cluster.metadata?.state || cluster.properties?.status,
            dnsName: cluster.properties?.dnsName,
            ram: cluster.properties?.ram, cores: cluster.properties?.cores,
            storageSize: cluster.properties?.storageSize,
            connectionIps: [],
          });
        }
        if (conn.cidr) {
          const n = nodes.find(n => n.id === nodeId);
          if (n && !n.data.connectionIps.includes(conn.cidr)) n.data.connectionIps.push(conn.cidr);
        }
        const lanNodeId = lanLookup(lanMap, conn.lanId);
        if (lanNodeId) addLink(nodeId, lanNodeId, conn.cidr || '', { linkType: 'managed' });
        else console.warn(`[VDC-Viz]   MariaDB "${name}": LAN ${conn.lanId} not found in lanMap`);
      }
    });
  });

  // 9. K8s Node Pools
  k8sNodePools.forEach(({ clusterId, clusterName, pool }) => {
    const poolLans = pool.properties?.lans || [];
    const matchingLans = poolLans.filter(l => lanLookup(lanMap, l.id));
    if (matchingLans.length > 0) {
      const pId = pool.id;
      const name = pool.properties?.name || `Pool ${pId}`;
      addNode(`k8s-${pId}`, 'k8s_np', name, {
        clusterName, clusterId,
        nodeCount: pool.properties?.nodeCount,
        k8sVersion: pool.properties?.k8sVersion,
        coresCount: pool.properties?.coresCount,
        ramSize: pool.properties?.ramSize,
        storageSize: pool.properties?.storageSize,
        state: pool.metadata?.state, lans: poolLans,
        connectionIps: [],
      });
      matchingLans.forEach(l => {
        const lanNodeId = lanLookup(lanMap, l.id);
        if (lanNodeId) addLink(`k8s-${pId}`, lanNodeId, '', { linkType: 'managed' });
      });
    }
  });

  // 10. NFS Clusters
  // NFS API uses: conn.lan (not lanId), conn.ipAddress (not ip)
  const nfsItems = nfsClusters?.items || [];
  nfsItems.forEach(cluster => {
    const conns = cluster.properties?.connections || cluster.connections || [];
    const clusterConns = Array.isArray(conns) ? conns : [];
    clusterConns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const cId = cluster.id;
        const name = cluster.properties?.name || cluster.name || `NFS ${cId}`;
        const nodeId = `nfs-${cId}`;
        const existingNode = nodes.find(n => n.id === nodeId);
        if (!existingNode) {
          addNode(nodeId, 'nfs', name, {
            size: cluster.properties?.size,
            connections: clusterConns,
            state: cluster.metadata?.state || cluster.metadata?.status || cluster.properties?.status || cluster.state,
            connectionIps: [],
          });
        }
        const nfsLanId = conn.lan || conn.lanId;
        const nfsIp = conn.ipAddress || conn.ip || '';
        if (nfsIp) {
          const n = nodes.find(n => n.id === nodeId);
          if (n && !n.data.connectionIps.includes(nfsIp)) n.data.connectionIps.push(nfsIp);
        }
        const lanNodeId = lanLookup(lanMap, nfsLanId);
        if (lanNodeId) addLink(nodeId, lanNodeId, nfsIp, { linkType: 'managed' });
      }
    });
  });

  // 11. VPN Gateways
  const wgItems = vpnGateways?.wireguard?.items || [];
  wgItems.forEach(gw => {
    const conns = gw.properties?.connections || [];
    conns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const gwId = gw.id;
        const name = gw.properties?.name || `WG VPN ${gwId}`;
        addNode(`vpn-wg-${gwId}`, 'vpn_wg', name, {
          gatewayIP: gw.properties?.gatewayIP, connections: conns,
          interfaceIPv4: conn.ipv4CIDR, interfaceIPv6: conn.ipv6CIDR,
          state: gw.metadata?.state || gw.metadata?.status || gw.properties?.status,
        });
        const lanNodeId = lanLookup(lanMap, conn.lanId);
        if (lanNodeId) addLink(`vpn-wg-${gwId}`, lanNodeId, conn.ipv4CIDR || '', { linkType: 'managed' });
      }
    });
  });

  const ipsecItems = vpnGateways?.ipsec?.items || [];
  ipsecItems.forEach(gw => {
    const conns = gw.properties?.connections || [];
    conns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const gwId = gw.id;
        const name = gw.properties?.name || `IPSec VPN ${gwId}`;
        addNode(`vpn-ipsec-${gwId}`, 'vpn_ipsec', name, {
          gatewayIP: gw.properties?.gatewayIP, connections: conns,
          state: gw.metadata?.state || gw.metadata?.status || gw.properties?.status,
        });
        const lanNodeId = lanLookup(lanMap, conn.lanId);
        if (lanNodeId) addLink(`vpn-ipsec-${gwId}`, lanNodeId, conn.ipv4CIDR || '', { linkType: 'managed' });
      }
    });
  });

  // 12. Kafka Clusters (Event Streams for Apache Kafka)
  const kafkaItems = kafkaClusters?.items || [];
  kafkaItems.forEach(cluster => {
    const conns = cluster.properties?.connections || [];
    conns.forEach(conn => {
      if (conn.datacenterId === dcId) {
        const cId = cluster.id;
        const name = cluster.properties?.name || `Kafka ${cId}`;
        addNode(`kafka-${cId}`, 'kafka', name, {
          version: cluster.properties?.version,
          size: cluster.properties?.size,
          brokerAddresses: cluster.metadata?.brokerAddresses || conn.brokerAddresses,
          state: cluster.metadata?.state || cluster.properties?.status,
        });
        const lanNodeId = lanLookup(lanMap, conn.lanId);
        if (lanNodeId) addLink(`kafka-${cId}`, lanNodeId, '', { linkType: 'managed' });
      }
    });
  });

  return { nodes, links };
}

// ============================== VISUALIZATION ==============================
function initSvg() {
  const svg = d3.select('#graphSvg');
  svg.selectAll('*').remove();
  svgGroup = svg.append('g').attr('class', 'graph-container');

  // SVG filter for heatmap halo blur
  const defs = svg.append('defs');
  const blur = defs.append('filter').attr('id', 'hmBlur').attr('x', '-50%').attr('y', '-50%').attr('width', '200%').attr('height', '200%');
  blur.append('feGaussianBlur').attr('in', 'SourceGraphic').attr('stdDeviation', '8');

  zoomBehavior = d3.zoom()
    .scaleExtent([0.1, 4])
    .on('zoom', (event) => { svgGroup.attr('transform', event.transform); });
  svg.call(zoomBehavior);
}

// ---- Map Background (Leaflet) ----
let bgMap = null;
let bgTileLayer = null;
let mapVisible = true;

function getMapTileUrl() {
  const style = currentTheme === 'light' ? 'light_all' : 'dark_all';
  return 'https://{s}.basemaps.cartocdn.com/' + style + '/{z}/{x}/{y}{r}.png';
}

function initMapBackground() {
  const container = document.getElementById('mapBackground');
  if (bgMap) { bgMap.remove(); bgMap = null; bgTileLayer = null; }
  bgMap = L.map(container, {
    zoomControl: false, attributionControl: false,
    dragging: false, scrollWheelZoom: false, doubleClickZoom: false,
    boxZoom: false, keyboard: false, touchZoom: false,
  });
  bgTileLayer = L.tileLayer(getMapTileUrl(), {
    subdomains: 'abcd', maxZoom: 19,
  }).addTo(bgMap);

  // Auto-invalidate map whenever the main-area container resizes
  // (handles AI panel open/close, detail panel, sidebar, window resize)
  if (typeof ResizeObserver !== 'undefined') {
    const mainArea = document.getElementById('mainArea');
    if (mainArea && !mainArea._mapResizeObserver) {
      mainArea._mapResizeObserver = new ResizeObserver(() => {
        if (bgMap) bgMap.invalidateSize({ animate: false });
      });
      mainArea._mapResizeObserver.observe(mainArea);
    }
  }
}

function updateMapTheme() {
  if (!bgMap || !bgTileLayer) return;
  bgTileLayer.setUrl(getMapTileUrl());
}

function updateMapBackground(location) {
  const region = locationRegion(location);
  const coords = LOCATION_COORDS[region];
  if (!coords || !bgMap) {
    document.getElementById('mapBackground').classList.remove('visible');
    return;
  }
  bgMap.invalidateSize({ animate: false });
  bgMap.setView([coords[0], coords[1]], coords[2], { animate: false });
  if (mapVisible) document.getElementById('mapBackground').classList.add('visible');
}

function toggleMapBackground() {
  mapVisible = !mapVisible;
  const el = document.getElementById('mapBackground');
  // Don't toggle passive visibility while in overview mode
  if (el.classList.contains('overview-mode')) return;
  el.classList.toggle('visible', mapVisible);
  document.getElementById('mapToggleBtn')?.classList.toggle('active', mapVisible);
}

// ---- Global Map Overview ----
let mapMarkers = [];
let mapDrillRegion = null;  // tracks which region we're zoomed into

function buildRegionClusters() {
  const byRegion = new Map();
  datacenters.forEach(dc => {
    const region = locationRegion(dc.properties?.location || '');
    if (!byRegion.has(region)) byRegion.set(region, []);
    byRegion.get(region).push({
      id: dc.id,
      name: dc.properties?.name || dc.id,
      location: dc.properties?.location || '',
    });
  });
  const clusters = [];
  byRegion.forEach((vdcs, region) => {
    const coords = LOCATION_COORDS[region];
    if (!coords) return;
    clusters.push({
      region,
      city: LOCATION_CITIES[region] || region,
      flag: countryFlag(region),
      coords: [coords[0], coords[1]],
      zoom: coords[2],
      vdcs,
    });
  });
  return clusters;
}

let availableLocationMarkers = [];

function clearMapMarkers() {
  mapMarkers.forEach(m => bgMap.removeLayer(m));
  mapMarkers = [];
}

function clearAvailableLocationMarkers() {
  availableLocationMarkers.forEach(m => bgMap.removeLayer(m));
  availableLocationMarkers = [];
}

// Show markers for all IONOS DC locations. When hasActiveClusters is true,
// available markers appear smaller/dimmed so active cluster bubbles stand out.
function showAvailableLocations(activeRegions) {
  clearAvailableLocationMarkers();
  if (!bgMap) return;

  const activeSet = new Set(activeRegions || []);
  const hasActive = activeSet.size > 0;
  Object.entries(LOCATION_COORDS).forEach(([region, coords]) => {
    if (activeSet.has(region)) return; // Active regions already have cluster bubbles
    const city = LOCATION_CITIES[region] || region;
    const flag = countryFlag(region);
    const cloudType = DC_CLOUD_TYPE[region] || 'public';
    const typeClass = cloudType === 'private' ? 'cloud-private' : cloudType === 'both' ? 'cloud-both' : '';
    const dimClass = hasActive ? ' dimmed' : '';
    const sz = hasActive ? 36 : 48;
    const icon = L.divIcon({
      className: '',
      html: `<div class="map-available-loc ${typeClass}${dimClass}">
        <span class="map-available-flag">${flag}</span>
        <span class="map-available-name">${city}</span>
      </div>`,
      iconSize: [sz, sz],
      iconAnchor: [sz / 2, sz / 2],
    });
    const marker = L.marker([coords[0], coords[1]], { icon }).addTo(bgMap);

    // Bind tooltip with cloud type
    const cloudClass = cloudType === 'private' ? 'tt-private' : cloudType === 'both' ? 'tt-both' : 'tt-public';
    const tooltipHtml = `<div class="tt-city">${flag} ${city}</div>
      <div class="tt-cloud ${cloudClass}">${cloudLabel(region)}</div>`;
    marker.bindTooltip(tooltipHtml, { className: 'map-loc-tooltip', direction: 'top', offset: [0, -28] });

    availableLocationMarkers.push(marker);
  });
}

function enableMapInteractions() {
  bgMap.dragging.enable();
  bgMap.scrollWheelZoom.enable();
  bgMap.doubleClickZoom.enable();
  bgMap.touchZoom.enable();
  bgMap.boxZoom.enable();
}

function disableMapInteractions() {
  bgMap.dragging.disable();
  bgMap.scrollWheelZoom.disable();
  bgMap.doubleClickZoom.disable();
  bgMap.touchZoom.disable();
  bgMap.boxZoom.disable();
}

function showMapOverview() {
  if (!bgMap) return;
  const el = document.getElementById('mapBackground');

  // Close AI panel instantly (no transition) so Leaflet sees correct container size
  closeAiPanelInstant();

  // Clear previous state
  clearMapMarkers();
  mapDrillRegion = null;
  document.getElementById('mapBackBtn').classList.remove('visible');
  closeDetail();
  closeHighlightsOverlay();
  if (heatmapActive) clearHeatmap();

  // Switch to overview mode
  el.classList.remove('visible');
  el.classList.add('overview-mode');
  enableMapInteractions();

  // Hide topology SVG, toolbar, and VDC-specific sidebar sections
  document.getElementById('graphSvg').classList.add('hidden-for-map');
  document.getElementById('toolbar').style.display = 'none';
  // Only hide onboarding card when connected (pre-login should keep it visible)
  if (!el.classList.contains('pre-login')) {
    document.getElementById('emptyState').style.display = 'none';
  }
  document.getElementById('legendSection').style.display = 'none';
  document.getElementById('searchSection').style.display = 'none';

  // Build clusters and add markers
  const clusters = buildRegionClusters();

  // Show faded markers for all available IONOS locations
  const activeRegions = clusters.map(c => c.region);
  showAvailableLocations(activeRegions);

  // If no user VDCs, still show available locations on the map
  if (clusters.length === 0 && Object.keys(LOCATION_COORDS).length > 0) {
    const allCoords = Object.values(LOCATION_COORDS).map(c => [c[0], c[1]]);
    bgMap.invalidateSize({ animate: false });
    bgMap.fitBounds(allCoords, { padding: [60, 60], maxZoom: 5, animate: false });
    bgMap.setMaxBounds([[15, -140], [72, 45]]);
    bgMap.setMinZoom(2);
    return;
  }

  // Collect bounds from all locations (active + available) for fitBounds
  const bounds = [];
  Object.values(LOCATION_COORDS).forEach(c => bounds.push([c[0], c[1]]));

  clusters.forEach(c => {
    const size = Math.max(64, Math.min(90, 64 + c.vdcs.length * 6));
    const icon = L.divIcon({
      className: '',
      html: `<div class="map-cluster-bubble" style="width:${size}px;height:${size}px;">
        <span class="map-cluster-flag">${c.flag}</span>
        <span class="map-cluster-name">${c.city}</span>
        <span class="map-cluster-count">${c.vdcs.length} VDC${c.vdcs.length > 1 ? 's' : ''}</span>
      </div>`,
      iconSize: [size, size],
      iconAnchor: [size / 2, size / 2],
    });

    const marker = L.marker(c.coords, { icon }).addTo(bgMap);
    // Click cluster → zoom into region and show individual VDC markers
    marker.on('click', () => drillIntoRegion(c));

    // Bind same-style tooltip as available markers for consistency
    const cloudType = DC_CLOUD_TYPE[c.region] || 'public';
    const cloudClass = cloudType === 'private' ? 'tt-private' : cloudType === 'both' ? 'tt-both' : 'tt-public';
    const tooltipHtml = `<div class="tt-city">${c.flag} ${c.city}</div>
      <div class="tt-cloud ${cloudClass}">${cloudLabel(c.region)} · ${c.vdcs.length} VDC${c.vdcs.length > 1 ? 's' : ''}</div>`;
    marker.bindTooltip(tooltipHtml, { className: 'map-loc-tooltip', direction: 'top', offset: [0, -size / 2 - 4] });

    mapMarkers.push(marker);
  });

  // Force Leaflet to re-measure container BEFORE setting the view
  // (critical when AI/detail panels have changed the available width)
  bgMap.invalidateSize({ animate: false });

  // Fit map to show all locations (active clusters + available DCs)
  if (bounds.length === 1) {
    bgMap.setView(bounds[0], 8, { animate: false });
  } else if (bounds.length > 1) {
    bgMap.fitBounds(bounds, { padding: [60, 60], maxZoom: 5, animate: false });
  }
  // Constrain to Europe + North America
  bgMap.setMaxBounds([[15, -140], [72, 45]]);
  bgMap.setMinZoom(2);

  // Show billing panel with region-level summary
  updateMapBillingPanel();
}

function drillIntoRegion(cluster) {
  if (!bgMap) return;
  mapDrillRegion = cluster.region;

  // Clear cluster markers and available location markers
  clearMapMarkers();
  clearAvailableLocationMarkers();

  // Zoom into the region
  bgMap.flyTo(cluster.coords, cluster.zoom + 2, { duration: 0.8 });

  // Show back button
  document.getElementById('mapBackBtn').classList.add('visible');

  // After zoom animation completes, place individual VDC markers spread around the center
  bgMap.once('moveend', () => {
    const vdcs = cluster.vdcs;
    const [cLat, cLon] = cluster.coords;
    // Spread VDCs in a circle around the center
    const spreadRadius = 0.008 * Math.max(1.5, vdcs.length * 0.6);

    vdcs.forEach((v, i) => {
      let lat, lon;
      if (vdcs.length === 1) {
        lat = cLat; lon = cLon;
      } else {
        const angle = (2 * Math.PI * i) / vdcs.length - Math.PI / 2;
        lat = cLat + spreadRadius * Math.sin(angle);
        lon = cLon + spreadRadius * Math.cos(angle) * 1.5; // wider horizontally
      }

      const size = 78;
      const icon = L.divIcon({
        className: '',
        html: `<div class="map-vdc-marker" style="width:${size}px;height:${size}px;" onclick="selectVdcFromMap('${v.id}')">
          <span class="map-cluster-flag">${cluster.flag}</span>
          <span class="map-cluster-name">${escapeHtml(v.name)}</span>
        </div>`,
        iconSize: [size, size],
        iconAnchor: [size / 2, size / 2],
      });

      const marker = L.marker([lat, lon], { icon }).addTo(bgMap);
      mapMarkers.push(marker);
    });

    // Show billing panel with per-VDC breakdown for this region
    updateMapBillingPanel(cluster.region);
  });
}

function hideMapOverview() {
  // Always hide the billing panel regardless of bgMap state
  const bp = document.getElementById('mapBillingPanel');
  if (bp) bp.classList.add('hidden');

  if (!bgMap) return;
  const el = document.getElementById('mapBackground');

  // Stop any running D3 simulation to free CPU
  if (simulation) { simulation.stop(); }

  // Clear markers and state
  clearMapMarkers();
  clearAvailableLocationMarkers();
  mapDrillRegion = null;
  document.getElementById('mapBackBtn').classList.remove('visible');
  bgMap.closePopup();

  // Disable interactions
  disableMapInteractions();
  bgMap.setMaxBounds(null);
  bgMap.setMinZoom(0);

  // Switch back to passive background
  el.classList.remove('overview-mode');
  if (mapVisible) el.classList.add('visible');

  // Show topology SVG and restore toolbar if a graph exists
  document.getElementById('graphSvg').classList.remove('hidden-for-map');
  const hasGraph = document.querySelector('#graphSvg .graph-container');
  document.getElementById('toolbar').style.display = hasGraph ? '' : 'none';
  if (!hasGraph) document.getElementById('emptyState').style.display = '';
}

function selectVdcFromMap(vdcId) {
  // Set the dropdown and switch to single VDC mode
  document.getElementById('dcSelect').value = vdcId;
  setViewMode('single');
  loadVDC();
}

function drawNode(g, d) {
  const cfg = NODE_TYPES[d.type] || NODE_TYPES.server;
  const r = cfg.radius;
  const c = cfg.color;

  // Background shape
  if (d.type === 'lan') {
    // Hexagon for LANs
    const pts = [];
    for (let i = 0; i < 6; i++) {
      const a = (Math.PI / 3) * i - Math.PI / 6;
      pts.push([r * Math.cos(a), r * Math.sin(a)]);
    }
    g.append('polygon')
      .attr('class', 'node-bg')
      .attr('points', pts.map(p => p.join(',')).join(' '))
      .attr('fill', c).attr('fill-opacity', 0.15)
      .attr('stroke', c).attr('stroke-width', 2.5);
  } else {
    // Circle for everything else
    g.append('circle')
      .attr('class', 'node-bg')
      .attr('r', r)
      .attr('fill', c).attr('fill-opacity', 0.12)
      .attr('stroke', c).attr('stroke-width', 2);
  }

  // Draw icon inside
  const iconGroup = g.append('g').attr('class', 'node-icon');
  const iconScale = d.type === 'lan' ? r * 0.55 : r * 0.48;
  const drawer = ICON_DRAW[d.type];
  if (drawer) {
    drawer(iconGroup, iconScale, c);
  }

  // Status indicator dot
  const status = d.data?.vmState || d.data?.state || '';
  const statusColor = STATUS_COLORS[status.toUpperCase()] || STATUS_COLORS[status];
  if (statusColor) {
    g.append('circle')
      .attr('class', 'status-dot')
      .attr('cx', r * 0.65).attr('cy', -r * 0.65)
      .attr('r', 4)
      .attr('fill', statusColor)
      .attr('stroke', 'var(--bg-primary)').attr('stroke-width', 1.5);
  }
}

function renderGraph(data) {
  graphData = data;
  if (heatmapActive) clearHeatmap();
  heatmapHaloGroup = null; // reset since SVG is recreated
  const svg = d3.select('#graphSvg');
  const width = document.getElementById('mainArea').clientWidth;
  const height = document.getElementById('mainArea').clientHeight;

  initSvg();

  if (data.nodes.length === 0) {
    document.getElementById('emptyState').querySelector('h2').textContent = 'No Resources Found';
    document.getElementById('emptyState').querySelector('p').textContent = 'This Virtual Data Center has no provisioned resources.';
    document.getElementById('emptyState').style.display = '';
    document.getElementById('toolbar').style.display = 'none';
    return;
  }

  document.getElementById('emptyState').style.display = 'none';
  document.getElementById('toolbar').style.display = '';

  // Links (drawn first, behind nodes)
  const linkGroup = svgGroup.append('g').attr('class', 'links');
  const link = linkGroup.selectAll('.link')
    .data(data.links)
    .join('line')
    .attr('class', d => `link ${d.linkType === 'nic' ? 'nic-link' : ''}`)
    .attr('stroke', d => {
      const lt = LINK_TYPES[d.linkType];
      if (lt) return lt.color;
      const srcNode = typeof d.source === 'object' ? d.source : data.nodes.find(n => n.id === d.source);
      return NODE_TYPES[srcNode?.type]?.color || '#475569';
    })
    .attr('stroke-dasharray', d => LINK_TYPES[d.linkType]?.dash || '0');

  // Animate links where both endpoints are in an active/available state
  const ACTIVE_STATES = new Set(['AVAILABLE', 'RUNNING', 'ACTIVE']);
  const INFRA_TYPES = new Set(['internet', 'lan', 'pcc', 'nat', 'alb', 'nlb', 'vpn_wg', 'vpn_ipsec', 'nfs', 'postgres', 'mongodb', 'mysql', 'mariadb', 'k8s_np', 'kafka']);
  const nodeByIdMap = new Map(data.nodes.map(n => [n.id, n]));
  link.each(function(d) {
    const sId = typeof d.source === 'object' ? d.source.id : d.source;
    const tId = typeof d.target === 'object' ? d.target.id : d.target;
    const sNode = nodeByIdMap.get(sId);
    const tNode = nodeByIdMap.get(tId);
    const sState = (sNode?.data?.state || sNode?.data?.vmState || '').toUpperCase();
    const tState = (tNode?.data?.state || tNode?.data?.vmState || '').toUpperCase();
    const sActive = INFRA_TYPES.has(sNode?.type) || ACTIVE_STATES.has(sState);
    const tActive = INFRA_TYPES.has(tNode?.type) || ACTIVE_STATES.has(tState);
    if (sActive && tActive) {
      d3.select(this).classed('traffic-flow', true);
    }
  });

  // Link label backgrounds (for readability)
  const linkLabelGroup = svgGroup.append('g').attr('class', 'link-labels');
  const labelsData = data.links.filter(d => d.label);

  // Label bg rects (added after positioning in tick)
  const linkLabelBg = linkLabelGroup.selectAll('.link-label-bg')
    .data(labelsData)
    .join('rect')
    .attr('class', 'link-label-bg')
    .attr('rx', 3).attr('ry', 3);

  const linkLabel = linkLabelGroup.selectAll('.link-label')
    .data(labelsData)
    .join('text')
    .attr('class', 'link-label')
    .text(d => d.label);

  // Nodes
  const nodeGroup = svgGroup.append('g').attr('class', 'nodes');
  const node = nodeGroup.selectAll('.node')
    .data(data.nodes)
    .join('g')
    .attr('class', 'node')
    .attr('data-ntype', d => d.type)
    .call(d3.drag()
      .on('start', dragStarted)
      .on('drag', dragged)
      .on('end', dragEnded)
    )
    .on('click', (event, d) => { event.stopPropagation(); showDetail(d); highlightNode(d); })
    .on('mouseenter', (event, d) => showTooltip(event, d))
    .on('mousemove', (event) => moveTooltip(event))
    .on('mouseleave', () => hideTooltip());

  // Draw each node (shape + icon)
  node.each(function(d) { drawNode(d3.select(this), d); });

  // Labels below nodes
  node.append('text')
    .attr('class', 'node-label')
    .attr('dy', d => (NODE_TYPES[d.type]?.radius || 28) + 16)
    .text(d => truncate(d.name, 16));

  // Sublabels (line 1)
  node.append('text')
    .attr('class', d => {
      if (d.type === 'lan') return 'node-sublabel node-ip-label';
      if (d.type === 'server' || d.type === 'cube') {
        const vmType = (d.data.type || '').toUpperCase();
        const cls = vmType === 'CUBE' ? 'compute-cube' : vmType === 'VCPU' ? 'compute-vcpu' : vmType === 'ENTERPRISE' ? 'compute-enterprise' : vmType === 'GPU' ? 'compute-gpu' : 'compute-other';
        return `node-sublabel node-compute-label ${cls}`;
      }
      return 'node-sublabel';
    })
    .attr('dy', d => (NODE_TYPES[d.type]?.radius || 28) + 28)
    .text(d => {
      if (d.type === 'lan') {
        const parts = [];
        if (d.data.isPublic) parts.push('Public');
        if (d.data.cidr) parts.push(d.data.cidr);
        return parts.join(' \u2022 ') || 'Private';
      }
      if (d.type === 'server' || d.type === 'cube') return `${d.data.cores || '?'}C / ${formatRAM(d.data.ram)}`;
      if (d.type === 'postgres') return `v${d.data.version || '?'}`;
      if (d.type === 'mongodb') return `v${d.data.version || '?'}`;
      if (d.type === 'mysql') return `v${d.data.version || '?'}`;
      if (d.type === 'mariadb') return `v${d.data.version || '?'}`;
      if (d.type === 'k8s_np') return `${d.data.nodeCount || '?'} nodes`;
      if (d.type === 'kafka') return `v${d.data.version || '?'} (${d.data.size || '?'})`;
      if (d.type === 'pcc') return 'Private Cross Connect';
      return '';
    });

  // Sublabels (line 2) — IPs for servers & managed resources, IPv6 for LANs
  node.append('text')
    .attr('class', 'node-sublabel node-ip-label')
    .attr('dy', d => (NODE_TYPES[d.type]?.radius || 28) + 42)
    .text(d => {
      if (d.type === 'lan') return d.data.ipv6Cidr || '';
      // Servers: collect all NIC IPs (first IP per NIC)
      if (d.type === 'server' || d.type === 'cube') {
        const nics = d.data.nics || [];
        const ips = nics.flatMap(n => n.ips || []);
        return ips.length > 0 ? truncate(ips.join(', '), 28) : '';
      }
      // NAT GW: public IPs
      if (d.type === 'nat') return (d.data.publicIps || []).join(', ') || '';
      // ALB / NLB: public + private IPs
      if (d.type === 'alb' || d.type === 'nlb') {
        const pub = d.data.ips || [];
        const priv = d.data.lbPrivateIps || [];
        const all = [...pub, ...priv];
        return all.length > 0 ? truncate(all.join(', '), 28) : '';
      }
      // VPN: gateway IP
      if (d.type === 'vpn_wg' || d.type === 'vpn_ipsec') return d.data.gatewayIP || '';
      // Kafka: broker addresses
      if (d.type === 'kafka') {
        const addrs = d.data.brokerAddresses || [];
        return addrs.length > 0 ? truncate(addrs[0], 28) : '';
      }
      // Managed services (DBaaS, NFS, K8s): connection IPs
      if (d.data.connectionIps && d.data.connectionIps.length > 0) {
        return truncate(d.data.connectionIps.join(', '), 28);
      }
      return '';
    });

  // ── VDC boundary boxes — created upfront and updated every tick ──
  let vdcBoundaryEls = [];
  if (data._vdcBoundaries && data._vdcBoundaries.length >= 1) {
    // Insert boundary group BEHIND nodes & links (rendered first = behind)
    const labelGroup = svgGroup.insert('g', ':first-child').attr('class', 'vdc-labels');
    data._vdcBoundaries.forEach(vdc => {
      const vdcG = labelGroup.append('g').attr('class', `vdc-boundary-${vdc.index}`);

      const boundaryRect = vdcG.append('rect')
        .attr('class', 'vdc-boundary-rect')
        .attr('rx', 12).attr('ry', 12)
        .attr('fill', 'none')
        .attr('stroke', 'var(--border)')
        .attr('stroke-width', 1.5)
        .attr('stroke-dasharray', '8,4')
        .attr('stroke-opacity', 0.5);

      const labelW = vdc.name.length * 8 + 40;
      const labelBg = vdcG.append('rect')
        .attr('class', 'vdc-label-bg')
        .attr('width', labelW).attr('height', 24);

      const toggleText = vdcG.append('text')
        .attr('class', 'vdc-toggle')
        .text('\u25BC')
        .on('click', (event) => { event.stopPropagation(); toggleVdc(vdc.index); });

      const nameText = vdcG.append('text')
        .attr('class', 'vdc-label-text')
        .text(vdc.name)
        .style('cursor', 'pointer')
        .on('click', (event) => { event.stopPropagation(); toggleVdc(vdc.index); });

      const collapsedLabel = vdcG.append('text')
        .attr('class', 'vdc-collapsed-label')
        .style('display', 'none');

      // Pre-resolve node references once to avoid filtering on every tick
      const _cachedNodes = data.nodes.filter(n => vdc.nodeIds.has(n.id));
      vdcBoundaryEls.push({ vdc, boundaryRect, labelBg, toggleText, nameText, collapsedLabel, _cachedNodes });
    });
  }

  // ── Connected-component clustering: give each network group its own region ──
  // 1. Build adjacency list
  const adj = new Map();
  data.nodes.forEach(n => adj.set(n.id, []));
  data.links.forEach(l => {
    const sId = typeof l.source === 'object' ? l.source.id : l.source;
    const tId = typeof l.target === 'object' ? l.target.id : l.target;
    if (adj.has(sId)) adj.get(sId).push(tId);
    if (adj.has(tId)) adj.get(tId).push(sId);
  });

  // 2. Find connected components via BFS
  const visitedNodes = new Set();
  const components = [];
  data.nodes.forEach(n => {
    if (visitedNodes.has(n.id)) return;
    const comp = [];
    const queue = [n.id];
    visitedNodes.add(n.id);
    while (queue.length) {
      const curr = queue.shift();
      comp.push(curr);
      for (const nb of (adj.get(curr) || [])) {
        if (!visitedNodes.has(nb)) { visitedNodes.add(nb); queue.push(nb); }
      }
    }
    components.push(comp);
  });

  // 3. Sort components: largest first for prominent placement
  components.sort((a, b) => b.length - a.length);

  // Tag each node with its component index (used by lanAlign force)
  const nodeById = new Map(data.nodes.map(n => [n.id, n]));
  components.forEach((comp, ci) => {
    comp.forEach(id => { const n = nodeById.get(id); if (n) n._compId = ci; });
  });

  // 4. Assign each component a horizontal band with gap between them
  const outerMargin = width * 0.08;
  const compGap = Math.min(200, width * 0.10);
  const availableWidth = width - 2 * outerMargin - Math.max(0, components.length - 1) * compGap;
  const totalNodeCount = data.nodes.length || 1;

  // Each component gets width proportional to its node count (min 180px per component)
  const minCompW = 180;
  let rawWidths = components.map(c => Math.max(minCompW, (c.length / totalNodeCount) * availableWidth));
  const rawTotal = rawWidths.reduce((a, b) => a + b, 0);
  if (rawTotal > availableWidth && availableWidth > 0) {
    const scale = availableWidth / rawTotal;
    rawWidths = rawWidths.map(w => w * scale);
  }

  // Calculate component band start/center X
  const compBands = [];
  let cx = outerMargin;
  rawWidths.forEach((w, i) => {
    compBands.push({ left: cx, center: cx + w / 2, width: w });
    cx += w + compGap;
  });

  // 5. Build nodeId → component index lookup
  const nodeCompIdx = new Map();
  components.forEach((comp, ci) => comp.forEach(id => nodeCompIdx.set(id, ci)));

  // 6. Within each component, position LANs evenly and assign children
  const nodeClusterX = new Map();
  const lanXPositions = new Map();

  components.forEach((comp, ci) => {
    const band = compBands[ci];
    if (!band) return;
    const compLanIds = comp.filter(id => {
      const nd = data.nodes.find(n => n.id === id);
      return nd?.type === 'lan';
    });

    // Position LANs within this component's band
    if (compLanIds.length === 0) {
      // No LANs — center everything
      comp.forEach(id => nodeClusterX.set(id, band.center));
    } else {
      const lanMargin = band.width * 0.12;
      compLanIds.forEach((lanId, idx) => {
        const x = compLanIds.length > 1
          ? (band.left + lanMargin) + (idx / (compLanIds.length - 1)) * (band.width - 2 * lanMargin)
          : band.center;
        lanXPositions.set(lanId, x);
        nodeClusterX.set(lanId, x);
      });

      // Assign non-LAN nodes to their connected LAN(s) — average for multi-homed
      const nonLanIds = comp.filter(id => !lanXPositions.has(id));
      // Direct neighbours of LANs
      const nodeXLists = new Map();
      data.links.forEach(l => {
        const sId = typeof l.source === 'object' ? l.source.id : l.source;
        const tId = typeof l.target === 'object' ? l.target.id : l.target;
        if (lanXPositions.has(sId) && nodeCompIdx.get(tId) === ci) {
          if (!nodeXLists.has(tId)) nodeXLists.set(tId, []);
          nodeXLists.get(tId).push(lanXPositions.get(sId));
        }
        if (lanXPositions.has(tId) && nodeCompIdx.get(sId) === ci) {
          if (!nodeXLists.has(sId)) nodeXLists.set(sId, []);
          nodeXLists.get(sId).push(lanXPositions.get(tId));
        }
      });
      nodeXLists.forEach((xs, id) => {
        if (!nodeClusterX.has(id)) {
          nodeClusterX.set(id, xs.reduce((a, b) => a + b, 0) / xs.length);
        }
      });

      // Propagate through indirect chains within this component
      let changed = true;
      while (changed) {
        changed = false;
        data.links.forEach(l => {
          const sId = typeof l.source === 'object' ? l.source.id : l.source;
          const tId = typeof l.target === 'object' ? l.target.id : l.target;
          if (nodeCompIdx.get(sId) !== ci && nodeCompIdx.get(tId) !== ci) return;
          if (nodeClusterX.has(sId) && !nodeClusterX.has(tId)) {
            nodeClusterX.set(tId, nodeClusterX.get(sId)); changed = true;
          }
          if (nodeClusterX.has(tId) && !nodeClusterX.has(sId)) {
            nodeClusterX.set(sId, nodeClusterX.get(tId)); changed = true;
          }
        });
      }

      // Any remaining unassigned nodes in this component → center of band
      comp.forEach(id => { if (!nodeClusterX.has(id)) nodeClusterX.set(id, band.center); });
    }
  });

  // ── Pre-build adjacency map for O(1) access (nodeByIdMap created above) ──
  // Adjacency map: nodeId → [connected node objects]
  const adjacencyMap = new Map();
  data.nodes.forEach(n => adjacencyMap.set(n.id, []));
  data.links.forEach(l => {
    const sId = typeof l.source === 'object' ? l.source.id : l.source;
    const tId = typeof l.target === 'object' ? l.target.id : l.target;
    const sNode = nodeByIdMap.get(sId), tNode = nodeByIdMap.get(tId);
    if (sNode && tNode) {
      adjacencyMap.get(sId).push(tNode);
      adjacencyMap.get(tId).push(sNode);
    }
  });
  // Store on graphData for use by highlight/detail functions
  graphData._nodeMap = nodeByIdMap;
  graphData._adj = adjacencyMap;

  // Build persistent IP→nodeId and NIC→nodeId lookup maps for resolveFlowPath
  const ipToNodes = new Map();   // IP string → Set of node IDs
  const nicToNode = new Map();   // NIC UUID → node ID
  data.nodes.forEach(n => {
    if (n.data?.nics) {
      n.data.nics.forEach(nic => {
        if (nic.nicId) nicToNode.set(nic.nicId, n.id);
        if (nic.ips) nic.ips.forEach(ip => {
          if (!ipToNodes.has(ip)) ipToNodes.set(ip, new Set());
          ipToNodes.get(ip).add(n.id);
        });
      });
    }
    if (n.type === 'ipblock' && n.data?.ips) {
      n.data.ips.forEach(ip => {
        if (!ipToNodes.has(ip)) ipToNodes.set(ip, new Set());
        ipToNodes.get(ip).add(n.id);
      });
    }
    if (n.type === 'nat' && n.data?.publicIps) {
      n.data.publicIps.forEach(ip => {
        if (!ipToNodes.has(ip)) ipToNodes.set(ip, new Set());
        ipToNodes.get(ip).add(n.id);
      });
    }
  });
  graphData._ipToNodes = ipToNodes;
  graphData._nicToNode = nicToNode;

  // Build BFS adjacency map for flow path resolution
  const bfsAdj = new Map();
  data.links.forEach((l, idx) => {
    const sId = typeof l.source === 'object' ? l.source.id : l.source;
    const tId = typeof l.target === 'object' ? l.target.id : l.target;
    if (!bfsAdj.has(sId)) bfsAdj.set(sId, []);
    if (!bfsAdj.has(tId)) bfsAdj.set(tId, []);
    bfsAdj.get(sId).push({ neighborId: tId, linkIdx: idx });
    bfsAdj.get(tId).push({ neighborId: sId, linkIdx: idx });
  });
  graphData._bfsAdj = bfsAdj;

  // Pre-initialize positions for key node types so simulation starts from sensible layout
  data.nodes.forEach(d => {
    if (d.type === 'internet' || d.type === 'pcc') {
      d.y = height * SIM_CONFIG.yPosition.pcc;
      d.x = nodeClusterX.get(d.id) || width / 2;
    } else if (d.type === 'nat') {
      d.y = height * SIM_CONFIG.yPosition.nat;
      d.x = nodeClusterX.get(d.id) || width / 2;
    } else if (d.type === 'lan') {
      d.y = height * SIM_CONFIG.yPosition.lan;
      d.x = nodeClusterX.get(d.id) || width / 2;
    } else if (d.type === 'alb' || d.type === 'nlb') {
      d.y = height * SIM_CONFIG.yPosition.lb;
      d.x = nodeClusterX.get(d.id) || width / 2;
    }
  });

  // Force simulation — stop previous to prevent memory leak
  if (simulation) { simulation.stop(); simulation = null; }
  simulation = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(data.links).id(d => d.id).distance(d => {
      const s = typeof d.source === 'object' ? d.source : nodeByIdMap.get(d.source);
      const t = typeof d.target === 'object' ? d.target : nodeByIdMap.get(d.target);
      return (s?.type === 'lan' || t?.type === 'lan') ? SIM_CONFIG.linkDistance.lan : SIM_CONFIG.linkDistance.default;
    }))
    .force('charge', d3.forceManyBody().strength(d => {
      if (d.type === 'pcc') return SIM_CONFIG.charge.pcc;
      if (d.type === 'lan') return SIM_CONFIG.charge.lan;
      return SIM_CONFIG.charge.default;
    }))
    .force('center', d3.forceCenter(width / 2, height / 2))
    .force('collision', d3.forceCollide().radius(d => {
      if (d.type === 'lan') return (NODE_TYPES[d.type]?.radius || 40) + SIM_CONFIG.collisionPadding.lan;
      return (NODE_TYPES[d.type]?.radius || 28) + SIM_CONFIG.collisionPadding.default;
    }))
    .force('x', d3.forceX(d => {
      if (nodeClusterX.has(d.id)) return nodeClusterX.get(d.id);
      return width / 2;
    }).strength(d => {
      if (d.type === 'internet') return 0.08;  // Gently center Internet horizontally
      if (d.type === 'pcc') return SIM_CONFIG.xStrength.pcc;
      if (d.type === 'lan') return SIM_CONFIG.xStrength.lan;
      if (nodeClusterX.has(d.id)) return SIM_CONFIG.xStrength.lanChild;
      return SIM_CONFIG.xStrength.unattached;
    }))
    .force('y', d3.forceY(d => {
      if (d.type === 'pcc') return height * SIM_CONFIG.yPosition.pcc;
      if (d.type === 'internet') return height * SIM_CONFIG.yPosition.internet;
      if (d.type === 'nat') return height * SIM_CONFIG.yPosition.nat;
      if (d.type === 'lan') return height * SIM_CONFIG.yPosition.lan;
      if (d.type === 'alb' || d.type === 'nlb') return height * SIM_CONFIG.yPosition.lb;
      return height * SIM_CONFIG.yPosition.default;
    }).strength(d => {
      // Internet, PCC & NAT need stronger pull to stay in their tier
      if (d.type === 'internet' || d.type === 'pcc') return 0.4;
      if (d.type === 'nat') return 0.3;
      if (d.type === 'lan') return 0.35;
      if (d.type === 'alb' || d.type === 'nlb') return 0.25;
      return SIM_CONFIG.yStrength;
    }))
    .force('lanAlign', (function() {
      // Custom force: gently pull LANs in the same connected component toward the same Y
      let nodes;
      function force(alpha) {
        if (!nodes) return;
        // Group LAN nodes by connected component
        const compLans = new Map(); // compId -> [lanNode, ...]
        nodes.forEach(n => {
          if (n.type === 'lan' && n._compId !== undefined) {
            if (!compLans.has(n._compId)) compLans.set(n._compId, []);
            compLans.get(n._compId).push(n);
          }
        });
        // For each component, compute average Y and nudge LANs toward it
        compLans.forEach(lans => {
          if (lans.length < 2) return;
          const avgY = lans.reduce((s, n) => s + n.y, 0) / lans.length;
          lans.forEach(n => {
            n.vy += (avgY - n.y) * SIM_CONFIG.lanAlignStrength * alpha;
          });
        });
      }
      force.initialize = function(n) { nodes = n; };
      return force;
    })())
    .on('tick', () => {
      link
        .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x).attr('y2', d => d.target.y);

      // Position link labels closer to the source node (server/VM side)
      linkLabel
        .attr('x', d => d.source.x * SIM_CONFIG.labelPosition.sourceWeight + d.target.x * SIM_CONFIG.labelPosition.targetWeight)
        .attr('y', d => d.source.y * SIM_CONFIG.labelPosition.sourceWeight + d.target.y * SIM_CONFIG.labelPosition.targetWeight + SIM_CONFIG.labelPosition.yOffset);

      node.attr('transform', d => `translate(${d.x},${d.y})`);

      // Update heatmap halo positions if active
      if (heatmapActive) updateHeatmapHalos();

      // Update VDC boundary positions every tick so they're visible immediately
      vdcBoundaryEls.forEach(({ vdc, boundaryRect, labelBg, toggleText, nameText, collapsedLabel, _cachedNodes }) => {
        // Use cached node refs (pre-resolved once) instead of filtering every tick
        const vdcNodes = _cachedNodes;
        if (!vdcNodes || vdcNodes.length === 0) return;
        // Single pass to compute bounds instead of 4× d3.min/max scans
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (let i = 0; i < vdcNodes.length; i++) {
          const n = vdcNodes[i];
          if (n.x < minX) minX = n.x;
          if (n.y < minY) minY = n.y;
          if (n.x > maxX) maxX = n.x;
          if (n.y > maxY) maxY = n.y;
        }
        const pad = 50;
        minX -= pad; minY -= 70; maxX += pad; maxY += pad;

        boundaryRect
          .attr('x', minX - 10).attr('y', minY - 10)
          .attr('width', maxX - minX + 20).attr('height', maxY - minY + 20);

        labelBg.attr('x', minX).attr('y', minY - 30);
        toggleText.attr('x', minX + 8).attr('y', minY - 13);
        nameText.attr('x', minX + 22).attr('y', minY - 13);
        collapsedLabel.attr('x', minX + 10).attr('y', minY + 12);
      });
    })
    .on('end', () => {
      // Position label backgrounds ONCE after simulation stabilizes (avoids getBBox thrashing per tick)
      linkLabelBg.each(function(d, i) {
        const textEl = linkLabel.nodes()[i];
        if (textEl) {
          const bbox = textEl.getBBox();
          d3.select(this)
            .attr('x', bbox.x - 3).attr('y', bbox.y - 1)
            .attr('width', bbox.width + 6).attr('height', bbox.height + 2);
        }
      });

    });

  // Click background to deselect
  svg.on('click', () => { clearHighlight(); closeDetail(); clearFlowHighlight(); if (heatmapActive) clearHeatmap(); });

  updateStats(data);
  updateLegend(data);
  document.getElementById('searchSection').style.display = '';
}

function dragStarted(event, d) {
  if (!event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x; d.fy = d.y;
}
function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
function dragEnded(event, d) {
  if (!event.active) simulation.alphaTarget(0);
  d.fx = null; d.fy = null;
}

// ============================== HIGHLIGHT ==============================
function highlightNode(d) {
  // Build connected set using O(1) adjacency map
  const connectedIds = new Set([d.id]);
  if (graphData._adj) {
    (graphData._adj.get(d.id) || []).forEach(n => connectedIds.add(n.id));
  }
  d3.selectAll('.node')
    .classed('highlighted', n => n.id === d.id)
    .classed('dimmed', n => !connectedIds.has(n.id));
  d3.selectAll('.link')
    .classed('highlighted', l => {
      const sid = typeof l.source === 'object' ? l.source.id : l.source;
      const tid = typeof l.target === 'object' ? l.target.id : l.target;
      return sid === d.id || tid === d.id;
    })
    .classed('dimmed', l => {
      const sid = typeof l.source === 'object' ? l.source.id : l.source;
      const tid = typeof l.target === 'object' ? l.target.id : l.target;
      return sid !== d.id && tid !== d.id;
    });
}

function clearHighlight() {
  d3.selectAll('.node').classed('highlighted', false).classed('dimmed', false);
  d3.selectAll('.link').classed('highlighted', false).classed('dimmed', false);
}

// ============================== LEGEND TYPE FILTER ==============================
function filterByType(type) {
  if (highlightedTypes.has(type)) { highlightedTypes.delete(type); }
  else { highlightedTypes.add(type); }
  d3.selectAll('.node').style('display', d => highlightedTypes.has(d.type) ? '' : 'none');
  d3.selectAll('.link').style('display', l => {
    const sType = typeof l.source === 'object' ? l.source.type : '';
    const tType = typeof l.target === 'object' ? l.target.type : '';
    return highlightedTypes.has(sType) && highlightedTypes.has(tType) ? '' : 'none';
  });
  document.querySelectorAll('.legend-item').forEach(el => {
    el.classList.toggle('dimmed', !highlightedTypes.has(el.dataset.type));
  });
}

// ============================== SEARCH ==============================
let searchTimeout = null;
function searchNodes(query) {
  const clear = document.getElementById('searchClear');
  const results = document.getElementById('searchResults');
  clear.style.display = query ? '' : 'none';
  if (!query || query.length < 2) { results.innerHTML = ''; return; }
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => {
    const q = query.toLowerCase();
    const matches = graphData.nodes.filter(n => (n.name || '').toLowerCase().includes(q) || (n.id || '').toLowerCase().includes(q));
    if (matches.length === 0) {
      results.innerHTML = `<div class="search-result-count">${t('search.noMatches')}</div>`;
      return;
    }
    let html = `<div class="search-result-count">${t('search.matchCount', {count: matches.length})}</div>`;
    matches.slice(0, 15).forEach(n => {
      const cfg = NODE_TYPES[n.type] || {};
      html += `<div class="search-result-item" onclick="focusNode('${escapeHtml(n.id)}')"><span class="search-result-dot" style="background:${cfg.color}"></span><span>${escapeHtml(n.name)}</span></div>`;
    });
    if (matches.length > 15) html += `<div class="search-result-count">${t('search.andMore', {count: matches.length - 15})}</div>`;
    results.innerHTML = html;
  }, 250);
}
function clearSearch() {
  document.getElementById('searchInput').value = '';
  document.getElementById('searchResults').innerHTML = '';
  document.getElementById('searchClear').style.display = 'none';
}

// ============================== SIDEBAR TOGGLE ==============================
function toggleSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const btn = document.getElementById('sidebarToggle');
  const expandBtn = document.getElementById('sidebarExpand');
  const search = document.getElementById('searchSection');
  sidebar.classList.toggle('collapsed');
  const isCollapsed = sidebar.classList.contains('collapsed');
  btn.innerHTML = isCollapsed ? '&#x25B6;' : '&#x25C0;';
  expandBtn.classList.toggle('visible', isCollapsed);
  // Shift search bar right when expand button is visible
  if (search) search.style.left = isCollapsed ? '58px' : '16px';
  // Let map recalculate size after sidebar transition
  if (typeof bgMap !== 'undefined' && bgMap) {
    setTimeout(() => bgMap.invalidateSize(), 350);
  }
}

// ============================== DETAIL PANEL ==============================
function showDetail(d) {
  const panel = document.getElementById('detailPanel');
  const content = document.getElementById('detailContent');
  const cfg = NODE_TYPES[d.type] || {};

  let html = `
    <div class="detail-header">
      <h2>${escapeHtml(d.name)}</h2>
      <button class="detail-close" onclick="closeDetail()">&times;</button>
    </div>
    <span class="detail-badge" style="background:${cfg.color}33;color:${cfg.color}">${cfg.label || d.type}</span>
  `;

  const props = buildDetailProps(d);
  if (props.length > 0) {
    html += '<table class="detail-table">';
    props.forEach(([k, v]) => {
      html += `<tr><th>${escapeHtml(k)}</th><td>${escapeHtml(String(v))}</td></tr>`;
    });
    html += '</table>';
  }

  // NIC details for servers
  if ((d.type === 'server' || d.type === 'cube') && d.data.nics && d.data.nics.length > 0) {
    html += `<div class="detail-section-title">${t('detail.nics')}</div>`;
    d.data.nics.forEach((nic, i) => {
      const badges = [];
      if (nic.firewall) badges.push('<span style="color:#10b981;">&#x25cf; Firewall</span>');
      if (nic.flowLogsEnabled) badges.push('<span style="color:#11C7E6;">&#x25cf; FlowLogs</span>');
      if (nic.securityGroupCount > 0) badges.push(`<span style="color:#FFAA00;">&#x25cf; ${nic.securityGroupCount} SecGroup(s)</span>`);
      if (nic.multiQueue) badges.push('<span style="color:#8b5cf6;">&#x25cf; MultiQ</span>');
      html += `
        <div style="background:var(--bg-tertiary);border-radius:6px;padding:8px 10px;margin-bottom:6px;font-size:12px;">
          <div style="font-weight:600;color:var(--text-primary);margin-bottom:4px;">${escapeHtml(nic.name || `NIC ${i+1}`)}</div>
          <div style="color:var(--text-muted);">LAN: ${nic.lanId} &middot; MAC: ${escapeHtml(nic.mac || 'N/A')}</div>
          <div style="color:var(--text-secondary);">IPv4: ${escapeHtml((nic.ips || []).join(', ') || 'None')}</div>
          ${nic.ipv6?.length ? `<div style="color:var(--text-muted);font-size:10px;">IPv6: ${escapeHtml(nic.ipv6.join(', '))}</div>` : ''}
          <div style="color:var(--text-muted);font-size:10px;">DHCP: ${nic.dhcp ? 'Yes' : 'No'} &middot; Firewall: ${nic.firewall ? 'Active' : 'Off'}</div>
          ${badges.length ? `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:4px;font-size:10px;">${badges.join('')}</div>` : ''}
          ${nic.securityGroupIds?.length ? `<div style="color:var(--text-muted);font-size:10px;margin-top:2px;">SG: ${nic.securityGroupIds.map(id => { const sg = graphData?._securityGroups?.get(id); return escapeHtml(sg ? sg.name : id); }).join(', ')}</div>` : ''}
        </div>`;
    });
  }

  // Network Metrics section (async load for servers)
  if (d.type === 'server' || d.type === 'cube') {
    html += `<div class="detail-section-title">${t('detail.networkMetrics')}</div>`;
    html += `<div id="metricsContainer"><div class="metrics-loading">${t('detail.loading')}</div></div>`;
    // Trigger async metrics load after panel renders
    // Use _origId if available (location mode prefixes IDs with vdc0-, vdc1-, etc.)
    const rawId = d._origId || d.id;
    setTimeout(() => loadAndShowMetrics(rawId.replace(/^srv-/, '')), 50);

    // Data Transfer section (async, uses pre-fetched billing data)
    html += `<div class="detail-section-title">${t('detail.billingTraffic')}</div>`;
    html += `<div id="billingContainer"><div class="metrics-loading">${t('detail.loading')}</div></div>`;
    setTimeout(() => loadAndShowBillingChart(rawId.replace(/^srv-/, '')), 100);
  }

  // Security Group Rules section (if loaded)
  if (graphData?._securityGroups && graphData._securityGroups.size > 0) {
    // Collect SG IDs from server-level AND NIC-level security groups
    const sgIds = new Set();
    if (d.type === 'server' || d.type === 'cube') {
      (d.data.securityGroupIds || []).forEach(id => sgIds.add(id));
      (d.data.nics || []).forEach(nic => {
        (nic.securityGroupIds || []).forEach(id => sgIds.add(id));
      });
    }
    if (sgIds.size > 0) {
      html += `<div class="detail-section-title">${t('detail.securityRules')}</div>`;
      sgIds.forEach(sgId => {
        const sg = graphData._securityGroups.get(sgId);
        if (!sg) return;
        html += `<div style="font-size:11px;font-weight:600;color:var(--text-primary);margin-bottom:4px;">${escapeHtml(sg.name)}${sg.description ? ` <span style="font-weight:400;color:var(--text-muted);font-size:10px;">\u2014 ${escapeHtml(sg.description)}</span>` : ''}</div>`;
        if (sg.rules.length === 0) {
          html += `<div style="font-size:10px;color:var(--text-muted);margin-bottom:6px;">${t('detail.noRules')}</div>`;
        } else {
          html += `<table style="width:100%;font-size:10px;border-collapse:collapse;margin-bottom:8px;">`;
          html += `<tr style="color:var(--text-muted);text-align:left;border-bottom:1px solid var(--border);">
            <th style="padding:3px 4px;font-weight:600;">${t('detail.ruleDir')}</th>
            <th style="padding:3px 4px;font-weight:600;">${t('detail.ruleProto')}</th>
            <th style="padding:3px 4px;font-weight:600;">${t('detail.rulePorts')}</th>
            <th style="padding:3px 4px;font-weight:600;">${t('detail.ruleSource')}</th>
            <th style="padding:3px 4px;font-weight:600;">${t('detail.ruleTarget')}</th>
          </tr>`;
          sg.rules.forEach(r => {
            const dirLabel = r.direction === 'INGRESS' ? `<span style="color:#10b981;">\u2B07 IN</span>` : `<span style="color:#f59e0b;">\u2B06 OUT</span>`;
            let port = '\u2014';
            if (r.protocol === 'ICMP') {
              port = r.icmpType != null ? `Type ${r.icmpType}` + (r.icmpCode != null ? `/${r.icmpCode}` : '') : t('detail.ruleAll');
            } else if (r.portStart) {
              port = r.portStart === r.portEnd ? `${r.portStart}` : `${r.portStart}\u2013${r.portEnd}`;
            } else {
              port = t('detail.ruleAll');
            }
            const src = r.sourceIp ? escapeHtml(r.sourceIp) : (r.sourceMac ? `MAC: ${escapeHtml(r.sourceMac)}` : t('detail.ruleAny'));
            const tgt = r.targetIp ? escapeHtml(r.targetIp) : t('detail.ruleAny');
            html += `<tr style="border-bottom:1px solid var(--bg-tertiary);">
              <td style="padding:3px 4px;">${dirLabel}</td>
              <td style="padding:3px 4px;color:var(--text-secondary);font-weight:600;">${escapeHtml(r.protocol)}</td>
              <td style="padding:3px 4px;color:var(--text-secondary);">${port}</td>
              <td style="padding:3px 4px;color:var(--text-muted);">${src}</td>
              <td style="padding:3px 4px;color:var(--text-muted);">${tgt}</td>
            </tr>`;
          });
          html += `</table>`;
        }
      });
    }
  }

  const connected = getConnectedNodes(d);
  if (connected.length > 0) {
    html += `<div class="detail-section-title">${t('detail.connectedResources')}</div>`;
    connected.forEach(cn => {
      const ccfg = NODE_TYPES[cn.type] || {};
      html += `
        <div class="connected-item" onclick="focusNode('${escapeHtml(cn.id)}')">
          <span class="connected-dot" style="background:${ccfg.color}"></span>
          <span>${escapeHtml(cn.name)}</span>
        </div>`;
    });
  }

  content.innerHTML = html;
  panel.classList.add('open');
}

function closeDetail() {
  document.getElementById('detailPanel').classList.remove('open');
  clearHighlight();
}

function setLoadingStage(stage) {
  const stages = document.querySelectorAll('.loading-stage');
  const fill = document.getElementById('loadingBarFill');
  stages.forEach((el, i) => {
    el.classList.remove('active', 'done');
    if (i < stage) el.classList.add('done');
    else if (i === stage) el.classList.add('active');
  });
  if (fill) fill.style.width = `${((stage + 1) / stages.length) * 100}%`;
}


function resetView() {
  highlightedTypes = new Set(Object.keys(NODE_TYPES));
  d3.selectAll('.node').style('display', '');
  d3.selectAll('.link').style('display', '');
  document.querySelectorAll('.legend-item').forEach(el => el.classList.remove('dimmed'));
  clearHighlight();
  closeDetail();
  clearSearch();

  // Reset IP view
  if (ipViewActive) toggleIPView();
  // Reset Compute view
  if (computeViewActive) toggleComputeView();
  // Uncheck all highlight checkboxes and clear glow rings
  ['hlFirewall','hlFlowLogs','hlSecGroups','hlIPv6','hlFailover','hlPCC'].forEach(id => {
    const cb = document.getElementById(id);
    if (cb) cb.checked = false;
  });
  applyHighlights();
  // Close highlights overlay if open
  const hlOverlay = document.getElementById('highlightsOverlay');
  if (hlOverlay) hlOverlay.classList.remove('open');
  const hlBtn = document.getElementById('hlOverlayBtn');
  if (hlBtn) hlBtn.classList.remove('active');

  zoomFit();
}

function buildDetailProps(d) {
  const p = [];
  const data = d.data || {};

  if (d.type === 'lan') {
    p.push([t('detail.lanId'), data.lanId]);
    p.push([t('detail.public'), data.isPublic ? 'Yes' : 'No']);
    if (data.cidr) p.push([t('detail.ipv4Cidr'), data.cidr]);
    if (data.ipv6Cidr) p.push([t('detail.ipv6Cidr'), data.ipv6Cidr]);
    if (data.pcc) p.push([t('detail.crossConnect'), data.pcc]);
    if (data.ipFailover?.length) p.push([t('detail.ipFailover'), data.ipFailover.map(f => `${f.ip} (NIC: ${f.nicUuid?.substring(0,8)}...)`).join(', ')]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'server' || d.type === 'cube') {
    p.push([t('detail.type'), data.type || 'ENTERPRISE']);
    p.push([t('detail.cores'), data.cores]);
    p.push([t('detail.ram'), formatRAM(data.ram)]);
    if (data.cpuFamily) p.push([t('detail.cpu'), data.cpuFamily]);
    if (data.state) p.push([t('detail.state'), data.state]);
    if (data.vmState) p.push([t('detail.vmState'), data.vmState]);
  } else if (d.type === 'postgres') {
    if (data.version) p.push([t('detail.version'), data.version]);
    if (data.instances) p.push([t('detail.instances'), data.instances]);
    if (data.cores) p.push([t('detail.cores'), data.cores]);
    if (data.ram) p.push([t('detail.ram'), formatRAM(data.ram)]);
    if (data.storageSize) p.push([t('detail.storage'), `${data.storageSize} MB`]);
    if (data.dnsName) p.push([t('detail.dns'), data.dnsName]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'mongodb') {
    if (data.version) p.push([t('detail.version'), data.version]);
    if (data.instances) p.push([t('detail.instances'), data.instances]);
    if (data.type) p.push([t('detail.type'), data.type]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'mysql') {
    if (data.version) p.push([t('detail.version'), data.version]);
    if (data.instances) p.push([t('detail.instances'), data.instances]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'nat') {
    if (data.publicIps) p.push([t('detail.publicIps'), data.publicIps.join(', ')]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'mariadb') {
    if (data.version) p.push([t('detail.version'), data.version]);
    if (data.instances) p.push([t('detail.instances'), data.instances]);
    if (data.cores) p.push([t('detail.cores'), data.cores]);
    if (data.ram) p.push([t('detail.ram'), formatRAM(data.ram)]);
    if (data.storageSize) p.push([t('detail.storage'), `${data.storageSize} MB`]);
    if (data.dnsName) p.push([t('detail.dns'), data.dnsName]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'alb' || d.type === 'nlb') {
    if (data.listenerLan) p.push([t('detail.listenerLan'), data.listenerLan]);
    if (data.targetLan) p.push([t('detail.targetLan'), data.targetLan]);
    if (data.ips) p.push([t('detail.publicIps'), data.ips.join(', ')]);
    if (data.lbPrivateIps) p.push([t('detail.privateIps'), data.lbPrivateIps.join(', ')]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'pcc') {
    if (data.pccId) p.push([t('detail.pccId'), data.pccId]);
  } else if (d.type === 'k8s_np') {
    if (data.clusterName) p.push([t('detail.cluster'), data.clusterName]);
    if (data.k8sVersion) p.push([t('detail.k8sVersion'), data.k8sVersion]);
    if (data.nodeCount) p.push([t('detail.nodes'), data.nodeCount]);
    if (data.coresCount) p.push([t('detail.coresPerNode'), data.coresCount]);
    if (data.ramSize) p.push([t('detail.ramPerNode'), formatRAM(data.ramSize)]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'nfs') {
    if (data.size) p.push([t('detail.size'), data.size]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'vpn_wg' || d.type === 'vpn_ipsec') {
    if (data.gatewayIP) p.push([t('detail.gatewayIp'), data.gatewayIP]);
    if (data.interfaceIPv4) p.push([t('detail.ifaceIpv4'), data.interfaceIPv4]);
    if (data.interfaceIPv6) p.push([t('detail.ifaceIpv6'), data.interfaceIPv6]);
    if (data.state) p.push([t('detail.state'), data.state]);
  } else if (d.type === 'kafka') {
    if (data.version) p.push([t('detail.version'), data.version]);
    if (data.size) p.push([t('detail.size'), data.size]);
    if (data.brokerAddresses) p.push([t('detail.privateIps'), Array.isArray(data.brokerAddresses) ? data.brokerAddresses.join(', ') : data.brokerAddresses]);
    if (data.state) p.push([t('detail.state'), data.state]);
  }

  // Generic: show connection IPs for managed services
  if (data.connectionIps && data.connectionIps.length > 0) {
    p.push([t('detail.privateIps'), data.connectionIps.join(', ')]);
  }

  // DNS & CDN enrichment: show domain names pointing to this node's public IPs
  if (forwardDnsMap || reverseIpMap) {
    const nodeIps = [];
    if (d.type === 'nat') nodeIps.push(...(data.publicIps || []));
    else if (d.type === 'alb' || d.type === 'nlb') nodeIps.push(...(data.ips || []));
    else if (d.type === 'vpn_wg' || d.type === 'vpn_ipsec') { if (data.gatewayIP) nodeIps.push(data.gatewayIP); }
    else if (d.type === 'server' || d.type === 'cube') {
      (data.nics || []).forEach(nic => nodeIps.push(...(nic.ips || [])));
    }

    if (nodeIps.length > 0) {
      // Forward DNS names (A/AAAA records → this IP)
      const dnsNames = [];
      nodeIps.forEach(ip => {
        const entries = forwardDnsMap?.get(ip);
        if (entries) entries.forEach(e => {
          const label = hasCDN(e.zoneName, e.fqdn) ? `${e.fqdn} [CDN]` : e.fqdn;
          if (!dnsNames.includes(label)) dnsNames.push(label);
        });
      });
      if (dnsNames.length > 0) p.push([t('detail.dnsNames'), dnsNames.join(', ')]);

      // Reverse DNS hostnames
      const rNames = [];
      nodeIps.forEach(ip => {
        const hostname = reverseIpMap?.get(ip);
        if (hostname && !rNames.includes(hostname)) rNames.push(hostname);
      });
      if (rNames.length > 0) p.push([t('detail.reverseDns'), rNames.join(', ')]);
    }
  }

  return p.filter(([k, v]) => v !== undefined && v !== null && v !== '');
}

function getConnectedNodes(d) {
  // O(1) adjacency lookup instead of scanning all links
  if (graphData._adj) return graphData._adj.get(d.id) || [];
  return [];
}

function focusNode(nodeId) {
  const node = graphData._nodeMap ? graphData._nodeMap.get(nodeId) : graphData.nodes.find(n => n.id === nodeId);
  if (!node) return;
  showDetail(node);
  highlightNode(node);
  const svg = d3.select('#graphSvg');
  const width = document.getElementById('mainArea').clientWidth;
  const height = document.getElementById('mainArea').clientHeight;
  const transform = d3.zoomIdentity.translate(width/2 - node.x, height/2 - node.y);
  svg.transition().duration(500).call(zoomBehavior.transform, transform);
}

// ============================== TOOLTIP ==============================
function showTooltip(event, d) {
  const tt = document.getElementById('tooltip');
  const cfg = NODE_TYPES[d.type] || {};
  let detail = '';
  let nicInfo = '';
  if (d.type === 'lan') detail = d.data.isPublic ? 'Public LAN' : (d.data.cidr || 'Private LAN');
  else if (d.type === 'server' || d.type === 'cube') {
    detail = `${d.data.cores || '?'} cores, ${formatRAM(d.data.ram)}`;
    if (d.data.nics && d.data.nics.length > 0) {
      nicInfo = d.data.nics.map((n, i) =>
        `NIC${i+1}: ${escapeHtml(n.ips?.join(', ') || 'no IP')} (LAN ${escapeHtml(String(n.lanId))})`
      ).join('<br>');
    }
  }
  else if (d.data?.state) detail = d.data.state;

  tt.innerHTML = `
    <div class="tt-title">${escapeHtml(d.name)}</div>
    <div class="tt-type">${cfg.label || d.type}</div>
    ${detail ? `<div class="tt-detail">${escapeHtml(detail)}</div>` : ''}
    ${nicInfo ? `<div class="tt-nic">${nicInfo}</div>` : ''}
  `;
  tt.classList.add('visible');
  moveTooltip(event);
}

function moveTooltip(event) {
  const tt = document.getElementById('tooltip');
  tt.style.left = (event.clientX + 14) + 'px';
  tt.style.top = (event.clientY + 14) + 'px';
}

function hideTooltip() { document.getElementById('tooltip').classList.remove('visible'); }

// ============================== STATS & LEGEND ==============================
function updateStats(data) {
  // Stats are now merged into the legend — this function just updates the total count badge
  const total = data.nodes.length;
  const el = document.getElementById('totalCount');
  if (el) el.textContent = `${total} total`;
}

function updateLegend(data) {
  const typeCounts = {};
  data.nodes.forEach(n => { typeCounts[n.type] = (typeCounts[n.type] || 0) + 1; });

  const list = document.getElementById('legendList');
  list.innerHTML = '';

  Object.entries(typeCounts).sort((a, b) => b[1] - a[1]).forEach(([type, count]) => {
    const cfg = NODE_TYPES[type] || {};
    const li = document.createElement('li');
    li.className = 'legend-item';
    li.dataset.type = type;
    li.onclick = () => filterByType(type);

    // Mini SVG icon for legend
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('class', 'legend-icon');
    svg.setAttribute('viewBox', '-14 -14 28 28');
    const gEl = document.createElementNS(svgNS, 'g');
    svg.appendChild(gEl);

    // Render mini icon using D3
    const d3g = d3.select(gEl);
    const drawer = ICON_DRAW[type];
    if (drawer) {
      if (type === 'lan') {
        // Small hexagon bg
        const pts = [];
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 3) * i - Math.PI / 6;
          pts.push([11 * Math.cos(a), 11 * Math.sin(a)]);
        }
        d3g.append('polygon').attr('points', pts.map(p => p.join(',')).join(' '))
          .attr('fill', cfg.color).attr('fill-opacity', 0.15).attr('stroke', cfg.color).attr('stroke-width', 1.5);
      } else {
        d3g.append('circle').attr('r', 11).attr('fill', cfg.color).attr('fill-opacity', 0.12).attr('stroke', cfg.color).attr('stroke-width', 1.5);
      }
      drawer(d3g.append('g'), 7, cfg.color);
    } else {
      d3g.append('circle').attr('r', 8).attr('fill', cfg.color).attr('fill-opacity', 0.3);
    }

    li.appendChild(svg);
    li.insertAdjacentHTML('beforeend', `<span>${cfg.label || type}</span><span class="legend-count">${count}</span>`);
    list.appendChild(li);
  });

  document.getElementById('legendSection').style.display = '';
  highlightedTypes = new Set(Object.keys(typeCounts));
}

// ============================== TOOLBAR ACTIONS ==============================
function zoomIn() { d3.select('#graphSvg').transition().duration(300).call(zoomBehavior.scaleBy, 1.4); }
function zoomOut() { d3.select('#graphSvg').transition().duration(300).call(zoomBehavior.scaleBy, 0.7); }

function zoomFit() {
  if (graphData.nodes.length === 0) return;
  const svg = d3.select('#graphSvg');
  const width = document.getElementById('mainArea').clientWidth;
  const height = document.getElementById('mainArea').clientHeight;
  const nodeCount = graphData.nodes.length;

  // Larger padding for small graphs so nodes aren't crammed at edges
  const pad = nodeCount <= 6 ? 150 : 60;
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  graphData.nodes.forEach(n => {
    minX = Math.min(minX, n.x - pad); maxX = Math.max(maxX, n.x + pad);
    minY = Math.min(minY, n.y - pad); maxY = Math.max(maxY, n.y + pad);
  });
  const dx = maxX - minX, dy = maxY - minY;

  // For small graphs, enforce a minimum bounding box so they don't appear too zoomed out
  const minSpan = Math.max(width * 0.4, 400);
  const effDx = Math.max(dx, minSpan);
  const effDy = Math.max(dy, minSpan * 0.6);

  const scale = Math.min(0.85 * width / effDx, 0.85 * height / effDy, 2);
  const tx = width / 2 - scale * (minX + dx / 2);
  const ty = height / 2 - scale * (minY + dy / 2);
  svg.transition().duration(500).call(zoomBehavior.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

// ============================== HIGHLIGHTS ==============================
/**
 * Applies visual highlights (glow effects) to nodes based on active filter checkboxes.
 * Highlights include firewall rules, flow logs, security groups, IPv6, failover, and PCC.
 * Updates CSS glow classes on .node elements to indicate feature presence.
 */
function applyHighlights() {
  const checks = {
    firewall:  document.getElementById('hlFirewall')?.checked,
    flowlogs:  document.getElementById('hlFlowLogs')?.checked,
    secgroups: document.getElementById('hlSecGroups')?.checked,
    ipv6:      document.getElementById('hlIPv6')?.checked,
    failover:  document.getElementById('hlFailover')?.checked,
    pcc:       document.getElementById('hlPCC')?.checked,
  };
  const anyActive = Object.values(checks).some(Boolean);

  // Highlight color map
  const HL_COLORS = {
    firewall: '#10b981', flowlogs: '#11C7E6', secgroups: '#FFAA00',
    ipv6: '#3b82f6', failover: '#ef4444', pcc: '#ec4899',
  };

  // Only check node types that can actually match any active highlight
  const serverChecks = checks.firewall || checks.flowlogs || checks.secgroups;
  const lanChecks = checks.ipv6 || checks.failover || checks.pcc;

  d3.selectAll('.node').each(function(d) {
    const el = d3.select(this);
    // Remove old rings
    el.selectAll('.hl-ring').remove();

    if (!anyActive) return;

    // Skip nodes that can't match any active check (perf: avoid processing irrelevant nodes)
    const isServerType = d.type === 'server' || d.type === 'cube';
    const isLanType = d.type === 'lan';
    if (!isServerType && !isLanType) return;
    if (isServerType && !serverChecks) return;
    if (isLanType && !lanChecks) return;

    const r = (NODE_TYPES[d.type]?.radius || 28);
    const matched = [];

    if (isServerType) {
      const nics = d.data?.nics || [];
      if (checks.firewall && nics.some(n => n.firewall)) matched.push('firewall');
      if (checks.flowlogs && nics.some(n => n.flowLogsEnabled)) matched.push('flowlogs');
      // Check both server-level and NIC-level security groups
      const hasSrvSG = (d.data?.securityGroupCount || 0) > 0;
      const hasNicSG = nics.some(n => n.securityGroupCount > 0);
      if (checks.secgroups && (hasSrvSG || hasNicSG)) matched.push('secgroups');
    } else {
      if (checks.ipv6 && d.data?.ipv6Cidr) matched.push('ipv6');
      if (checks.failover && d.data?.ipFailover?.length > 0) matched.push('failover');
      if (checks.pcc && d.data?.pcc) matched.push('pcc');
    }

    if (matched.length === 0) return;

    // Draw concentric rings for each matched highlight (appended ON TOP so they're visible)
    matched.forEach((key, i) => {
      const ringR = r + 8 + i * 6;
      if (isLanType) {
        const pts = [];
        for (let j = 0; j < 6; j++) {
          const a = (Math.PI / 3) * j - Math.PI / 6;
          pts.push([ringR * Math.cos(a), ringR * Math.sin(a)]);
        }
        el.append('polygon')
          .attr('class', 'hl-ring')
          .attr('points', pts.map(p => p.join(',')).join(' '))
          .attr('stroke', HL_COLORS[key])
          .attr('stroke-dasharray', '6,3');
      } else {
        el.append('circle')
          .attr('class', 'hl-ring')
          .attr('r', ringR)
          .attr('stroke', HL_COLORS[key])
          .attr('stroke-dasharray', '6,3');
      }
    });
  });
}

// ============================== USER INFO ==============================
// Safely decodes JWT payload from authorization token. Handles base64url padding.
// Returns parsed payload object on success, null on invalid token or parse error.
function decodeJwtPayload(token) {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) {
      console.log('[VDC-Viz] Token is not JWT format (no 3 dot-separated parts)');
      return null;
    }
    // Handle base64url → base64 conversion and add padding
    let b64 = parts[1].replace(/-/g, '+').replace(/_/g, '/');
    while (b64.length % 4 !== 0) b64 += '=';
    const payload = JSON.parse(atob(b64));
    console.log('[VDC-Viz] JWT decoded fields:', Object.keys(payload));
    return payload;
  } catch (e) {
    console.warn('[VDC-Viz] JWT decode error:', e.message);
    return null;
  }
}

function showUserInfo(user) {
  if (!user) return;
  const items = [];
  
  if (user.email) {
    items.push(`<div class="account-info-item"><div class="account-info-label">${t('account.email')}</div><div class="account-info-value">${escapeHtml(user.email)}</div></div>`);
  }

  if (user.contracts && user.contracts.length > 0) {
    let contractHtml = '';
    if (user.contracts.length > 1) {
      // Multiple contracts: Create Dropdown
      contractHtml = `<select id="contractSelect" onchange="handleContractChange(this.value)" style="padding:2px 4px; height:auto; font-size:11px; margin-top:2px;">`;
      user.contracts.forEach(c => {
        const num = String(c.properties.contractNumber).replace(/[<>"&]/g, '');
        const owner = (c.properties.owner || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        const selected = num === String(currentContract) ? 'selected' : '';
        contractHtml += `<option value="${num}" ${selected}>${num} (${owner})</option>`;
      });
      contractHtml += `</select>`;
    } else {
      // Single contract: Keep as text
      const num = String(user.contracts[0].properties.contractNumber).replace(/[<>"&]/g, '');
      contractHtml = `<div class="account-info-value">${num}</div>`;
    }
    items.push(`<div class="account-info-item"><div class="account-info-label">${t('account.contract')}</div>${contractHtml}</div>`);
  }
  
  document.getElementById('accountInfo').innerHTML = items.join('');
  document.getElementById('accountSection').style.display = '';
}

function toggleLabels() {
  showLabels = !showLabels;
  d3.selectAll('.node-label, .node-sublabel, .link-label, .link-label-bg').style('display', showLabels ? '' : 'none');
}

let ipViewActive = false;
function toggleIPView() {
  ipViewActive = !ipViewActive;
  const svg = document.getElementById('graphSvg');
  const btn = document.getElementById('ipViewBtn');
  svg.classList.toggle('ip-view-active', ipViewActive);
  btn.classList.toggle('active', ipViewActive);

  if (ipViewActive) {
    // Deactivate Compute View if active
    if (computeViewActive) toggleComputeView();
    // Ensure node IP labels are visible (link labels hidden via CSS to avoid duplication)
    d3.selectAll('.node-ip-label').style('display', '');
    // Move IP labels closer to nodes (since name/spec labels are hidden)
    d3.selectAll('.node-ip-label:not(.ip-detail-label)').each(function() {
      const el = d3.select(this);
      const d = d3.select(this.parentNode).datum();
      if (!d) return;
      const radius = NODE_TYPES[d.type]?.radius || 28;
      const origDy = radius + 42;
      if (!el.attr('data-orig-dy')) el.attr('data-orig-dy', origDy);
      el.attr('dy', radius + 14);
    });
    // All links stay visible — only text labels are dimmed via CSS
    enrichIPLabels();
  } else {
    // Restore original IP label positions
    d3.selectAll('.node-ip-label:not(.ip-detail-label)').each(function() {
      const el = d3.select(this);
      const origDy = el.attr('data-orig-dy');
      if (origDy) el.attr('dy', origDy);
    });
    // Restore original IP labels (strip DNS enrichment)
    resetIPLabels();
  }
}

let computeViewActive = false;
function toggleComputeView() {
  computeViewActive = !computeViewActive;
  const svg = document.getElementById('graphSvg');
  const btn = document.getElementById('computeViewBtn');
  svg.classList.toggle('compute-view-active', computeViewActive);
  btn.classList.toggle('active', computeViewActive);

  if (computeViewActive) {
    // Deactivate IP View if active
    if (ipViewActive) toggleIPView();
    // Enrich labels with detailed compute info (hides originals, appends new text elements)
    enrichComputeLabels();
  } else {
    // Restore original compute sublabels
    resetComputeLabels();
  }
}

function enrichComputeLabels() {
  // Strategy: hide the original sublabel and append a NEW <text> element
  // with absolute y positioning on each tspan. This avoids dy/tspan
  // interaction issues that cause labels to render inside the node circle.
  d3.selectAll('.node-compute-label').each(function() {
    const el = d3.select(this);
    const parent = d3.select(this.parentNode);

    // Save original text for reset
    if (!el.attr('data-original-compute')) {
      el.attr('data-original-compute', el.text());
    }

    // Get node data
    const nodeData = parent.datum();
    if (!nodeData || (nodeData.type !== 'server' && nodeData.type !== 'cube')) return;

    // Hide the original sublabel (display:none survives CSS opacity overrides)
    el.style('display', 'none');

    // Remove any previously created compute-detail label
    parent.selectAll('.compute-detail-label').remove();

    const radius = NODE_TYPES[nodeData.type]?.radius || 28;
    const vmType = (nodeData.data.type || '').toUpperCase();
    const cores = nodeData.data.cores || '?';
    const ram = formatRAM(nodeData.data.ram);
    const cpuFamily = nodeData.data.cpuFamily || '';

    const typeLabel = vmType === 'GPU' ? 'GPU' : vmType === 'CUBE' ? 'CUBE' : vmType === 'VCPU' ? 'vCPU' : vmType === 'ENTERPRISE' ? 'DediCore' : vmType || '?';

    // Determine color class
    let colorClass = 'compute-other';
    if (vmType === 'GPU') colorClass = 'compute-gpu';
    else if (vmType === 'CUBE') colorClass = 'compute-cube';
    else if (vmType === 'VCPU') colorClass = 'compute-vcpu';
    else if (vmType === 'ENTERPRISE') colorClass = 'compute-enterprise';

    // Shorten CPU family: INTEL_SKYLAKE -> Skylake, AMD_EPYC -> Epyc
    let cpuShort = '';
    if (cpuFamily) {
      cpuShort = cpuFamily.replace(/^(INTEL|AMD)_/i, '').replace(/_/g, ' ')
        .split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
    }

    // Create a brand-new <text> element with absolute y positions on tspans
    // Line 1: Type + CPU family (e.g. "DediCore · Skylake")
    // Line 2: Cores + RAM (e.g. "3C · 4 GB")
    const baseY = radius + 30;   // snug below node name label (which sits at radius+16)
    const lineGap = 11;          // tight vertical gap between lines

    const newText = parent.append('text')
      .attr('class', `compute-detail-label node-compute-label ${colorClass}`)
      .attr('text-anchor', 'middle')
      .style('pointer-events', 'none')
      .style('font-weight', '600');

    // Line 1: type + CPU on same line
    const line1 = cpuShort ? `${typeLabel} \u00b7 ${cpuShort}` : typeLabel;
    newText.append('tspan')
      .attr('class', 'compute-line-type')
      .attr('x', 0).attr('y', baseY)
      .text(line1);
    // Line 2: cores + RAM
    newText.append('tspan')
      .attr('class', 'compute-line-spec')
      .attr('x', 0).attr('y', baseY + lineGap)
      .text(`${cores}C \u00b7 ${ram}`);
  });
}

function resetComputeLabels() {
  // Remove the appended compute-detail labels
  d3.selectAll('.compute-detail-label').remove();
  // Show the original sublabels again
  d3.selectAll('.node-compute-label').each(function() {
    d3.select(this).style('display', null);
  });
}

function resetIPLabels() {
  // Remove appended ip-detail labels
  d3.selectAll('.ip-detail-label').remove();
  // Show originals and clean up link label tspans
  d3.selectAll('.node-ip-label').each(function() {
    d3.select(this).style('display', null);
  });
  d3.selectAll('.link-label').each(function() {
    const el = d3.select(this);
    const original = el.attr('data-original-ip');
    if (original) {
      el.selectAll('tspan').remove();
      el.text(original);
    }
  });
}

// Check if a domain has CDN coverage: matches if CDN domain equals the zone name,
// the FQDN itself, or the FQDN is a subdomain of a CDN domain (e.g., CDN on
// "example.com" covers "www.example.com")
function hasCDN(zoneName, fqdn) {
  if (!cdnDomainSet || cdnDomainSet.size === 0) return false;
  if (cdnDomainSet.has(zoneName)) return true;
  if (fqdn && cdnDomainSet.has(fqdn)) return true;
  // Check if FQDN is a subdomain of any CDN domain
  if (fqdn) {
    for (const cdnDomain of cdnDomainSet) {
      if (fqdn.endsWith('.' + cdnDomain) || fqdn === cdnDomain) return true;
    }
  }
  return false;
}

function enrichIPLabels() {
  if (!reverseIpMap && !forwardDnsMap) return;

  // Helper: collect DNS entries for an IP
  function dnsForIp(ip) {
    const dns = [];
    const rHostname = reverseIpMap?.get(ip);
    if (rHostname) dns.push({ name: rHostname, cdn: false });
    const fEntries = forwardDnsMap?.get(ip);
    if (fEntries) {
      fEntries.forEach(e => {
        const isCdn = hasCDN(e.zoneName, e.fqdn);
        const label = e.fqdn;
        if (!dns.some(d => d.name === label) && label !== rHostname) {
          dns.push({ name: label, cdn: isCdn });
        }
      });
    }
    return dns;
  }

  // Enrich node IP sublabels — create new text elements with absolute y positioning
  d3.selectAll('.node-ip-label').each(function() {
    const el = d3.select(this);
    const parent = d3.select(this.parentNode);
    const original = el.attr('data-original-ip') || el.text();
    if (!el.attr('data-original-ip')) el.attr('data-original-ip', original);
    if (!original || !original.trim()) return;

    // Parse IPs (could be comma-separated list)
    const ips = original.split(',').map(s => s.trim()).filter(Boolean);
    const allDns = [];
    ips.forEach(raw => {
      const ip = raw.split('/')[0].trim();
      dnsForIp(ip).forEach(d => {
        if (!allDns.some(x => x.name === d.name)) allDns.push(d);
      });
    });

    if (allDns.length === 0) return;

    // Hide original and remove any previous detail label
    el.style('display', 'none');
    parent.selectAll('.ip-detail-label').remove();

    // Position: snug below node name (radius+16) with comfortable spacing
    const nodeData = parent.datum();
    const radius = NODE_TYPES[nodeData?.type]?.radius || 28;
    const baseY = radius + 14;   // IP address line — snug just below node circle
    const lineGap = 14;          // gap between DNS lines

    const newText = parent.append('text')
      .attr('class', 'ip-detail-label node-ip-label')
      .attr('text-anchor', 'middle')
      .style('pointer-events', 'none')
      .style('font-weight', '600');

    // Line 1: IP address(es)
    newText.append('tspan')
      .attr('class', 'ip-line-addr')
      .attr('x', 0).attr('y', baseY)
      .text(truncate(original, 30));

    // Lines 2+: DNS hostnames
    allDns.slice(0, 3).forEach((d, i) => {
      const cls = d.cdn ? 'ip-line-cdn' : 'ip-line-dns';
      const label = d.cdn ? `${d.name} [CDN]` : d.name;
      newText.append('tspan')
        .attr('class', cls)
        .attr('x', 0).attr('y', baseY + lineGap * (i + 1))
        .text(truncate(label, 32));
    });
    if (allDns.length > 3) {
      newText.append('tspan')
        .attr('class', 'ip-line-dns')
        .attr('x', 0).attr('y', baseY + lineGap * 4)
        .text(`+${allDns.length - 3} more`);
    }
  });

  // Enrich link labels (IPs on connections) — multiline too
  d3.selectAll('.link-label').each(function() {
    const el = d3.select(this);
    const original = el.attr('data-original-ip') || el.text();
    if (!original || !original.trim()) return;
    if (!el.attr('data-original-ip')) el.attr('data-original-ip', original);

    const ip = original.split('/')[0].trim();
    const dns = dnsForIp(ip);
    if (dns.length === 0) return;

    el.text(null);
    el.append('tspan')
      .attr('class', 'ip-line-addr')
      .attr('dy', '0')
      .text(original);
    el.append('tspan')
      .attr('class', 'ip-line-dns')
      .attr('dy', '1.15em')
      .text(truncate(dns[0].name, 28));
  });
}

function toggleHighlightsOverlay() {
  const overlay = document.getElementById('highlightsOverlay');
  const btn = document.getElementById('hlOverlayBtn');
  const isOpen = overlay.classList.toggle('open');
  btn.classList.toggle('active', isOpen);
}

function closeHighlightsOverlay() {
  const overlay = document.getElementById('highlightsOverlay');
  const btn = document.getElementById('hlOverlayBtn');
  if (overlay) overlay.classList.remove('open');
  if (btn) btn.classList.remove('active');
}

// Helper: returns IP text for a given node (used by IP View mode)
function getNodeIPText(d) {
  if (d.type === 'server' || d.type === 'cube') {
    return (d.data.nics || []).flatMap(n => n.ips || []).length > 0;
  }
  if (d.type === 'nat') return (d.data.publicIps || []).length > 0;
  if (d.type === 'alb' || d.type === 'nlb') return (d.data.ips || []).length > 0 || (d.data.lbPrivateIps || []).length > 0;
  if (d.type === 'vpn_wg' || d.type === 'vpn_ipsec') return !!d.data.gatewayIP;
  if (d.type === 'lan') return !!(d.data.cidr || d.data.ipv6Cidr);
  if (d.type === 'kafka') return (d.data.brokerAddresses || []).length > 0;
  if (d.type === 'internet') return true; // always relevant in IP view
  // Managed services with connection IPs (DBaaS, NFS, K8s)
  if (d.data.connectionIps && d.data.connectionIps.length > 0) return true;
  return false;
}

function exportPNG() {
  const svgEl = document.getElementById('graphSvg');
  const bbox = svgEl.getBoundingClientRect();

  // Clone SVG so we can inject inline styles without affecting the live DOM
  const clone = svgEl.cloneNode(true);

  // Set explicit width/height on the clone for proper rendering
  clone.setAttribute('width', bbox.width);
  clone.setAttribute('height', bbox.height);
  clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  // Resolve CSS variable values from computed styles
  const cs = getComputedStyle(document.documentElement);
  const textPrimary = cs.getPropertyValue('--text-primary').trim() || '#f1f5f9';
  const textSecondary = cs.getPropertyValue('--text-secondary').trim() || '#a0c4e8';
  const bgPrimary = cs.getPropertyValue('--bg-primary').trim() || '#001B41';

  // Inject a <style> block with resolved (non-variable) CSS into the SVG clone
  const styleEl = document.createElementNS('http://www.w3.org/2000/svg', 'style');
  styleEl.textContent = `
    .node-label { font-family: Inter, sans-serif; font-size: 11px; fill: ${textPrimary}; text-anchor: middle; font-weight: 600; }
    .node-sublabel { font-family: Inter, sans-serif; font-size: 9px; fill: ${textSecondary}; text-anchor: middle; }
    .link { stroke-width: 2; stroke-opacity: 0.35; }
    .link-label { font-family: Inter, sans-serif; font-size: 10px; fill: ${textSecondary}; text-anchor: middle; font-weight: 500; }
    .link-label-bg { fill: ${bgPrimary}; fill-opacity: 0.7; }
    .node.dimmed { opacity: 0.12; }
    .link.dimmed { stroke-opacity: 0.04; }
    .link.highlighted { stroke-opacity: 0.9; stroke-width: 3; }
    .hl-ring { fill: none; stroke-width: 3; stroke-dasharray: 6,3; }
  `;
  clone.insertBefore(styleEl, clone.firstChild);

  const serializer = new XMLSerializer();
  const svgStr = serializer.serializeToString(clone);

  const canvas = document.createElement('canvas');
  canvas.width = bbox.width * 2; canvas.height = bbox.height * 2;
  const ctx = canvas.getContext('2d');
  ctx.scale(2, 2);
  ctx.fillStyle = bgPrimary;
  ctx.fillRect(0, 0, bbox.width, bbox.height);

  const img = new Image();
  img.onload = () => {
    ctx.drawImage(img, 0, 0, bbox.width, bbox.height);
    const a = document.createElement('a');
    a.download = `vdc-${currentDC?.properties?.name || 'export'}.png`;
    a.href = canvas.toDataURL('image/png');
    a.click();
    toast(t('toast.pngExported'), 'success');
    closeExportMenu();
  };
  img.onerror = () => toast(t('toast.pngFailed'), 'error');
  // Unicode-safe Base64 encode (replaces deprecated unescape)
  const utf8Bytes = new TextEncoder().encode(svgStr);
  const binStr = Array.from(utf8Bytes, b => String.fromCharCode(b)).join('');
  img.src = 'data:image/svg+xml;base64,' + btoa(binStr);
}

function exportSVG() {
  const svgEl = document.getElementById('graphSvg');
  const bbox = svgEl.getBoundingClientRect();
  const clone = svgEl.cloneNode(true);
  clone.setAttribute('width', bbox.width);
  clone.setAttribute('height', bbox.height);
  clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  const cs = getComputedStyle(document.documentElement);
  const styleEl = document.createElementNS('http://www.w3.org/2000/svg', 'style');
  styleEl.textContent = `
    .node-label { font-family: Inter, sans-serif; font-size: 11px; fill: ${cs.getPropertyValue('--text-primary').trim()}; text-anchor: middle; font-weight: 600; }
    .node-sublabel { font-family: Inter, sans-serif; font-size: 9px; fill: ${cs.getPropertyValue('--text-secondary').trim()}; text-anchor: middle; }
    .link { stroke-width: 2; stroke-opacity: 0.35; }
    .link-label { font-family: Inter, sans-serif; font-size: 10px; fill: ${cs.getPropertyValue('--text-secondary').trim()}; text-anchor: middle; font-weight: 500; }
    .link-label-bg { fill: ${cs.getPropertyValue('--bg-primary').trim()}; fill-opacity: 0.7; }
    svg { background: ${cs.getPropertyValue('--bg-primary').trim()}; }
  `;
  clone.insertBefore(styleEl, clone.firstChild);
  const svgStr = new XMLSerializer().serializeToString(clone);
  const blob = new Blob([svgStr], { type: 'image/svg+xml' });
  const a = document.createElement('a');
  a.download = `vdc-${currentDC?.properties?.name || 'export'}.svg`;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  toast(t('toast.svgExported'), 'success');
  closeExportMenu();
}

function exportJSON() {
  if (!graphData || !graphData.nodes) { toast(t('toast.noData'), 'warning'); return; }
  const exportData = {
    meta: {
      exported: new Date().toISOString(),
      tool: 'IONOS Cloud Network Visualizer',
      vdc: currentDC?.properties?.name || '',
      location: currentDC?.properties?.location || '',
    },
    nodes: graphData.nodes.map(n => ({
      id: n.id, type: n.type, name: n.name,
      data: n.data || {},
    })),
    links: graphData.links.map(l => ({
      source: typeof l.source === 'object' ? l.source.id : l.source,
      target: typeof l.target === 'object' ? l.target.id : l.target,
      label: l.label || '', linkType: l.linkType || '',
    })),
    stats: {
      totalNodes: graphData.nodes.length,
      totalLinks: graphData.links.length,
      byType: {},
    },
  };
  graphData.nodes.forEach(n => { exportData.stats.byType[n.type] = (exportData.stats.byType[n.type] || 0) + 1; });
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.download = `vdc-topology-${currentDC?.properties?.name || 'export'}.json`;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  toast(t('toast.jsonExported'), 'success');
  closeExportMenu();
}

// ============================== TABLE VIEW ==============================
let tableRows = [];
let activeTableFilters = new Set();
let tableSortCol = null;
let tableSortDir = 'asc';
let tableFilterTimeout = null;

function buildTableRow(n) {
  const data = n.data || {};
  const cfg = NODE_TYPES[n.type] || {};
  const typeLabel = cfg.label || n.type;
  const state = data.state || data.vmState || '';

  // Build type-specific details summary
  let details = '';
  if (n.type === 'server' || n.type === 'cube') {
    const vmType = (data.type || 'ENTERPRISE').toUpperCase();
    const tl = vmType === 'GPU' ? 'GPU' : vmType === 'CUBE' ? 'CUBE' : vmType === 'VCPU' ? 'vCPU' : vmType === 'ENTERPRISE' ? 'DediCore' : vmType;
    const parts = [tl];
    if (data.cores) parts.push(`${data.cores}C`);
    if (data.ram) parts.push(formatRAM(data.ram));
    details = parts.join(' \u00b7 ');
  } else if (n.type === 'postgres' || n.type === 'mariadb' || n.type === 'mysql') {
    const parts = [];
    if (data.version) parts.push(`v${data.version}`);
    if (data.instances) parts.push(`${data.instances} inst`);
    if (data.cores) parts.push(`${data.cores}C`);
    if (data.ram) parts.push(formatRAM(data.ram));
    details = parts.join(' \u00b7 ');
  } else if (n.type === 'mongodb') {
    const parts = [];
    if (data.version) parts.push(`v${data.version}`);
    if (data.type) parts.push(data.type);
    if (data.instances) parts.push(`${data.instances} inst`);
    details = parts.join(' \u00b7 ');
  } else if (n.type === 'nat') {
    details = (data.publicIps || []).join(', ');
  } else if (n.type === 'alb' || n.type === 'nlb') {
    const parts = [];
    if (data.listenerLan) parts.push(`Listener LAN ${data.listenerLan}`);
    if (data.targetLan) parts.push(`Target LAN ${data.targetLan}`);
    details = parts.join(' \u2192 ');
  } else if (n.type === 'k8s_np') {
    const parts = [];
    if (data.k8sVersion) parts.push(`v${data.k8sVersion}`);
    if (data.nodeCount) parts.push(`${data.nodeCount} nodes`);
    if (data.coresCount) parts.push(`${data.coresCount}C`);
    details = parts.join(' \u00b7 ');
  } else if (n.type === 'vpn_wg' || n.type === 'vpn_ipsec') {
    details = data.gatewayIP || data.interfaceIPv4 || '';
  } else if (n.type === 'nfs') {
    details = data.size || '';
  } else if (n.type === 'kafka') {
    const parts = [];
    if (data.version) parts.push(`v${data.version}`);
    if (data.size) parts.push(data.size);
    details = parts.join(' \u00b7 ');
  } else if (n.type === 'lan') {
    details = data.isPublic ? 'Public' : (data.cidr || 'Private');
  } else if (n.type === 'pcc') {
    details = data.pccId || '';
  }

  // Collect all IPs
  const ips = [];
  if (data.nics) data.nics.forEach(nic => { if (nic.ips) ips.push(...nic.ips); });
  if (data.publicIps) ips.push(...data.publicIps);
  if (data.ips) ips.push(...data.ips);
  if (data.lbPrivateIps) ips.push(...data.lbPrivateIps);
  if (data.gatewayIP) ips.push(data.gatewayIP);
  if (data.interfaceIPv4) ips.push(data.interfaceIPv4);
  if (data.interfaceIPv6) ips.push(data.interfaceIPv6);
  if (data.brokerAddresses) ips.push(...(Array.isArray(data.brokerAddresses) ? data.brokerAddresses : []));
  if (data.connectionIps) ips.push(...data.connectionIps);

  return {
    id: n.id,
    name: n.name || n.id,
    typeLabel,
    typeKey: n.type,
    typeColor: cfg.color || '#6b7280',
    state,
    details,
    ips: [...new Set(ips)].join(', '),
  };
}

function openTableView() {
  if (!graphData || !graphData.nodes || !graphData.nodes.length) {
    toast(t('toast.noDisplay'), 'warning');
    return;
  }
  tableRows = graphData.nodes
    .filter(n => n.type !== 'internet')
    .map(buildTableRow);

  activeTableFilters = new Set(tableRows.map(r => r.typeKey));
  tableSortCol = 'name';
  tableSortDir = 'asc';

  const searchEl = document.getElementById('tableSearch');
  if (searchEl) searchEl.value = '';

  renderTypeFilters();
  renderTableView();
  document.getElementById('tableOverlay').style.display = '';
  setTimeout(() => { const s = document.getElementById('tableSearch'); if (s) s.focus(); }, 100);
}

function closeTableView() {
  document.getElementById('tableOverlay').style.display = 'none';
}

function renderTypeFilters() {
  const container = document.getElementById('tableFilters');
  if (!container) return;

  // Count per type
  const counts = {};
  tableRows.forEach(r => { counts[r.typeKey] = (counts[r.typeKey] || 0) + 1; });

  // Sort by count descending
  const types = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);

  let html = '';
  types.forEach(t => {
    const cfg = NODE_TYPES[t] || {};
    const label = cfg.label || t;
    const color = cfg.color || '#6b7280';
    const active = activeTableFilters.has(t) ? ' active' : '';
    html += `<span class="table-filter-pill${active}" data-type="${t}" onclick="toggleTableFilter('${t}')"><span class="table-filter-dot" style="background:${color}"></span>${escapeHtml(label)} (${counts[t]})</span>`;
  });
  container.innerHTML = html;
}

function toggleTableFilter(typeKey) {
  if (activeTableFilters.has(typeKey)) {
    activeTableFilters.delete(typeKey);
  } else {
    activeTableFilters.add(typeKey);
  }
  renderTypeFilters();
  renderTableView();
}

function getFilteredSortedRows() {
  const searchVal = (document.getElementById('tableSearch')?.value || '').toLowerCase();

  let rows = tableRows.filter(r => activeTableFilters.has(r.typeKey));

  if (searchVal) {
    rows = rows.filter(r =>
      r.name.toLowerCase().includes(searchVal) ||
      r.typeLabel.toLowerCase().includes(searchVal) ||
      r.state.toLowerCase().includes(searchVal) ||
      r.details.toLowerCase().includes(searchVal) ||
      r.ips.toLowerCase().includes(searchVal)
    );
  }

  if (tableSortCol) {
    const dir = tableSortDir === 'asc' ? 1 : -1;
    rows.sort((a, b) => {
      const av = (a[tableSortCol] || '').toLowerCase();
      const bv = (b[tableSortCol] || '').toLowerCase();
      if (av < bv) return -1 * dir;
      if (av > bv) return 1 * dir;
      return 0;
    });
  }

  return rows;
}

function renderTableView() {
  const thead = document.getElementById('resourceTableHead');
  const tbody = document.getElementById('resourceTableBody');
  const footer = document.getElementById('tableFooter');
  if (!thead || !tbody) return;

  const cols = [
    { key: 'name', label: t('table.name'), sortable: true },
    { key: 'typeLabel', label: t('table.type'), sortable: true },
    { key: 'state', label: t('table.state'), sortable: true },
    { key: 'details', label: t('table.details'), sortable: false },
    { key: 'ips', label: t('table.ips'), sortable: false },
  ];

  // Render header
  let headHtml = '<tr>';
  cols.forEach(col => {
    const isSorted = tableSortCol === col.key;
    let cls = col.sortable ? ' class="sortable' : ' class="';
    if (isSorted) cls += ` sort-${tableSortDir}`;
    cls += '"';
    const arrow = col.sortable ? `<span class="sort-arrow">${isSorted ? (tableSortDir === 'asc' ? '\u25B2' : '\u25BC') : '\u25B8'}</span>` : '';
    const click = col.sortable ? ` onclick="sortTable('${col.key}')"` : '';
    headHtml += `<th${cls}${click}>${col.label}${arrow}</th>`;
  });
  headHtml += '</tr>';
  thead.innerHTML = headHtml;

  // Get filtered and sorted rows
  const rows = getFilteredSortedRows();

  if (rows.length === 0) {
    tbody.innerHTML = `<tr><td colspan="5" class="table-empty">${t('table.noMatch')}</td></tr>`;
  } else {
    let bodyHtml = '';
    rows.forEach(r => {
      const stateClass = r.state ? ` ${r.state.toLowerCase()}` : '';
      bodyHtml += `<tr onclick="tableRowClick('${escapeHtml(r.id)}')">`;
      bodyHtml += `<td><strong>${escapeHtml(r.name)}</strong></td>`;
      bodyHtml += `<td><span class="table-type-badge"><span class="table-type-dot" style="background:${r.typeColor}"></span>${escapeHtml(r.typeLabel)}</span></td>`;
      bodyHtml += `<td><span class="table-state${stateClass}">${escapeHtml(r.state)}</span></td>`;
      bodyHtml += `<td>${escapeHtml(r.details)}</td>`;
      bodyHtml += `<td class="table-ips">${escapeHtml(r.ips)}</td>`;
      bodyHtml += '</tr>';
    });
    tbody.innerHTML = bodyHtml;
  }

  // Footer
  if (footer) {
    footer.innerHTML = t('table.showing', {count: rows.length, total: tableRows.length});
  }
}

function sortTable(colKey) {
  if (tableSortCol === colKey) {
    tableSortDir = tableSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    tableSortCol = colKey;
    tableSortDir = 'asc';
  }
  renderTableView();
}

function filterTable() {
  clearTimeout(tableFilterTimeout);
  tableFilterTimeout = setTimeout(renderTableView, 200);
}

function tableRowClick(nodeId) {
  closeTableView();
  focusNode(nodeId);
}

function exportTableCSV() {
  const rows = getFilteredSortedRows();
  if (rows.length === 0) { toast(t('toast.noRows'), 'warning'); return; }

  const csvEscape = (val) => {
    const s = String(val || '');
    if (s.includes(',') || s.includes('"') || s.includes('\n')) {
      return '"' + s.replace(/"/g, '""') + '"';
    }
    return s;
  };

  const header = ['Name', 'Type', 'State', 'Details', 'IPs'];
  const lines = [header.join(',')];
  rows.forEach(r => {
    lines.push([
      csvEscape(r.name),
      csvEscape(r.typeLabel),
      csvEscape(r.state),
      csvEscape(r.details),
      csvEscape(r.ips),
    ].join(','));
  });

  const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.download = `vdc-resources-${currentDC?.properties?.name || 'export'}.csv`;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  toast(t('toast.csvExported', {count: rows.length}), 'success');
}

// ============================== EXPORT DROPDOWN ==============================
function toggleExportMenu() {
  closeFlowLogMenu();
  const dd = document.getElementById('exportDropdown');
  const btn = document.getElementById('exportMenuBtn');
  const isOpen = dd.classList.toggle('open');
  btn.classList.toggle('active', isOpen);
  if (isOpen) {
    setTimeout(() => document.addEventListener('click', _closeExportOutside), 0);
  } else {
    document.removeEventListener('click', _closeExportOutside);
  }
}

function closeExportMenu() {
  const dd = document.getElementById('exportDropdown');
  const btn = document.getElementById('exportMenuBtn');
  if (dd) dd.classList.remove('open');
  if (btn) btn.classList.remove('active');
  document.removeEventListener('click', _closeExportOutside);
}

function _closeExportOutside(e) {
  if (!document.querySelector('.export-dropdown-wrapper')?.contains(e.target)) {
    closeExportMenu();
  }
}

// ============================== FLOW LOG DROPDOWN ==============================
function toggleFlowLogMenu() {
  closeExportMenu();
  const dd = document.getElementById('flowlogDropdown');
  const btn = document.getElementById('flowlogMenuBtn');
  const isOpen = dd.classList.toggle('open');
  btn.classList.toggle('active', isOpen);
  if (isOpen) {
    setTimeout(() => document.addEventListener('click', _closeFlowLogOutside), 0);
  } else {
    document.removeEventListener('click', _closeFlowLogOutside);
  }
}

function closeFlowLogMenu() {
  const dd = document.getElementById('flowlogDropdown');
  const btn = document.getElementById('flowlogMenuBtn');
  if (dd) dd.classList.remove('open');
  if (btn) btn.classList.remove('active');
  document.removeEventListener('click', _closeFlowLogOutside);
}

function _closeFlowLogOutside(e) {
  if (!document.querySelector('.flowlog-dropdown-wrapper')?.contains(e.target)) {
    closeFlowLogMenu();
  }
}

// ── CSV Export (all resources, unfiltered) ──
function exportCSV() {
  if (!graphData || !graphData.nodes || !graphData.nodes.length) {
    toast(t('toast.noData'), 'warning'); closeExportMenu(); return;
  }
  const rows = graphData.nodes.filter(n => n.type !== 'internet').map(buildTableRow);

  const csvEscape = (val) => {
    const s = String(val || '');
    if (s.includes(',') || s.includes('"') || s.includes('\n')) return '"' + s.replace(/"/g, '""') + '"';
    return s;
  };

  const header = ['Name', 'Type', 'State', 'Details', 'IPs'];
  const lines = [header.join(',')];
  rows.forEach(r => {
    lines.push([csvEscape(r.name), csvEscape(r.typeLabel), csvEscape(r.state), csvEscape(r.details), csvEscape(r.ips)].join(','));
  });

  const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
  const a = document.createElement('a');
  a.download = `vdc-resources-${currentDC?.properties?.name || 'export'}.csv`;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  toast(t('toast.csvExported', {count: rows.length}), 'success');
  closeExportMenu();
}

// ── XLSX Export (multi-sheet workbook) ──
function exportXLSX() {
  if (!graphData || !graphData.nodes || !graphData.nodes.length) {
    toast(t('toast.noData'), 'warning'); closeExportMenu(); return;
  }
  if (typeof XLSX === 'undefined') {
    toast(t('toast.xlsxNotLoaded'), 'error'); closeExportMenu(); return;
  }

  const rows = graphData.nodes.filter(n => n.type !== 'internet').map(buildTableRow);
  const dcName = currentDC?.properties?.name || 'export';
  const dcLocation = currentDC?.properties?.location || '';
  const wb = XLSX.utils.book_new();

  // Sheet 1: Resources
  const resData = [['Name', 'Type', 'State', 'Details', 'IPs'], ...rows.map(r => [r.name, r.typeLabel, r.state, r.details, r.ips])];
  const resSheet = XLSX.utils.aoa_to_sheet(resData);
  resSheet['!cols'] = [{ wch: 28 }, { wch: 16 }, { wch: 14 }, { wch: 32 }, { wch: 24 }];
  XLSX.utils.book_append_sheet(wb, resSheet, 'Resources');

  // Sheet 2: Connections
  const nodeMap = graphData._nodeMap || new Map(graphData.nodes.map(n => [n.id, n]));
  const linkData = [['Source', 'Target', 'Link Type', 'Label']];
  (graphData.links || []).forEach(l => {
    const srcId = typeof l.source === 'object' ? l.source.id : l.source;
    const tgtId = typeof l.target === 'object' ? l.target.id : l.target;
    const srcName = nodeMap.get(srcId)?.name || srcId;
    const tgtName = nodeMap.get(tgtId)?.name || tgtId;
    const linkCfg = LINK_TYPES[l.linkType] || {};
    linkData.push([srcName, tgtName, linkCfg.label || l.linkType || '', l.label || '']);
  });
  const linkSheet = XLSX.utils.aoa_to_sheet(linkData);
  linkSheet['!cols'] = [{ wch: 28 }, { wch: 28 }, { wch: 18 }, { wch: 22 }];
  XLSX.utils.book_append_sheet(wb, linkSheet, 'Connections');

  // Sheet 3: Summary
  const typeCounts = {};
  rows.forEach(r => { typeCounts[r.typeLabel] = (typeCounts[r.typeLabel] || 0) + 1; });
  const sumData = [
    ['Metric', 'Value'],
    ['VDC Name', dcName],
    ['Location', dcLocation],
    ['Export Date', new Date().toISOString()],
    ['Total Resources', rows.length],
    ['Total Connections', graphData.links?.length || 0],
    ['', ''],
    ['Resource Type', 'Count'],
    ...Object.entries(typeCounts).sort((a, b) => b[1] - a[1]).map(([t, c]) => [t, c]),
  ];
  const sumSheet = XLSX.utils.aoa_to_sheet(sumData);
  sumSheet['!cols'] = [{ wch: 22 }, { wch: 16 }];
  XLSX.utils.book_append_sheet(wb, sumSheet, 'Summary');

  XLSX.writeFile(wb, `vdc-${dcName}.xlsx`);
  toast(t('toast.xlsxExported'), 'success');
  closeExportMenu();
}

// ── PDF Export (diagram + resource table report) ──
function exportPDF() {
  if (!graphData || !graphData.nodes || !graphData.nodes.length) {
    toast(t('toast.noData'), 'warning'); closeExportMenu(); return;
  }
  if (typeof jspdf === 'undefined') {
    toast(t('toast.pdfNotLoaded'), 'error'); closeExportMenu(); return;
  }

  const dcName = currentDC?.properties?.name || 'export';
  const dcLocation = currentDC?.properties?.location || '';
  const rows = graphData.nodes.filter(n => n.type !== 'internet').map(buildTableRow);

  // Render SVG to canvas (same approach as exportPNG)
  const svgEl = document.getElementById('graphSvg');
  const bbox = svgEl.getBoundingClientRect();
  const clone = svgEl.cloneNode(true);
  clone.setAttribute('width', bbox.width);
  clone.setAttribute('height', bbox.height);
  clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

  const cs = getComputedStyle(document.documentElement);
  const bgPrimary = cs.getPropertyValue('--bg-primary').trim() || '#001B41';
  const textPrimary = cs.getPropertyValue('--text-primary').trim() || '#f1f5f9';
  const textSecondary = cs.getPropertyValue('--text-secondary').trim() || '#a0c4e8';

  const styleEl = document.createElementNS('http://www.w3.org/2000/svg', 'style');
  styleEl.textContent = `
    .node-label { font-family: Inter, sans-serif; font-size: 11px; fill: ${textPrimary}; text-anchor: middle; font-weight: 600; }
    .node-sublabel { font-family: Inter, sans-serif; font-size: 9px; fill: ${textSecondary}; text-anchor: middle; }
    .link { stroke-width: 2; stroke-opacity: 0.35; }
    .link-label { font-family: Inter, sans-serif; font-size: 10px; fill: ${textSecondary}; text-anchor: middle; font-weight: 500; }
    .link-label-bg { fill: ${bgPrimary}; fill-opacity: 0.7; }
    .node.dimmed { opacity: 0.12; }
    .link.dimmed { stroke-opacity: 0.04; }
  `;
  clone.insertBefore(styleEl, clone.firstChild);

  const svgStr = new XMLSerializer().serializeToString(clone);
  const canvas = document.createElement('canvas');
  canvas.width = bbox.width * 1.5;
  canvas.height = bbox.height * 1.5;
  const ctx = canvas.getContext('2d');
  ctx.scale(1.5, 1.5);
  ctx.fillStyle = bgPrimary;
  ctx.fillRect(0, 0, bbox.width, bbox.height);

  const img = new Image();
  img.onload = () => {
    ctx.drawImage(img, 0, 0, bbox.width, bbox.height);

    const doc = new jspdf.jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();

    // Title bar
    doc.setFillColor(0, 27, 65);
    doc.rect(0, 0, pageW, 20, 'F');
    doc.setFontSize(14);
    doc.setTextColor(241, 245, 249);
    doc.text(`VDC: ${dcName}`, 10, 13);
    doc.setFontSize(9);
    doc.setTextColor(160, 196, 232);
    const meta = [dcLocation, new Date().toLocaleDateString()].filter(Boolean).join(' \u00b7 ');
    doc.text(meta, pageW - 10, 13, { align: 'right' });

    // Topology diagram
    const imgData = canvas.toDataURL('image/png');
    const imgW = pageW - 20;
    const imgH = Math.min((bbox.height / bbox.width) * imgW, pageH - 35);
    doc.addImage(imgData, 'PNG', 10, 24, imgW, imgH);

    // Resource table on new page
    doc.addPage('a4', 'landscape');
    doc.setFillColor(0, 27, 65);
    doc.rect(0, 0, pageW, 16, 'F');
    doc.setFontSize(12);
    doc.setTextColor(241, 245, 249);
    doc.text('Resource Inventory', 10, 11);
    doc.setFontSize(8);
    doc.setTextColor(160, 196, 232);
    doc.text(`${rows.length} resources`, pageW - 10, 11, { align: 'right' });

    const tableData = rows.map(r => [r.name, r.typeLabel, r.state, r.details, r.ips]);

    doc.autoTable({
      head: [['Name', 'Type', 'State', 'Details', 'IPs']],
      body: tableData,
      startY: 20,
      margin: { left: 10, right: 10 },
      styles: { fontSize: 8, textColor: [241, 245, 249], fillColor: [0, 38, 77], cellPadding: 2.5, lineWidth: 0.1, lineColor: [26, 74, 122] },
      headStyles: { fillColor: [0, 27, 65], textColor: [17, 199, 230], fontStyle: 'bold', fontSize: 8 },
      alternateRowStyles: { fillColor: [0, 51, 102] },
      columnStyles: { 0: { cellWidth: 50 }, 1: { cellWidth: 30 }, 2: { cellWidth: 25 }, 3: { cellWidth: 65 }, 4: { cellWidth: 'auto' } },
    });

    doc.save(`vdc-${dcName}-report.pdf`);
    toast(t('toast.pdfExported'), 'success');
    closeExportMenu();
  };

  img.onerror = () => {
    toast(t('toast.pdfFailed'), 'error');
    closeExportMenu();
  };

  const utf8Bytes = new TextEncoder().encode(svgStr);
  const binStr = Array.from(utf8Bytes, b => String.fromCharCode(b)).join('');
  img.src = 'data:image/svg+xml;base64,' + btoa(binStr);
}

// ── IP Block Panel ──
let ipBlockData = null;
async function loadIPBlocks() {
  try {
    const data = await fetchIPBlocks();
    console.log('[VDC-Viz] IP blocks response:', data);
    if (!data?.items) {
      console.warn('[VDC-Viz] No IP blocks found or fetch failed');
      return;
    }
    ipBlockData = data.items;
    console.log(`[VDC-Viz] Loaded ${ipBlockData.length} IP block(s)`);
    renderIPBlockPanel();
  } catch (e) { console.warn('[VDC-Viz] IP blocks fetch failed', e); }
}

function renderIPBlockPanel(filterLocation) {
  const panel = document.getElementById('ipBlockPanel');
  const section = document.getElementById('ipBlockSection');
  if (!ipBlockData || ipBlockData.length === 0) {
    section.style.display = 'none';
    return;
  }
  section.style.display = '';

  // Aggregate by location
  const byLoc = new Map();
  ipBlockData.forEach(block => {
    const loc = block.properties?.location || 'unknown';
    if (!byLoc.has(loc)) byLoc.set(loc, { total: 0, used: 0, blocks: [] });
    const entry = byLoc.get(loc);
    const ips = block.properties?.ips || [];
    const size = block.properties?.size || ips.length;
    // IONOS API may use ipConsumers (camelCase) or ip_consumers (snake_case)
    const consumers = block.properties?.ipConsumers || block.properties?.ip_consumers || [];
    entry.total += size;
    entry.used += consumers.length;
    entry.blocks.push(block);
  });

  // Determine which locations to display
  // When filtering, also match sub-locations (e.g. 'de/fra' matches 'de/fra/1')
  let locations;
  if (filterLocation) {
    const baseLoc = filterLocation.split('/').slice(0, 2).join('/');
    locations = [...byLoc.keys()].filter(k => k === filterLocation || k === baseLoc || k.startsWith(baseLoc + '/'));
    // If no blocks match the filter, show all locations with a note
    if (locations.length === 0) locations = [...byLoc.keys()].sort();
  } else {
    locations = [...byLoc.keys()].sort();
  }

  // Compute totals only for visible locations (not all locations)
  let totalVis = 0, usedVis = 0;
  locations.forEach(loc => {
    const entry = byLoc.get(loc);
    if (entry) { totalVis += entry.total; usedVis += entry.used; }
  });

  // Also compute grand totals for context
  let totalAll = 0, usedAll = 0;
  byLoc.forEach(v => { totalAll += v.total; usedAll += v.used; });

  const pct = totalVis > 0 ? Math.round((usedVis / totalVis) * 100) : 0;
  const barColor = pct > 90 ? '#ef4444' : pct > 70 ? '#f59e0b' : '#10b981';

  // Show filtered totals; if filtering, also show grand total in parentheses
  const barLabel = filterLocation && totalVis !== totalAll
    ? `<span class="used" style="color:${barColor}">${usedVis}</span> / ${totalVis} <span style="opacity:0.5">(${usedAll}/${totalAll} total)</span>`
    : `<span class="used" style="color:${barColor}">${usedVis}</span> / ${totalVis}`;

  let html = `<div class="ip-bar-container">
    <div class="ip-bar"><div class="ip-bar-fill" style="width:${pct}%;background:${barColor};"></div></div>
    <div class="ip-bar-label">${barLabel}</div>
  </div>`;

  locations.forEach(loc => {
    const entry = byLoc.get(loc);
    if (!entry) return;
    const flag = countryFlag(loc);
    const city = LOCATION_CITIES[loc.split('/').slice(0, 2).join('/')] || loc;
    html += `<div class="ip-block-row">
      <span class="ip-block-loc">${flag} ${city}</span>
      <span class="ip-block-stat"><span class="used">${entry.used}</span> / ${entry.total} used</span>
    </div>`;
  });

  panel.innerHTML = html;
}

// ── DNS & CDN Panel ──
let dnsZones = null;
let reverseIpMap = null;       // Map: IP string → hostname
let forwardDnsMap = null;      // Map: IP string → [{ zoneName, recordName }]
let cdnDomainSet = null;       // Set of domain names with CDN distribution
let dnsRecordCounts = null;    // Map: zoneId → record count

async function loadDNSData() {
  if (dnsZones) return; // Already loaded (global data, fetch once)
  try {
    const [zones, reverseDns, distributions] = await Promise.all([
      fetchDNSZones(),
      fetchReverseDNS(),
      fetchCDNDistributions(),
    ]);

    if (!zones?.items || zones.items.length === 0) {
      console.warn('[VDC-Viz] No DNS zones found');
      return;
    }

    dnsZones = zones.items;
    console.log(`[VDC-Viz] Loaded ${dnsZones.length} DNS zone(s)`);

    // Build reverse IP → hostname map
    reverseIpMap = new Map();
    if (reverseDns?.items) {
      reverseDns.items.forEach(rec => {
        const ip = rec.properties?.ip;
        const hostname = rec.properties?.name;
        if (ip && hostname) reverseIpMap.set(ip, hostname);
      });
      console.log(`[VDC-Viz] Built reverse DNS map: ${reverseIpMap.size} record(s)`);
    }

    // Build CDN domain set
    cdnDomainSet = new Set();
    if (distributions?.items) {
      distributions.items.forEach(dist => {
        const domain = dist.properties?.domain;
        if (domain) cdnDomainSet.add(domain);
      });
      console.log(`[VDC-Viz] CDN distributions: ${cdnDomainSet.size} domain(s) protected`);
    }

    // Fetch records for each zone → build forward DNS map (IP → domains)
    forwardDnsMap = new Map();
    dnsRecordCounts = new Map();
    await Promise.all(dnsZones.map(async (zone) => {
      const records = await fetchDNSRecords(zone.id);
      const items = records?.items || [];
      const zoneName = zone.properties?.zoneName || zone.id;
      dnsRecordCounts.set(zone.id, items.length);

      items.forEach(rec => {
        const rType = rec.properties?.type;
        const content = rec.properties?.content || '';
        if ((rType === 'A' || rType === 'AAAA') && content) {
          const recName = rec.properties?.name || '';
          const fqdn = recName ? `${recName}.${zoneName}` : zoneName;
          if (!forwardDnsMap.has(content)) forwardDnsMap.set(content, []);
          forwardDnsMap.get(content).push({ zoneName, fqdn });
        }
      });
    }));

    console.log(`[VDC-Viz] Forward DNS map: ${forwardDnsMap.size} IP(s) with DNS records`);

    renderDNSPanel();
    enrichIPLabels();
  } catch (e) {
    console.warn('[VDC-Viz] DNS/CDN data fetch failed:', e.message);
  }
}

function renderDNSPanel() {
  const panel = document.getElementById('dnsPanel');
  const section = document.getElementById('dnsSection');
  if (!dnsZones || dnsZones.length === 0) {
    if (section) section.style.display = 'none';
    return;
  }
  if (section) section.style.display = '';
  const countEl = document.getElementById('dnsZoneCount');
  if (countEl) countEl.textContent = dnsZones.length;

  let html = '';
  dnsZones.forEach(zone => {
    const zoneName = zone.properties?.zoneName || zone.id;
    const isEnabled = zone.properties?.enabled !== false;
    const zoneCDN = hasCDN(zoneName, zoneName);
    const recCount = dnsRecordCounts?.get(zone.id) || 0;
    const state = zone.metadata?.state || '';

    // Find topology IPs matching this zone's A/AAAA records
    const matchingIps = [];
    forwardDnsMap?.forEach((entries, ip) => {
      if (entries.some(e => e.zoneName === zoneName)) matchingIps.push(ip);
    });

    const cdnBadge = zoneCDN
      ? '<span class="cdn-badge">CDN</span>'
      : '<span class="cdn-badge cdn-badge-off">No CDN</span>';
    const stateColor = state === 'AVAILABLE' || state === 'CREATED' ? 'var(--success)' : 'var(--text-muted)';

    html += `<div class="dns-zone-card" style="border-left-color:${stateColor}">
      <div style="font-weight:600;color:var(--text-primary);margin-bottom:2px;">
        ${escapeHtml(zoneName)} ${cdnBadge}
      </div>
      <div style="color:var(--text-muted);font-size:10px;">
        ${recCount} record${recCount !== 1 ? 's' : ''} &middot; ${isEnabled ? 'Enabled' : 'Disabled'}
      </div>
      ${matchingIps.length > 0 ? `<div style="color:var(--text-secondary);font-size:10px;margin-top:2px;">Topology IPs: ${matchingIps.join(', ')}</div>` : ''}
    </div>`;
  });

  if (panel) panel.innerHTML = html;
}

// ── Security Groups Overlay ──
async function loadSecurityOverlay(dcId) {
  try {
    const data = await fetchSecurityGroups(dcId);
    if (!data?.items || data.items.length === 0) return;

    // Build map: securityGroupId → { name, rules[] }
    const sgMap = new Map();
    data.items.forEach(sg => {
      const rules = sg.entities?.rules?.items || [];
      console.log(`[VDC-Viz] SecGroup "${sg.properties?.name}" (${sg.id}): ${rules.length} rule(s)`, rules.length > 0 ? rules[0] : '(empty)');
      sgMap.set(sg.id, {
        name: sg.properties?.name || sg.id,
        description: sg.properties?.description || '',
        rules: rules.map(r => {
          const p = r.properties || {};
          return {
            name: p.name || '',
            protocol: p.protocol || 'ANY',
            direction: p.type || 'INGRESS',
            sourceIp: p.sourceIp || p.sourceCidr || '',
            targetIp: p.targetIp || p.targetCidr || '',
            sourceMac: p.sourceMac || '',
            icmpType: p.icmpType,
            icmpCode: p.icmpCode,
            portStart: p.portRangeStart,
            portEnd: p.portRangeEnd,
          };
        }),
      });
    });

    // Store on graphData for use in detail panel
    if (graphData) graphData._securityGroups = sgMap;
  } catch (e) { console.warn('Security groups fetch failed', e); }
}

// ── Data Transfer Data ──
async function loadBillingData() {
  try {
    const [trafficResp, utilizationResp] = await Promise.all([
      fetchBillingTraffic(),
      fetchBillingUtilization(),
    ]);

    // Process per-VDC traffic from /traffic/ endpoint
    _billingTraffic = trafficResp;
    _billingByVdc = new Map();
    // Response: { metadata: { unit: "Bytes" }, trafficObj: { vdc: [ { vdcUUID, vdcName, dates: [ { Date, In, Out } ] } ] } }
    if (trafficResp?.trafficObj?.vdc) {
      const vdcList = trafficResp.trafficObj.vdc;
      vdcList.forEach(vdc => {
        const vdcId = vdc.vdcUUID;
        if (!vdcId) return;
        let totalIn = 0, totalOut = 0;
        if (vdc.dates) {
          vdc.dates.forEach(d => {
            totalIn += (d.In || 0);
            totalOut += (d.Out || 0);
          });
        }
        _billingByVdc.set(vdcId, {
          name: vdc.vdcName || '',
          totalIn,
          totalOut,
        });
      });
      console.log(`[VDC-Viz] Billing traffic: ${_billingByVdc.size} VDC(s)`);
    }

    // Process per-server utilization from /utilization/ endpoint
    // Response: { datacenters: [ { id, name, meters: [ { serverId, meterId, quantity: { quantity, unit }, from, ... } ] } ] }
    _billingUtilization = utilizationResp;
    _billingByServer = new Map();
    const dcList = utilizationResp?.datacenters || [];
    console.log(`[VDC-Viz] Billing utilization: ${dcList.length} datacenter(s) in response`);
    if (dcList.length > 0) {
      dcList.forEach(dc => {
        const meters = dc.meters || [];
        meters.forEach(meter => {
          const serverId = meter.serverId;
          if (!serverId) return;
          const meterId = meter.meterId || '';
          const isInbound = meterId === 'TI1000';
          const isOutbound = meterId === 'TO1000';
          if (!isInbound && !isOutbound) return;

          if (!_billingByServer.has(serverId)) {
            _billingByServer.set(serverId, { totalIn: 0, totalOut: 0, daily: new Map() });
          }
          const entry = _billingByServer.get(serverId);
          // quantity is an object: { quantity: 0.123, unit: "1G" }
          const qty = (meter.quantity && typeof meter.quantity === 'object')
            ? (meter.quantity.quantity || 0) : (meter.quantity || 0);
          if (isInbound) entry.totalIn += qty;
          if (isOutbound) entry.totalOut += qty;

          // Aggregate daily data — date is in meter.from (ISO string)
          const fromStr = meter.from || '';
          const date = fromStr.substring(0, 10); // "2026-02-01T00:00:00.000Z" → "2026-02-01"
          if (date) {
            if (!entry.daily.has(date)) entry.daily.set(date, { date, inGB: 0, outGB: 0 });
            const day = entry.daily.get(date);
            if (isInbound) day.inGB += qty;
            if (isOutbound) day.outGB += qty;
          }
        });
      });

      // Convert daily Maps to sorted arrays
      _billingByServer.forEach(entry => {
        entry.daily = [...entry.daily.values()].sort((a, b) => a.date.localeCompare(b.date));
      });

      console.log(`[VDC-Viz] Billing utilization: ${_billingByServer.size} server(s)`);
    }

    // Update billing panel on map if visible
    updateMapBillingPanel();
    // Invalidate heatmap cache if billing data changed
    invalidateHeatmapCache();
  } catch (e) {
    console.warn('[VDC-Viz] Billing data fetch failed:', e.message);
  }
}

function fmtTrafficBytes(bytes) {
  const gb = bytes / (1024 * 1024 * 1024);
  if (gb >= 1024) return (gb / 1024).toFixed(1) + ' TB';
  if (gb >= 1) return gb.toFixed(1) + ' GB';
  return (gb * 1024).toFixed(0) + ' MB';
}

function updateMapBillingPanel(drillRegion) {
  const panel = document.getElementById('mapBillingPanel');
  if (!panel) return;
  if (!_billingByVdc || _billingByVdc.size === 0) {
    panel.classList.add('hidden');
    return;
  }
  const el = document.getElementById('mapBackground');
  if (!el || !el.classList.contains('overview-mode')) {
    panel.classList.add('hidden');
    return;
  }

  const clusters = buildRegionClusters();
  const region = drillRegion || null;
  let html = '';

  if (!region) {
    // ── Overview: show per-region summary ──
    html += `<h4>Data Transfer</h4>`;
    html += `<table class="mbp-table"><thead><tr><th>Region</th><th>\u2193 In</th><th>\u2191 Out</th></tr></thead><tbody>`;
    let grandIn = 0, grandOut = 0;
    clusters.forEach(c => {
      let rIn = 0, rOut = 0;
      c.vdcs.forEach(v => {
        const bd = _billingByVdc.get(v.id);
        if (bd) { rIn += bd.totalIn; rOut += bd.totalOut; }
      });
      if (rIn === 0 && rOut === 0) return;
      grandIn += rIn; grandOut += rOut;
      html += `<tr><td>${c.flag} ${c.city}</td><td class="mbp-in">${fmtTrafficBytes(rIn)}</td><td class="mbp-out">${fmtTrafficBytes(rOut)}</td></tr>`;
    });
    if (grandIn > 0 || grandOut > 0) {
      html += `<tr class="mbp-total"><td>Total</td><td class="mbp-in">${fmtTrafficBytes(grandIn)}</td><td class="mbp-out">${fmtTrafficBytes(grandOut)}</td></tr>`;
    }
    html += `</tbody></table>`;
  } else {
    // ── Drilled-in: show per-VDC for this region ──
    const cluster = clusters.find(c => c.region === region);
    if (!cluster) { panel.classList.add('hidden'); return; }
    html += `<h4>${cluster.flag} ${cluster.city} Traffic</h4>`;
    html += `<table class="mbp-table"><thead><tr><th>VDC</th><th>\u2193 In</th><th>\u2191 Out</th></tr></thead><tbody>`;
    let regIn = 0, regOut = 0;
    cluster.vdcs.forEach(v => {
      const bd = _billingByVdc.get(v.id);
      if (!bd) return;
      regIn += bd.totalIn; regOut += bd.totalOut;
      html += `<tr><td title="${escapeHtml(v.name)}">${escapeHtml(v.name)}</td><td class="mbp-in">${fmtTrafficBytes(bd.totalIn)}</td><td class="mbp-out">${fmtTrafficBytes(bd.totalOut)}</td></tr>`;
    });
    if (regIn > 0 || regOut > 0) {
      html += `<tr class="mbp-total"><td>Total</td><td class="mbp-in">${fmtTrafficBytes(regIn)}</td><td class="mbp-out">${fmtTrafficBytes(regOut)}</td></tr>`;
    }
    html += `</tbody></table>`;
  }

  panel.innerHTML = html;
  panel.classList.remove('hidden');
}

// ── Network Metrics (IONOS Monitoring/Telemetry) ──
// Telemetry API is Prometheus-compatible; uses same auth as Cloud API.
// Metric names: instance_network_in_bytes, instance_network_out_bytes,
//               instance_network_in_packets, instance_network_out_packets
const TELEMETRY_BASE = 'https://api.ionos.com/telemetry/api/v1';

async function fetchNetworkMetrics(serverId) {
  const metricNames = ['instance_network_in_bytes', 'instance_network_out_bytes',
                       'instance_network_in_packets', 'instance_network_out_packets'];
  const keys = ['bytesIn', 'bytesOut', 'packetsIn', 'packetsOut'];

  // Time range: last 1 hour, 60s steps (matches IONOS telemetry pattern)
  const end = new Date();
  const start = new Date(end.getTime() - 60 * 60 * 1000);
  const timeParams = `&start=${start.toISOString()}&end=${end.toISOString()}&step=60`;

  try {
    const results = {};
    const fetches = metricNames.map(async (metric, i) => {
      try {
        const query = `irate(${metric}{uuid="${serverId}"}[4m])`;
        const url = `${TELEMETRY_BASE}/query_range?query=${encodeURIComponent(query)}${timeParams}`;
        console.log(`[Metrics] Querying ${keys[i]}: ${url}`);
        const json = await apiFetch(url);
        console.log(`[Metrics] ${keys[i]} response:`, json);
        // query_range returns matrix: result[].values = [[timestamp, "value"], ...]
        const values = json?.data?.result?.[0]?.values;
        if (values && values.length > 0) {
          results[keys[i]] = values.map(([ts, val]) => ({ t: ts * 1000, v: parseFloat(val) || 0 }));
        }
      } catch (e) {
        console.warn(`[Metrics] ${keys[i]} query failed:`, e.message);
      }
    });
    await Promise.allSettled(fetches);
    console.log('[Metrics] Final results:', Object.keys(results).map(k => `${k}: ${results[k]?.length || 0} pts`));
    return Object.keys(results).length > 0 ? results : null;
  } catch (e) {
    console.warn('[VDC-Viz] Network metrics fetch failed', e);
    return null;
  }
}

function formatBytes(bytesPerSec) {
  if (bytesPerSec == null || isNaN(bytesPerSec)) return 'N/A';
  if (bytesPerSec < 1024) return `${bytesPerSec.toFixed(1)} B/s`;
  if (bytesPerSec < 1024 * 1024) return `${(bytesPerSec / 1024).toFixed(1)} KB/s`;
  return `${(bytesPerSec / (1024 * 1024)).toFixed(1)} MB/s`;
}

function formatPackets(pps) {
  if (pps == null || isNaN(pps)) return 'N/A';
  if (pps < 1000) return `${pps.toFixed(0)} pps`;
  return `${(pps / 1000).toFixed(1)}K pps`;
}

// Render a small time-series chart into a container using D3
function renderMetricsChart(container, seriesA, seriesB, labelA, labelB, colorA, colorB, formatter) {
  const W = container.clientWidth || 320, H = 80;
  const margin = { top: 4, right: 6, bottom: 18, left: 40 };
  const w = W - margin.left - margin.right, h = H - margin.top - margin.bottom;

  container.classList.add('metrics-chart');
  const allPts = [...(seriesA || []), ...(seriesB || [])];
  if (allPts.length === 0) {
    container.innerHTML = '<div class="metrics-no-data">No data</div>';
    return;
  }

  const xExtent = d3.extent(allPts, d => d.t);
  const yMax = d3.max(allPts, d => d.v) || 1;
  const x = d3.scaleTime().domain(xExtent).range([0, w]);
  const y = d3.scaleLinear().domain([0, yMax * 1.1]).range([h, 0]);

  const svg = d3.select(container).append('svg')
    .attr('width', W).attr('height', H)
    .append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  // Axes
  svg.append('g').attr('class', 'axis x-axis').attr('transform', `translate(0,${h})`)
    .call(d3.axisBottom(x).ticks(4).tickFormat(d3.timeFormat('%H:%M')));

  svg.append('g').attr('class', 'axis y-axis grid')
    .call(d3.axisLeft(y).ticks(3).tickFormat(d => formatter(d)))
    .call(g => g.selectAll('.tick line').clone().attr('x2', w).attr('class', 'grid-line'));

  const line = d3.line().x(d => x(d.t)).y(d => y(d.v)).curve(d3.curveMonotoneX);
  const area = d3.area().x(d => x(d.t)).y0(h).y1(d => y(d.v)).curve(d3.curveMonotoneX);

  // Draw each series: area fill + line
  function drawSeries(data, color) {
    if (!data || data.length === 0) return;
    svg.append('path').datum(data).attr('d', area)
      .attr('fill', color).attr('fill-opacity', 0.1);
    svg.append('path').datum(data).attr('d', line)
      .attr('fill', 'none').attr('stroke', color).attr('stroke-width', 1.5).attr('stroke-opacity', 0.8);
  }
  drawSeries(seriesA, colorA);
  drawSeries(seriesB, colorB);

  // Legend with latest values
  const lastA = seriesA?.[seriesA.length - 1]?.v;
  const lastB = seriesB?.[seriesB.length - 1]?.v;
  const legend = d3.select(container).append('div').attr('class', 'metrics-legend');
  if (lastA !== undefined) legend.append('span')
    .style('color', colorA).html(`\u25CF ${labelA}: ${formatter(lastA)}`);
  if (lastB !== undefined) legend.append('span')
    .style('color', colorB).html(`\u25CF ${labelB}: ${formatter(lastB)}`);
}

async function loadAndShowMetrics(serverId) {
  const container = document.getElementById('metricsContainer');
  if (!container) return;
  container.innerHTML = '<div class="metrics-loading">Loading metrics...</div>';
  const metrics = await fetchNetworkMetrics(serverId);
  if (!metrics) {
    container.innerHTML = '<div class="metrics-no-data">No metrics data — check browser console for details</div>';
    return;
  }
  container.innerHTML = '';

  // Throughput chart (bytes/s)
  if (metrics.bytesIn || metrics.bytesOut) {
    const chartLabel = document.createElement('div');
    chartLabel.className = 'metrics-chart-label';
    chartLabel.textContent = 'Throughput (last 1h)';
    container.appendChild(chartLabel);
    const bytesDiv = document.createElement('div');
    container.appendChild(bytesDiv);
    renderMetricsChart(bytesDiv, metrics.bytesIn, metrics.bytesOut, '\u2193 In', '\u2191 Out', '#10b981', '#f59e0b', formatBytes);
  }

  // Packets chart
  if (metrics.packetsIn || metrics.packetsOut) {
    const chartLabel = document.createElement('div');
    chartLabel.className = 'metrics-chart-label';
    chartLabel.textContent = 'Packets (last 1h)';
    container.appendChild(chartLabel);
    const pktDiv = document.createElement('div');
    container.appendChild(pktDiv);
    renderMetricsChart(pktDiv, metrics.packetsIn, metrics.packetsOut, '\u2193 In', '\u2191 Out', '#10b981', '#f59e0b', formatPackets);
  }
}

function loadAndShowBillingChart(serverId) {
  const container = document.getElementById('billingContainer');
  if (!container) return;

  const serverData = _billingByServer.get(serverId);
  if (!serverData || !serverData.daily || serverData.daily.length === 0) {
    container.innerHTML = `<div class="metrics-no-data">${t('detail.noBillingData')}</div>`;
    return;
  }

  container.innerHTML = '';

  const daily = serverData.daily;
  const W = container.clientWidth || 320, H = 90;
  const margin = { top: 6, right: 6, bottom: 22, left: 42 };
  const w = W - margin.left - margin.right, h = H - margin.top - margin.bottom;

  container.classList.add('metrics-chart');

  const maxVal = Math.max(1, d3.max(daily, d => Math.max(d.inGB, d.outGB)));
  const xScale = d3.scaleBand().domain(daily.map(d => d.date)).range([0, w]).padding(0.2);
  const yScale = d3.scaleLinear().domain([0, maxVal * 1.1]).range([h, 0]);

  const svg = d3.select(container).append('svg')
    .attr('width', W).attr('height', H)
    .append('g').attr('transform', `translate(${margin.left},${margin.top})`);

  // X axis — show a few date labels
  const tickFilter = daily.length > 10
    ? daily.filter((_, i) => i % Math.ceil(daily.length / 6) === 0).map(d => d.date)
    : daily.map(d => d.date);
  svg.append('g').attr('class', 'axis x-axis').attr('transform', `translate(0,${h})`)
    .call(d3.axisBottom(xScale).tickValues(tickFilter).tickFormat(d => {
      const parts = d.split('-');
      return parts.length >= 3 ? `${parts[1]}/${parts[2]}` : d;
    }));

  // Y axis
  svg.append('g').attr('class', 'axis y-axis grid')
    .call(d3.axisLeft(yScale).ticks(3).tickFormat(d => d.toFixed(1) + ' GB'))
    .call(g => g.selectAll('.tick line').clone().attr('x2', w).attr('class', 'grid-line'));

  const barW = xScale.bandwidth() / 2;

  // Inbound bars (green)
  svg.selectAll('.bar-in').data(daily).enter().append('rect')
    .attr('class', 'bar-in')
    .attr('x', d => xScale(d.date))
    .attr('y', d => yScale(d.inGB))
    .attr('width', barW)
    .attr('height', d => h - yScale(d.inGB))
    .attr('fill', '#10b981').attr('opacity', 0.8);

  // Outbound bars (amber)
  svg.selectAll('.bar-out').data(daily).enter().append('rect')
    .attr('class', 'bar-out')
    .attr('x', d => xScale(d.date) + barW)
    .attr('y', d => yScale(d.outGB))
    .attr('width', barW)
    .attr('height', d => h - yScale(d.outGB))
    .attr('fill', '#f59e0b').attr('opacity', 0.8);

  // Legend
  const legend = d3.select(container).append('div').attr('class', 'metrics-legend');
  legend.append('span').style('color', '#10b981')
    .html(`\u25CF \u2193 In: ${serverData.totalIn.toFixed(2)} GB`);
  legend.append('span').style('color', '#f59e0b')
    .html(`\u25CF \u2191 Out: ${serverData.totalOut.toFixed(2)} GB`);
}

// ============================== MAIN FLOWS ==============================
async function connect(isSwitching = false) {
  apiToken = document.getElementById('tokenInput').value.trim();
  if (!apiToken) { toast(t('toast.enterToken'), 'error'); return; }

  const btn = document.getElementById('connectBtn');
  btn.disabled = true;
  btn.textContent = 'Connecting...';

  // Show progressive loading screen and stop carousel
  showConnectLoading();
  setConnectLoadingStep('auth');
  if (window._stopFeatureCarousel) window._stopFeatureCarousel();

  try {
    // 1. Fetch Contracts first if not already switching
    if (!isSwitching) {
        const contracts = await fetchContracts();
        userContracts = contracts;
        if (contracts.length > 0) {
            // Set default if not set
            if (!currentContract) currentContract = contracts[0].properties.contractNumber;
            showUserInfo({ ...(currentUser || {}), contracts });
        }
    }

    completeConnectLoadingStep('auth');
    setConnectLoadingStep('datacenters');

    // 2. Fetch Datacenters (will now use X-Contract header if currentContract is set)
    datacenters = await fetchDatacenters();
    if (datacenters.length === 0) {
      toast(t('toast.noDataCenters'), 'warning');
      hideConnectLoading();
      return;
    }

    // Sort by name for easier selection
    datacenters.sort((a, b) => (a.properties?.name || '').localeCompare(b.properties?.name || ''));

    const sel = document.getElementById('dcSelect');
    sel.innerHTML = '<option value="">-- Select a VDC --</option>';
    datacenters.forEach(dc => {
      const opt = document.createElement('option');
      opt.value = dc.id;
      const name = dc.properties?.name || dc.id;
      const loc = dc.properties?.location || '';
      const cityLabel = locationLabel(loc);
      opt.textContent = `${name} (${cityLabel.trim()})`;
      sel.appendChild(opt);
    });
    sel.disabled = false;
    document.getElementById('refreshBtn').disabled = false;
    document.getElementById('pinVdcBtn').disabled = false;
    loadFavorites();
    reorderVDCOptions();

    // Populate location dropdown (grouped by region — e.g. de/fra covers de/fra/1 + de/fra/2)
    const locMap = new Map();
    datacenters.forEach(dc => {
      const region = locationRegion(dc.properties?.location || '');
      if (!locMap.has(region)) locMap.set(region, []);
      locMap.get(region).push(dc);
    });
    const locSel = document.getElementById('locSelect');
    locSel.innerHTML = '<option value="">-- Select a location --</option>';
    [...locMap.entries()].sort((a, b) => a[0].localeCompare(b[0])).forEach(([region, dcs]) => {
      const opt = document.createElement('option');
      opt.value = region;
      opt.textContent = `${locationLabel(region).trim()} (${dcs.length} VDC${dcs.length > 1 ? 's' : ''})`;
      locSel.appendChild(opt);
    });
    locSel.disabled = false;
    document.getElementById('refreshLocBtn').disabled = false;

    completeConnectLoadingStep('datacenters');
    setConnectLoadingStep('map');

    toast(t('toast.foundDcs', {count: datacenters.length}), 'success');

    // Initialize map and show global overview (remove pre-login dimming)
    document.getElementById('mapBackground').classList.remove('pre-login');
    initMapBackground();

    completeConnectLoadingStep('map');
    setConnectLoadingStep('billing');

    // Start billing data fetch early (needs contract number + token, both available now)
    loadBillingData();

    setViewMode('map');

    // Background: fetch dynamic locations from API to enrich city labels
    loadDynamicLocations();

    // Extract user info: decode JWT for uuid + contract, then fetch user by ID for email
    const jwt = decodeJwtPayload(apiToken);
    console.log('[VDC-Viz] JWT payload:', jwt);
    const userInfo = { email: '', firstName: '', lastName: '', contractNumber: '' };

    if (jwt) {
      // IONOS JWT structure: fields are nested under jwt.identity {}
      const identity = jwt.identity || {};
      const jwtUuid = identity.uuid || '';
      userInfo.contractNumber = String(identity.contractNumber || '') || '';
      console.log('[VDC-Viz] JWT identity.uuid:', jwtUuid, '| contractNumber:', userInfo.contractNumber);

      // Fetch user email by direct /um/users/{uuid} call
      if (jwtUuid) {
        try {
          const user = await safeFetch(`${API_BASES.cloud}/um/users/${jwtUuid}`);
          if (user?.properties) {
            userInfo.email = user.properties.email || '';
            userInfo.firstName = user.properties.firstname || '';
            userInfo.lastName = user.properties.lastname || '';
            console.log('[VDC-Viz] User found by id:', userInfo.email);
          }
        } catch (e) { console.warn('[VDC-Viz] User-by-id fetch failed:', e.message); }
      }
    }

    if (userInfo.email || userInfo.contractNumber) {
      userInfo.contracts = userContracts;
      currentUser = userInfo;
      showUserInfo(currentUser);
    } else {
      console.log('[VDC-Viz] No user info available');
    }

    // Fetch IP blocks and DNS/CDN in background (non-blocking)
    // Note: loadBillingData() already started earlier for faster panel display
    completeConnectLoadingStep('billing');
    setConnectLoadingStep('dns');
    loadIPBlocks();
    loadDNSData().then(() => {
      completeConnectLoadingStep('dns');
      setConnectLoadingStep('ready');
      // Brief pause then mark ready and hide
      setTimeout(() => {
        completeConnectLoadingStep('ready');
        hideConnectLoading();
      }, 600);
    }).catch(() => {
      completeConnectLoadingStep('dns');
      completeConnectLoadingStep('ready');
      hideConnectLoading();
    });

    // Switch Connect button to Disconnect
    btn.disabled = false;
    btn.textContent = t('sidebar.disconnect');
    btn.onclick = disconnect;
    btn.classList.remove('btn-primary');
    btn.classList.add('btn-disconnect');
  } catch (e) {
    toast(t('toast.connectionFailed', {error: e.message}), 'error');
    console.error(e);
    btn.disabled = false;
    btn.textContent = t('sidebar.connect');
    hideConnectLoading();
  }
}

function disconnect() {
  // Clear token and API state
  apiToken = '';
  currentUser = null;
  userContracts = [];
  currentContract = null;
  datacenters = [];
  graphData = null;
  reverseIpMap = null;
  forwardDnsMap = null;
  dnsZones = null;
  ipBlocks = null;
  _billingTraffic = null;
  _billingUtilization = null;
  _billingByServer = new Map();
  _billingByVdc = new Map();

  // Clear AI state
  if (aiAbortController) { aiAbortController.abort(); aiAbortController = null; }
  mcpSessionId = null;
  mcpInitialized = false;
  _mcpSearchToolName = null;
  closeAiPanel();
  clearAiConversation();
  updateAiButtonVisibility();

  // Reset token input and connect button
  document.getElementById('tokenInput').value = '';
  const btn = document.getElementById('connectBtn');
  btn.textContent = t('sidebar.connect');
  btn.onclick = connect;
  btn.classList.remove('btn-disconnect');
  btn.classList.add('btn-primary');

  // Hide account section
  const acctSection = document.getElementById('accountSection');
  if (acctSection) acctSection.style.display = 'none';

  // Reset VDC dropdown
  const sel = document.getElementById('dcSelect');
  sel.innerHTML = `<option value="" data-i18n="sidebar.connectFirst">${t('sidebar.connectFirst')}</option>`;
  sel.disabled = true;
  document.getElementById('refreshBtn').disabled = true;
  document.getElementById('pinVdcBtn').disabled = true;

  // Reset location dropdown
  const locSel = document.getElementById('locSelect');
  locSel.innerHTML = `<option value="" data-i18n="sidebar.connectFirst">${t('sidebar.connectFirst')}</option>`;
  locSel.disabled = true;
  document.getElementById('refreshLocBtn').disabled = true;

  // Clear graph
  d3.select('#graphSvg').selectAll('*').remove();

  // Reset views
  if (ipViewActive) toggleIPView();
  if (computeViewActive) toggleComputeView();

  // Hide legend, IP blocks, DNS sections
  document.getElementById('legendSection').style.display = 'none';
  const ipBlockSec = document.getElementById('ipBlockSection');
  if (ipBlockSec) ipBlockSec.style.display = 'none';
  const dnsSec = document.getElementById('dnsSection');
  if (dnsSec) dnsSec.style.display = 'none';

  // Reset map to pre-login state
  document.getElementById('mapBackground').classList.add('pre-login');
  setViewMode('map');

  // Hide toolbar and search (they only make sense with a loaded graph)
  document.getElementById('toolbar').style.display = 'none';
  document.getElementById('searchSection').style.display = 'none';
  document.getElementById('graphSvg').classList.add('hidden-for-map');

  // Show onboarding card again AFTER setViewMode('map') which hides it via showMapOverview()
  const emptyState = document.getElementById('emptyState');
  if (emptyState) {
    emptyState.style.display = '';
    const appName = emptyState.querySelector('.onboarding-appname');
    if (appName) appName.textContent = t('onboarding.title');
    const p = emptyState.querySelector('.onboarding-header p');
    if (p) p.textContent = t('onboarding.subtitle');
  }

  // Clear detail panel, search, DNS panel
  closeDetail();
  clearSearch();
  const dnsPanel = document.getElementById('dnsPanel');
  if (dnsPanel) dnsPanel.style.display = 'none';

  // Clear map cluster bubbles
  if (typeof clearMapMarkers === 'function') clearMapMarkers();

  toast(t('toast.disconnected'), 'info');
}

async function loadVDC() {
  const dcId = document.getElementById('dcSelect').value;
  if (!dcId) return;

  // Clean up previous view state
  closeAiPanelInstant();
  closeDetail();
  closeHighlightsOverlay();

  // Cancel any in-flight requests from previous VDC load
  if (currentAbortController) currentAbortController.abort();
  currentAbortController = new AbortController();

  showLoading(t('loading.fetchingDetails'));
  setVdcLoadingStep('servers');
  currentDC = datacenters.find(dc => dc.id === dcId);
  const dcLocation = currentDC?.properties?.location || '';

  try {
    const [dcData, natGWs, albs, nlbs, pgClusters, mongoClusters, mysqlClusters, mariadbClusters, k8sData, nfsClusters, vpnGateways, kafkaClusters] = await Promise.all([
      fetchDCDetails(dcId),
      fetchNatGateways(dcId),
      fetchALBs(dcId),
      fetchNLBs(dcId),
      fetchPostgresClusters(),
      fetchMongoClusters(),
      fetchMySQLClusters(),
      fetchMariaDBClusters(dcLocation),
      fetchK8sClusters(),
      fetchNFSClusters(dcLocation),
      fetchVPNGateways(dcLocation),
      fetchKafkaClusters(dcLocation),
    ]);

    // Ensure all servers have NIC data - fallback to per-server fetch if depth didn't include them
    completeVdcLoadingStep('servers');
    setVdcLoadingStep('nics');
    const servers = dcData?.entities?.servers?.items || [];
    console.log(`[VDC-Viz] Found ${servers.length} server(s) in DC response`);
    let nicFallbackCount = 0;
    await Promise.all(servers.map(async (srv) => {
      const nics = srv.entities?.nics?.items || [];
      const hasNicProps = nics.length > 0 && nics[0].properties;
      console.log(`[VDC-Viz] Server "${srv.properties?.name || srv.id}": ${nics.length} NIC(s), properties present: ${!!hasNicProps}`);
      if (nics.length === 0 || !hasNicProps) {
        // NICs missing or lacking properties - fetch them directly
        const nicData = await fetchServerNICs(dcId, srv.id);
        if (nicData && nicData.items && nicData.items.length > 0) {
          if (!srv.entities) srv.entities = {};
          srv.entities.nics = nicData;
          nicFallbackCount++;
          console.log(`[VDC-Viz]   -> Fetched ${nicData.items.length} NIC(s) for server "${srv.properties?.name || srv.id}"`);
        }
      }
    }));
    if (nicFallbackCount > 0) console.log(`[VDC-Viz] Used NIC fallback fetch for ${nicFallbackCount} server(s)`);

    completeVdcLoadingStep('nics');
    setVdcLoadingStep('k8s');
    const k8sNodePools = [];
    const k8sClusters = k8sData?.items || [];
    await Promise.all(k8sClusters.map(async (cluster) => {
      const pools = await fetchK8sNodePools(cluster.id);
      (pools?.items || []).forEach(pool => {
        k8sNodePools.push({ clusterId: cluster.id, clusterName: cluster.properties?.name || cluster.id, pool });
      });
    }));

    completeVdcLoadingStep('k8s');
    setVdcLoadingStep('graph');
    const data = buildGraph(dcData, natGWs, albs, nlbs, pgClusters, mongoClusters, mysqlClusters, mariadbClusters, k8sNodePools, nfsClusters || {}, vpnGateways, kafkaClusters);

    // Tag all nodes/links with _vdcIdx = 0 so collapse toggle works in single-VDC mode
    data.nodes.forEach(n => n._vdcIdx = 0);
    data.links.forEach(l => l._vdcIdx = 0);

    // Attach VDC boundary info so the name label renders on the canvas
    const vdcName = currentDC?.properties?.name || dcId;
    data._vdcBoundaries = [{ name: vdcName, nodeIds: new Set(data.nodes.map(n => n.id)), index: 0 }];

    renderGraph(data);
    setTimeout(() => zoomFit(), 1500);
    toast(t('toast.loadedResources', {count: data.nodes.length}), 'success');
    updateAiButtonVisibility();

    // Update map background to show VDC region
    updateMapBackground(dcLocation);

    // Load security groups, refresh IP/DNS panels in background (non-blocking)
    loadSecurityOverlay(dcId);
    if (ipBlockData) renderIPBlockPanel(dcLocation);
    if (dnsZones) { renderDNSPanel(); if (ipViewActive) enrichIPLabels(); }
  } catch (e) {
    toast(t('toast.loadFailed', {error: e.message}), 'error');
    console.error(e);
  } finally {
    hideLoading();
  }
}

// ============================== VIEW MODE ==============================
function setViewMode(mode) {
  document.getElementById('mapView').style.display = mode === 'map' ? '' : 'none';
  document.getElementById('singleVdcView').style.display = mode === 'single' ? '' : 'none';
  document.getElementById('locationView').style.display = mode === 'location' ? '' : 'none';
  document.getElementById('viewModeMap').classList.toggle('active', mode === 'map');
  document.getElementById('viewModeSingle').classList.toggle('active', mode === 'single');
  document.getElementById('viewModeLocation').classList.toggle('active', mode === 'location');

  // Toggle map overview vs topology
  if (mode === 'map') {
    showMapOverview();
  } else {
    hideMapOverview();
    // Ensure billing panel is hidden when leaving map view
    const bp = document.getElementById('mapBillingPanel');
    if (bp) bp.classList.add('hidden');
  }
}

const collapsedVdcs = new Set();

function toggleVdc(vdcIdx) {
  if (collapsedVdcs.has(vdcIdx)) {
    collapsedVdcs.delete(vdcIdx);
  } else {
    collapsedVdcs.add(vdcIdx);
  }
  const isCollapsed = collapsedVdcs.has(vdcIdx);

  // Toggle node visibility
  d3.selectAll('.node').each(function(d) {
    if (d._vdcIdx === vdcIdx) {
      d3.select(this).style('display', isCollapsed ? 'none' : '');
    }
  });
  // Toggle link visibility
  d3.selectAll('.link').each(function(d) {
    if (d._vdcIdx === vdcIdx) {
      d3.select(this).style('display', isCollapsed ? 'none' : '');
    }
  });
  // Toggle link labels
  d3.selectAll('.link-labels text, .link-labels rect').each(function(d) {
    if (d && d._vdcIdx === vdcIdx) {
      d3.select(this).style('display', isCollapsed ? 'none' : '');
    }
  });

  // Update VDC boundary appearance
  const boundaryGroup = d3.select(`.vdc-boundary-${vdcIdx}`);
  if (!boundaryGroup.empty()) {
    boundaryGroup.select('.vdc-boundary-rect').classed('vdc-boundary-collapsed', isCollapsed);
    boundaryGroup.select('.vdc-toggle').text(isCollapsed ? '▶' : '▼');
    boundaryGroup.selectAll('.vdc-inner-content').style('display', isCollapsed ? 'none' : '');
    const collapsedLabel = boundaryGroup.select('.vdc-collapsed-label');
    if (isCollapsed) {
      const nodeCount = graphData.nodes.filter(n => n._vdcIdx === vdcIdx).length;
      collapsedLabel.text(`${nodeCount} resources (collapsed)`).style('display', '');
    } else {
      collapsedLabel.style('display', 'none');
    }
  }
}

async function loadLocation() {
  const loc = document.getElementById('locSelect').value;
  if (!loc) return;

  // Clean up previous view state
  closeAiPanelInstant();
  closeDetail();
  closeHighlightsOverlay();

  // Match all VDCs in this region (e.g. "de/fra" matches "de/fra", "de/fra/1", "de/fra/2")
  const dcsInLoc = datacenters.filter(dc => {
    const dcRegion = locationRegion(dc.properties?.location || '');
    return dcRegion === loc || dc.properties?.location === loc;
  });
  if (dcsInLoc.length === 0) { toast(t('toast.noVdcsLocation'), 'warning'); return; }

  showLoading(t('loading.loadingVdcs', {count: dcsInLoc.length, location: locationLabel(loc).trim()}));
  setVdcLoadingStep('servers');

  try {
    // Fetch global/shared services ONCE (these are the same regardless of VDC)
    setLoadingText(t('loading.fetchingShared'));
    const dcLocation = dcsInLoc[0]?.properties?.location || '';
    const [pgClusters, mongoClusters, mysqlClusters, mariadbClusters, k8sData, nfsClusters, vpnGateways, kafkaClusters] = await Promise.all([
      fetchPostgresClusters(),
      fetchMongoClusters(),
      fetchMySQLClusters(),
      fetchMariaDBClusters(dcLocation),
      fetchK8sClusters(),
      fetchNFSClusters(dcLocation),
      fetchVPNGateways(dcLocation),
      fetchKafkaClusters(dcLocation),
    ]);

    // Fetch per-VDC data in parallel (only DC-specific APIs)
    const allVdcData = await Promise.all(dcsInLoc.map(async (dc, idx) => {
      setLoadingText(`Loading VDC ${idx + 1}/${dcsInLoc.length}: ${dc.properties?.name || dc.id}`);
      const dcId = dc.id;

      const [dcData, natGWs, albs, nlbs] = await Promise.all([
        fetchDCDetails(dcId),
        fetchNatGateways(dcId),
        fetchALBs(dcId),
        fetchNLBs(dcId),
      ]);

      // Resolve NICs
      const servers = dcData?.entities?.servers?.items || [];
      await Promise.all(servers.map(async (srv) => {
        const nics = srv.entities?.nics?.items || [];
        if (nics.length === 0 || !(nics[0]?.properties)) {
          const nicData = await fetchServerNICs(dcId, srv.id);
          if (nicData?.items?.length > 0) {
            if (!srv.entities) srv.entities = {};
            srv.entities.nics = nicData;
          }
        }
      }));

      // K8s node pools
      const k8sNodePools = [];
      const k8sClusters = k8sData?.items || [];
      await Promise.all(k8sClusters.map(async (cluster) => {
        const pools = await fetchK8sNodePools(cluster.id);
        (pools?.items || []).forEach(pool => {
          k8sNodePools.push({ clusterId: cluster.id, clusterName: cluster.properties?.name || cluster.id, pool });
        });
      }));

      return {
        dc,
        graph: buildGraph(dcData, natGWs, albs, nlbs, pgClusters, mongoClusters, mysqlClusters, mariadbClusters, k8sNodePools, nfsClusters || {}, vpnGateways, kafkaClusters),
      };
    }));

    // Merge all VDC graphs into one, prefixing node/link IDs to avoid collisions
    completeVdcLoadingStep('servers');
    completeVdcLoadingStep('nics');
    completeVdcLoadingStep('k8s');
    setVdcLoadingStep('graph');
    setLoadingText('Merging topologies');
    const mergedNodes = [];
    const mergedLinks = [];
    const vdcBoundaries = []; // track which nodes belong to which VDC

    allVdcData.forEach(({ dc, graph }, vi) => {
      const prefix = `vdc${vi}-`;
      const vdcName = dc.properties?.name || dc.id;
      const nodeIds = new Set();

      graph.nodes.forEach(n => {
        const newId = prefix + n.id;
        nodeIds.add(newId);
        mergedNodes.push({ ...n, id: newId, _origId: n.id, _vdcIdx: vi, _vdcName: vdcName });
      });

      graph.links.forEach(l => {
        const sId = typeof l.source === 'object' ? l.source.id : l.source;
        const tId = typeof l.target === 'object' ? l.target.id : l.target;
        mergedLinks.push({ ...l, source: prefix + sId, target: prefix + tId, _vdcIdx: vi });
      });

      vdcBoundaries.push({ name: vdcName, nodeIds, index: vi });
    });

    // ── Cross-VDC PCC bridging: merge PCC nodes sharing the same pccId ──
    // Find PCC nodes grouped by their underlying pccId
    const pccGroups = new Map(); // pccId → [node objects]
    mergedNodes.forEach(n => {
      if (n.type === 'pcc' && n.data?.pccId) {
        const pid = n.data.pccId;
        if (!pccGroups.has(pid)) pccGroups.set(pid, []);
        pccGroups.get(pid).push(n);
      }
    });

    // For each shared PCC (appearing in >1 VDC), keep one canonical node and repoint links
    const allRemoveIds = new Set();
    pccGroups.forEach((pccNodes, pccId) => {
      if (pccNodes.length <= 1) return; // only in one VDC, nothing to bridge

      const canonical = pccNodes[0]; // keep first as the shared node
      canonical._vdcName = 'Shared';  // mark as cross-VDC
      // Collect all VDC names this PCC spans
      const vdcNames = [...new Set(pccNodes.map(n => n._vdcName))];
      canonical.name = `PCC: ${vdcNames.join(' ↔ ')}`;

      // Add canonical to ALL VDC boundaries it spans
      pccNodes.forEach(n => {
        const boundary = vdcBoundaries.find(b => b.index === n._vdcIdx);
        if (boundary) boundary.nodeIds.add(canonical.id);
      });

      // Remove duplicate PCC nodes (all except canonical) and repoint their links
      for (let i = 1; i < pccNodes.length; i++) {
        const dup = pccNodes[i];
        allRemoveIds.add(dup.id);
        // Repoint links from duplicate to canonical
        mergedLinks.forEach(l => {
          if (l.source === dup.id) l.source = canonical.id;
          if (l.target === dup.id) l.target = canonical.id;
        });
      }
    });

    // Batch-remove duplicate PCC nodes in a single pass
    const cleanedNodes = allRemoveIds.size > 0
      ? mergedNodes.filter(n => !allRemoveIds.has(n.id))
      : mergedNodes;

    const mergedData = { nodes: cleanedNodes, links: mergedLinks, _vdcBoundaries: vdcBoundaries };
    renderGraph(mergedData);
    setTimeout(() => zoomFit(), 1500);
    toast(t('toast.loadedLocation', {dcCount: dcsInLoc.length, nodeCount: cleanedNodes.length}), 'success');
    updateAiButtonVisibility();

    // Update map background to show location region
    updateMapBackground(loc);

    // Load security groups for each VDC in background (non-blocking)
    // Merge all SG maps into one so detail panel works in location mode
    Promise.all(dcsInLoc.map(dc => fetchSecurityGroups(dc.id).catch(() => null))).then(results => {
      const mergedSgMap = new Map();
      results.forEach(data => {
        if (!data?.items) return;
        data.items.forEach(sg => {
          const rules = sg.entities?.rules?.items || [];
          mergedSgMap.set(sg.id, {
            name: sg.properties?.name || sg.id,
            description: sg.properties?.description || '',
            rules: rules.map(r => {
              const p = r.properties || {};
              return {
                name: p.name || '',
                protocol: p.protocol || 'ANY',
                direction: p.type || 'INGRESS',
                sourceIp: p.sourceIp || p.sourceCidr || '',
                targetIp: p.targetIp || p.targetCidr || '',
                sourceMac: p.sourceMac || '',
                icmpType: p.icmpType,
                icmpCode: p.icmpCode,
                portStart: p.portRangeStart,
                portEnd: p.portRangeEnd,
              };
            }),
          });
        });
      });
      if (graphData) graphData._securityGroups = mergedSgMap;
    });

    // Refresh IP block and DNS panels filtered to this location
    if (ipBlockData) renderIPBlockPanel(loc);
    if (dnsZones) { renderDNSPanel(); if (ipViewActive) enrichIPLabels(); }

  } catch (e) {
    toast(t('toast.locationFailed', {error: e.message}), 'error');
    console.error(e);
  } finally {
    hideLoading();
  }
}

// ============================== UTILITIES ==============================
function showLoading(text) {
  const overlay = document.getElementById('loadingOverlay');
  overlay.classList.add('active');
  overlay.classList.remove('fade-out');
  // Reset all checklist items
  overlay.querySelectorAll('.connect-loading-item').forEach(i => i.classList.remove('active', 'done'));
  const fill = document.getElementById('vdcLoadingProgressFill');
  if (fill) fill.style.width = '0%';
  // Set title from text if provided
  const title = document.getElementById('vdcLoadingTitle');
  if (title && text) title.textContent = text;
}
function setVdcLoadingStep(stepName) {
  const items = document.querySelectorAll('#vdcLoadingChecklist .connect-loading-item');
  const fill = document.getElementById('vdcLoadingProgressFill');
  let foundIdx = -1;
  items.forEach((item, i) => {
    if (item.dataset.step === stepName) foundIdx = i;
    item.classList.remove('active', 'done');
    if (foundIdx >= 0 && i < foundIdx) item.classList.add('done');
    else if (i === foundIdx) item.classList.add('active');
  });
  if (fill && foundIdx >= 0) fill.style.width = `${((foundIdx + 1) / items.length) * 100}%`;
}
function completeVdcLoadingStep(stepName) {
  const item = document.querySelector(`#vdcLoadingChecklist .connect-loading-item[data-step="${stepName}"]`);
  if (item) { item.classList.remove('active'); item.classList.add('done'); }
}
// Legacy compat — setLoadingText now maps to step names
function setLoadingText(text) {
  const sub = document.getElementById('vdcLoadingSubtitle');
  if (sub) sub.textContent = text;
}
function hideLoading() {
  const overlay = document.getElementById('loadingOverlay');
  if (!overlay) return;
  // Mark all done
  overlay.querySelectorAll('.connect-loading-item').forEach(i => { i.classList.remove('active'); i.classList.add('done'); });
  const fill = document.getElementById('vdcLoadingProgressFill');
  if (fill) fill.style.width = '100%';
  setTimeout(() => {
    overlay.classList.add('fade-out');
    setTimeout(() => { overlay.classList.remove('active', 'fade-out'); }, 500);
  }, 600);
}

let flPersistentToast = null;
function toast(message, type = 'info', persistent = false) {
  const container = document.getElementById('toastContainer');
  const el = document.createElement('div');
  el.className = `toast ${type}`;
  if (persistent) el.classList.add('toast-persistent');
  el.textContent = message;
  container.appendChild(el);
  if (persistent) {
    // Remove any previous persistent toast
    if (flPersistentToast && flPersistentToast.parentNode) flPersistentToast.remove();
    flPersistentToast = el;
  } else {
    setTimeout(() => el.remove(), 3000);
  }
}

function clearPersistentToast() {
  if (flPersistentToast && flPersistentToast.parentNode) {
    flPersistentToast.remove();
    flPersistentToast = null;
  }
}

function truncate(str, len) {
  if (!str) return '';
  return str.length > len ? str.substring(0, len - 1) + '\u2026' : str;
}

function formatRAM(mb) {
  if (!mb) return '?';
  if (mb >= 1024) return `${(mb / 1024).toFixed(mb % 1024 === 0 ? 0 : 1)} GB`;
  return `${mb} MB`;
}

const _escapeMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
const _escapeRe = /[&<>"']/g;
function escapeHtml(str) {
  if (typeof str !== 'string') return '';
  return str.replace(_escapeRe, c => _escapeMap[c]);
}

document.getElementById('tokenInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') connect();
});

// Show global map with all available IONOS DC locations on page load (before login)
// Show global map with all available IONOS DC locations on page load (before login)
(function initPreLoginMap() {
  initMapBackground();
  const el = document.getElementById('mapBackground');

  // Use overview-mode so the map is interactive (pointer-events, tooltips work)
  // pre-login class dims the map so the onboarding card stands out
  el.classList.add('overview-mode', 'pre-login');
  enableMapInteractions();

  // Hide topology SVG and toolbar (same as showMapOverview)
  document.getElementById('graphSvg').classList.add('hidden-for-map');
  document.getElementById('toolbar').style.display = 'none';

  // Show all DC locations as markers
  showAvailableLocations([]);
  bgMap.invalidateSize({ animate: false });
  const allCoords = Object.values(LOCATION_COORDS).map(c => [c[0], c[1]]);
  if (allCoords.length > 0) {
    bgMap.fitBounds(allCoords, { padding: [60, 60], maxZoom: 5, animate: false });
  }
  bgMap.setMaxBounds([[15, -140], [72, 45]]);
  bgMap.setMinZoom(2);
})();

// ============================== FEATURE CAROUSEL ==============================
(function initFeatureCarousel() {
  const track = document.getElementById('featureCarouselTrack');
  const dotsContainer = document.getElementById('featureCarouselDots');
  if (!track || !dotsContainer) return;
  const slides = track.querySelectorAll('.feature-slide');
  if (slides.length === 0) return;
  let current = 0;
  let interval = null;

  // Create dots
  slides.forEach((_, i) => {
    const dot = document.createElement('button');
    dot.className = 'feature-carousel-dot' + (i === 0 ? ' active' : '');
    dot.setAttribute('aria-label', `Feature ${i + 1}`);
    dot.addEventListener('click', () => goTo(i));
    dotsContainer.appendChild(dot);
  });

  function goTo(idx) {
    current = idx;
    track.style.transform = `translateX(-${current * 100}%)`;
    dotsContainer.querySelectorAll('.feature-carousel-dot').forEach((d, i) => {
      d.classList.toggle('active', i === current);
    });
  }

  function next() { goTo((current + 1) % slides.length); }

  function startAutoplay() { if (interval) clearInterval(interval); interval = setInterval(next, 4500); }
  function stopAutoplay() { if (interval) { clearInterval(interval); interval = null; } }

  // Auto-rotate, pause on hover
  startAutoplay();
  const carousel = document.getElementById('featureCarousel');
  carousel.addEventListener('mouseenter', stopAutoplay);
  carousel.addEventListener('mouseleave', startAutoplay);

  // Store stop function so connect() can kill it
  window._stopFeatureCarousel = stopAutoplay;
})();

// ============================== CONNECT LOADING SCREEN ==============================
function showConnectLoading() {
  const overlay = document.getElementById('connectLoadingOverlay');
  if (overlay) { overlay.classList.add('active'); overlay.classList.remove('fade-out'); }
}
function setConnectLoadingStep(stepName) {
  const items = document.querySelectorAll('.connect-loading-item');
  const fill = document.getElementById('connectLoadingProgressFill');
  let foundIdx = -1;
  items.forEach((item, i) => {
    const step = item.dataset.step;
    if (step === stepName) foundIdx = i;
    item.classList.remove('active', 'done');
    if (foundIdx >= 0 && i < foundIdx) item.classList.add('done');
    else if (i === foundIdx) item.classList.add('active');
  });
  if (fill && foundIdx >= 0) {
    fill.style.width = `${((foundIdx + 1) / items.length) * 100}%`;
  }
}
function completeConnectLoadingStep(stepName) {
  const item = document.querySelector(`.connect-loading-item[data-step="${stepName}"]`);
  if (item) { item.classList.remove('active'); item.classList.add('done'); }
}
function hideConnectLoading() {
  const overlay = document.getElementById('connectLoadingOverlay');
  if (!overlay) return;
  // Mark all done
  overlay.querySelectorAll('.connect-loading-item').forEach(i => { i.classList.remove('active'); i.classList.add('done'); });
  const fill = document.getElementById('connectLoadingProgressFill');
  if (fill) fill.style.width = '100%';
  // Fade out after a brief moment
  setTimeout(() => {
    overlay.classList.add('fade-out');
    setTimeout(() => { overlay.classList.remove('active', 'fade-out'); }, 500);
  }, 800);
}

// ============================== THEME INIT ==============================
currentTheme = detectTheme();
applyTheme(currentTheme);

// ============================== LOCALE INIT ==============================
currentLocale = detectLocale();
translatePage();
updateLocaleButtons();

// ============================== TRAFFIC HEATMAP ==============================
let heatmapActive = false;
let heatmapMode = 'volume'; // 'volume' or 'security'
let heatmapHaloGroup = null; // SVG group for halo elements

function toggleHeatmap() {
  if (heatmapActive) {
    clearHeatmap();
  } else {
    applyHeatmap();
  }
}

function setHeatmapMode(mode) {
  heatmapMode = mode;
  document.getElementById('hmModeVolume').classList.toggle('active', mode === 'volume');
  document.getElementById('hmModeSecurity').classList.toggle('active', mode === 'security');
  document.getElementById('hmModeBilling').classList.toggle('active', mode === 'billing');

  // Update legend title
  const hmTitle = document.getElementById('hmTitle');
  if (hmTitle) hmTitle.textContent = mode === 'billing' ? 'Data Transfer Heatmap' : 'Traffic Heatmap';

  // Update gradient
  const grad = document.getElementById('hmGradient');
  grad.className = 'heatmap-gradient ' + mode;
  const labels = document.getElementById('hmGradientLabels');
  if (mode === 'volume') {
    labels.innerHTML = '<span>0 B</span><span>Med</span><span>High</span>';
  } else if (mode === 'billing') {
    labels.innerHTML = '<span>0 GB</span><span>Med</span><span>High</span>';
  } else {
    labels.innerHTML = '<span>0% rejected</span><span>50%</span><span>100%</span>';
  }

  if (heatmapActive) applyHeatmap();
}

// Memoization cache for aggregateFlowData — invalidated when flow logs or graph change
let _hmAggCache = null;
let _hmAggCacheKey = '';
function invalidateHeatmapCache() { _hmAggCache = null; _hmAggCacheKey = ''; }

function aggregateFlowData() {
  // Memoize: only recompute when records count or graph changes
  const cacheKey = `${flAllRecords.length}|${graphData?.nodes?.length || 0}`;
  if (_hmAggCache && _hmAggCacheKey === cacheKey) return _hmAggCache;

  // Aggregate flow log records per NIC and per IP pair
  const nodeStats = new Map();  // nodeId -> {bytes, packets, accepted, rejected}
  const linkStats = new Map();  // "srcNodeId|tgtNodeId" -> {bytes, packets, accepted, rejected}

  if (!flAllRecords || !flAllRecords.length || !graphData || !graphData.nodes) return { nodeStats, linkStats };

  // Build lookup: IP -> nodeId, NIC -> nodeId
  const ipToNode = new Map();
  const nicToNode = new Map();
  graphData.nodes.forEach(n => {
    if (n.data?.nics) {
      n.data.nics.forEach(nic => {
        if (nic.nicId) nicToNode.set(nic.nicId, n.id);
        if (nic.ips) nic.ips.forEach(ip => ipToNode.set(ip, n.id));
      });
    }
    if (n.type === 'ipblock' && n.data?.ips) {
      n.data.ips.forEach(ip => ipToNode.set(ip, n.id));
    }
    if (n.type === 'nat' && n.data?.publicIps) {
      n.data.publicIps.forEach(ip => ipToNode.set(ip, n.id));
    }
  });

  // Initialize stats for all nodes
  graphData.nodes.forEach(n => {
    nodeStats.set(n.id, { bytes: 0, packets: 0, accepted: 0, rejected: 0 });
  });

  // Process each flow record
  flAllRecords.forEach(r => {
    // Find source and dest nodes
    const srcNodeId = nicToNode.get(r.interfaceId) || ipToNode.get(r.srcaddr);
    const dstNodeId = ipToNode.get(r.dstaddr);
    const isAccept = r.action === 'ACCEPT';

    // Update node stats
    if (srcNodeId && nodeStats.has(srcNodeId)) {
      const s = nodeStats.get(srcNodeId);
      s.bytes += r.bytes; s.packets += r.packets;
      if (isAccept) s.accepted++; else s.rejected++;
    }
    if (dstNodeId && nodeStats.has(dstNodeId)) {
      const s = nodeStats.get(dstNodeId);
      s.bytes += r.bytes; s.packets += r.packets;
      if (isAccept) s.accepted++; else s.rejected++;
    }

    // Update link stats (find if there's a direct or indirect link)
    if (srcNodeId && dstNodeId && srcNodeId !== dstNodeId) {
      const key = [srcNodeId, dstNodeId].sort().join('|');
      if (!linkStats.has(key)) linkStats.set(key, { bytes: 0, packets: 0, accepted: 0, rejected: 0 });
      const ls = linkStats.get(key);
      ls.bytes += r.bytes; ls.packets += r.packets;
      if (isAccept) ls.accepted++; else ls.rejected++;
    }
  });

  _hmAggCache = { nodeStats, linkStats };
  _hmAggCacheKey = cacheKey;
  return _hmAggCache;
}

function heatColor(value, mode) {
  // value: 0-1 normalized
  if (mode === 'security') {
    // Green (safe) -> Yellow (warning) -> Red (danger)
    if (value < 0.3) return `rgba(16, 185, 129, ${0.3 + value * 1.5})`;  // green
    if (value < 0.6) return `rgba(245, 158, 11, ${0.4 + value})`;         // yellow/amber
    return `rgba(239, 68, 68, ${0.5 + value * 0.5})`;                      // red
  }
  // Volume: cool blue -> cyan -> green -> amber -> red
  if (value < 0.2) return `rgba(17, 199, 230, ${0.2 + value * 2})`;
  if (value < 0.5) return `rgba(16, 185, 129, ${0.3 + value})`;
  if (value < 0.8) return `rgba(255, 170, 0, ${0.4 + value * 0.5})`;
  return `rgba(239, 68, 68, ${0.6 + value * 0.4})`;
}

function applyHeatmap() {
  if (heatmapMode === 'billing') {
    if (!_billingByServer || _billingByServer.size === 0) {
      toast('No data transfer data available — connect first', 'warning');
      return;
    }
  } else {
    if (!flAllRecords || !flAllRecords.length) {
      toast('Load flow log files first (press W)', 'warning');
      return;
    }
  }
  if (!graphData || !graphData.nodes || !graphData.nodes.length) {
    toast('Load a VDC first', 'warning');
    return;
  }

  heatmapActive = true;
  document.getElementById('heatmapLegend').classList.remove('hidden');

  // Billing mode uses billing API data instead of flow logs
  if (heatmapMode === 'billing') {
    applyBillingHeatmap();
    return;
  }

  const { nodeStats, linkStats } = aggregateFlowData();

  // Find max values for normalization
  let maxNodeBytes = 0, maxNodeRejectRatio = 0;
  nodeStats.forEach(s => {
    maxNodeBytes = Math.max(maxNodeBytes, s.bytes);
    const total = s.accepted + s.rejected;
    if (total > 10) maxNodeRejectRatio = Math.max(maxNodeRejectRatio, s.rejected / total);
  });
  if (maxNodeBytes === 0) maxNodeBytes = 1;
  if (maxNodeRejectRatio === 0) maxNodeRejectRatio = 1;

  let maxLinkBytes = 0;
  linkStats.forEach(s => { maxLinkBytes = Math.max(maxLinkBytes, s.bytes); });
  if (maxLinkBytes === 0) maxLinkBytes = 1;

  // Create halo group if not exists
  if (!heatmapHaloGroup && svgGroup) {
    heatmapHaloGroup = svgGroup.insert('g', '.nodes').attr('class', 'heatmap-halos');
  }

  // Clear previous halos
  if (heatmapHaloGroup) heatmapHaloGroup.selectAll('*').remove();

  // Apply node halos
  if (svgGroup) {
    graphData.nodes.forEach(n => {
      const stats = nodeStats.get(n.id);
      if (!stats || (stats.bytes === 0 && stats.accepted === 0 && stats.rejected === 0)) return;

      let intensity;
      if (heatmapMode === 'volume') {
        intensity = Math.sqrt(stats.bytes / maxNodeBytes); // sqrt for better distribution
      } else {
        const total = stats.accepted + stats.rejected;
        intensity = total > 10 ? (stats.rejected / total) / maxNodeRejectRatio : 0;
      }
      if (intensity < 0.02) return;

      const r = (NODE_TYPES[n.type]?.radius || 28) + 8 + intensity * 20;
      const color = heatColor(intensity, heatmapMode);

      if (heatmapHaloGroup) {
        heatmapHaloGroup.append('circle')
          .attr('class', 'hm-node-halo')
          .attr('data-node-id', n.id)
          .attr('cx', n.x).attr('cy', n.y)
          .attr('r', r)
          .attr('fill', color)
          .attr('opacity', 0.4 + intensity * 0.4)
          .attr('filter', 'url(#hmBlur)');
      }
    });

    // Apply link coloring/thickness
    svgGroup.selectAll('.link').each(function(d) {
      const sId = typeof d.source === 'object' ? d.source.id : d.source;
      const tId = typeof d.target === 'object' ? d.target.id : d.target;
      const key = [sId, tId].sort().join('|');
      const stats = linkStats.get(key);
      const el = d3.select(this);

      if (stats && stats.bytes > 0) {
        let intensity;
        if (heatmapMode === 'volume') {
          intensity = Math.sqrt(stats.bytes / maxLinkBytes);
        } else {
          const total = stats.accepted + stats.rejected;
          intensity = total > 5 ? stats.rejected / total : 0;
        }
        const color = heatColor(intensity, heatmapMode);
        el.attr('stroke', color).attr('stroke-width', 2 + intensity * 5).attr('opacity', 0.5 + intensity * 0.5);
      } else {
        // No traffic on this link — dim it
        el.attr('opacity', 0.15);
      }
    });
  }

  // Update legend stats
  let totalBytes = 0, totalPackets = 0, totalAccepted = 0, totalRejected = 0;
  let nodesWithTraffic = 0;
  nodeStats.forEach(s => {
    if (s.bytes > 0) nodesWithTraffic++;
    totalBytes += s.bytes; totalPackets += s.packets;
    totalAccepted += s.accepted; totalRejected += s.rejected;
  });
  // Deduplicate (each record counted on src+dst)
  totalBytes = Math.round(totalBytes / 2);
  totalPackets = Math.round(totalPackets / 2);

  const statsEl = document.getElementById('hmStats');
  const rejectPct = (totalAccepted + totalRejected) > 0 ? ((totalRejected / (totalAccepted + totalRejected)) * 100).toFixed(1) : '0';
  statsEl.innerHTML = `
    Nodes with traffic: <span>${nodesWithTraffic}</span> / ${graphData.nodes.length}<br>
    Total volume: <span>${formatFlowBytes(totalBytes)}</span> (${totalPackets.toLocaleString()} pkts)<br>
    Accepted: <span style="color:var(--success)">${totalAccepted.toLocaleString()}</span> &nbsp;
    Rejected: <span style="color:var(--danger)">${totalRejected.toLocaleString()}</span> (${rejectPct}%)
  `;

  // Update gradient labels with actual values
  const labels = document.getElementById('hmGradientLabels');
  if (heatmapMode === 'volume') {
    labels.innerHTML = `<span>0</span><span>${formatFlowBytes(maxNodeBytes / 2)}</span><span>${formatFlowBytes(maxNodeBytes)}</span>`;
  } else {
    labels.innerHTML = '<span>0% rejected</span><span>50%</span><span>100%</span>';
  }
}

function applyBillingHeatmap() {
  // Create halo group if not exists
  if (!heatmapHaloGroup && svgGroup) {
    heatmapHaloGroup = svgGroup.insert('g', '.nodes').attr('class', 'heatmap-halos');
  }
  if (heatmapHaloGroup) heatmapHaloGroup.selectAll('*').remove();

  // Map graph node IDs to billing server IDs and compute intensities
  let maxTotal = 0;
  const serverTraffic = new Map(); // graphNodeId → totalGB
  graphData.nodes.forEach(n => {
    if (n.type !== 'server' && n.type !== 'cube') return;
    const rawId = (n._origId || n.id).replace(/^srv-/, '');
    const billing = _billingByServer.get(rawId);
    if (!billing) return;
    const total = billing.totalIn + billing.totalOut;
    serverTraffic.set(n.id, total);
    maxTotal = Math.max(maxTotal, total);
  });
  if (maxTotal === 0) maxTotal = 1;

  // Apply node halos
  let nodesWithData = 0;
  let totalInAll = 0, totalOutAll = 0;
  if (svgGroup) {
    graphData.nodes.forEach(n => {
      const total = serverTraffic.get(n.id);
      if (!total || total === 0) return;
      nodesWithData++;

      const rawId = (n._origId || n.id).replace(/^srv-/, '');
      const billing = _billingByServer.get(rawId);
      if (billing) { totalInAll += billing.totalIn; totalOutAll += billing.totalOut; }

      const intensity = Math.sqrt(total / maxTotal);
      if (intensity < 0.02) return;
      const r = (NODE_TYPES[n.type]?.radius || 28) + 8 + intensity * 20;
      const color = heatColor(intensity, 'volume'); // use volume gradient for billing

      if (heatmapHaloGroup) {
        heatmapHaloGroup.append('circle')
          .attr('class', 'hm-node-halo')
          .attr('data-node-id', n.id)
          .attr('cx', n.x).attr('cy', n.y)
          .attr('r', r)
          .attr('fill', color)
          .attr('opacity', 0.4 + intensity * 0.4)
          .attr('filter', 'url(#hmBlur)');
      }
    });

    // Dim links with no associated billing data
    svgGroup.selectAll('.link').each(function() {
      d3.select(this).attr('opacity', 0.15);
    });
  }

  // Update legend stats
  const statsEl = document.getElementById('hmStats');
  statsEl.innerHTML = `
    Servers with data: <span>${nodesWithData}</span> / ${graphData.nodes.filter(n => n.type === 'server' || n.type === 'cube').length}<br>
    Total inbound: <span style="color:var(--success)">${totalInAll.toFixed(2)} GB</span><br>
    Total outbound: <span style="color:var(--warning)">${totalOutAll.toFixed(2)} GB</span>
  `;

  // Update gradient labels
  const labels = document.getElementById('hmGradientLabels');
  labels.innerHTML = `<span>0 GB</span><span>${(maxTotal / 2).toFixed(1)} GB</span><span>${maxTotal.toFixed(1)} GB</span>`;
}

function updateHeatmapHalos() {
  if (!heatmapActive || !heatmapHaloGroup || !graphData) return;
  // Use pre-built nodeMap (O(1) lookup) instead of .find() (O(n)) per halo
  const nodeMap = graphData._nodeMap || new Map(graphData.nodes.map(n => [n.id, n]));
  heatmapHaloGroup.selectAll('.hm-node-halo').each(function() {
    const el = d3.select(this);
    const node = nodeMap.get(el.attr('data-node-id'));
    if (node) {
      el.attr('cx', node.x).attr('cy', node.y);
    }
  });
}

function clearHeatmap() {
  heatmapActive = false;
  document.getElementById('heatmapLegend')?.classList.add('hidden');

  // Remove halos
  if (heatmapHaloGroup) {
    heatmapHaloGroup.selectAll('*').remove();
  }

  // Restore link styles
  if (svgGroup) {
    svgGroup.selectAll('.link')
      .attr('stroke', function(d) {
        const lt = LINK_TYPES[d.linkType];
        if (lt) return lt.color;
        const srcNode = typeof d.source === 'object' ? d.source : null;
        return NODE_TYPES[srcNode?.type]?.color || '#475569';
      })
      .attr('stroke-width', null)
      .attr('opacity', null);
  }
}

// ============================== FLOW LOG EXPLORER ==============================
const PROTO_MAP = { 1: 'ICMP', 6: 'TCP', 17: 'UDP', 47: 'GRE', 50: 'ESP', 58: 'ICMPv6' };

// Well-known port labels for flow log enrichment
const WELL_KNOWN_PORTS = {
  20: 'FTP-D', 21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
  53: 'DNS', 67: 'DHCP', 68: 'DHCP', 80: 'HTTP', 110: 'POP3',
  123: 'NTP', 143: 'IMAP', 161: 'SNMP', 162: 'SNMP', 443: 'HTTPS',
  445: 'SMB', 465: 'SMTPS', 514: 'Syslog', 587: 'SMTP',
  993: 'IMAPS', 995: 'POP3S', 1433: 'MSSQL', 1521: 'Oracle',
  3306: 'MySQL', 3389: 'RDP', 5432: 'Postgres', 5672: 'AMQP',
  5900: 'VNC', 6379: 'Redis', 8080: 'HTTP-Alt', 8443: 'HTTPS-Alt',
  9090: 'Prometheus', 9200: 'Elastic', 27017: 'MongoDB',
};

// Ports commonly targeted by scanners/bots — used for threat flagging
const THREAT_PORTS = new Set([
  23, 445, 1433, 3389, 5900, // Telnet, SMB, MSSQL, RDP, VNC
]);

// Resolve an IP to a topology resource tag (O(1) lookup)
function resolveIpTag(ip) {
  if (!graphData?._ipToNodes) return null;
  const nodeIds = graphData._ipToNodes.get(ip);
  if (!nodeIds || nodeIds.size === 0) return null;
  const nodeMap = graphData._nodeMap;
  if (!nodeMap) return null;
  const firstId = nodeIds.values().next().value;
  const node = nodeMap.get(firstId);
  if (!node) return null;
  const typeInfo = NODE_TYPES[node.type];
  return {
    name: node.name || node.id,
    type: node.type,
    label: typeInfo?.label || node.type,
    color: typeInfo?.color || '#94a3b8',
  };
}

// Check if an IP+port combo looks like a scan/bot attempt
function isExternalThreatCandidate(ip, port, proto) {
  if (!ip) return false;
  // If IP belongs to our infrastructure, it's not a threat
  if (graphData?._ipToNodes?.has(ip)) return false;
  // ICMP from external IPs is a common probe/scan
  if (proto === 1 || proto === 58) return true; // ICMP / ICMPv6
  return port && THREAT_PORTS.has(port);
}

// Check if an IP is external (not in loaded topology)
function isExternalIp(ip) {
  if (!ip || !graphData?._ipToNodes) return false;
  return !graphData._ipToNodes.has(ip);
}

// Render enriched IP cell with resource tag
function enrichIpCell(ip, action) {
  if (!ip) return '-';
  let html = escapeHtml(ip);
  const tag = resolveIpTag(ip);
  if (tag) {
    const shortName = tag.name.length > 20 ? tag.name.substring(0, 18) + '..' : tag.name;
    html += ` <span class="fl-ip-tag" style="background:${tag.color}22;color:${tag.color}">${escapeHtml(tag.label)}: ${escapeHtml(shortName)}</span>`;
  } else if (action === 'REJECT' && isExternalIp(ip)) {
    html += ' <span class="fl-ip-tag" style="background:rgba(248,113,113,0.12);color:#f87171">External</span>';
  }
  return html;
}

// Resolve NIC UUID to server name
function resolveNicLabel(nicId) {
  if (!nicId || !graphData?._nicToNode || !graphData?._nodeMap) return null;
  const nodeId = graphData._nicToNode.get(nicId);
  if (!nodeId) return null;
  const node = graphData._nodeMap.get(nodeId);
  if (!node) return null;
  return node.name || null;
}

// Render enriched port cell with service label and threat badge
function enrichPortCell(port, ip, action, proto) {
  let html = port ? String(port) : '-';
  if (port) {
    const label = WELL_KNOWN_PORTS[port];
    if (label) {
      html += ` <span class="fl-port-label">${escapeHtml(label)}</span>`;
    }
  }
  if (isExternalThreatCandidate(ip, port, proto) && action === 'REJECT') {
    html += ' <span class="fl-threat-badge">\u26A0 Scan</span>';
  }
  return html;
}

// Render enriched NIC cell with server name + full NIC UUID
function enrichNicCell(nicId) {
  if (!nicId) return '-';
  const serverName = resolveNicLabel(nicId);
  if (serverName) {
    const shortServer = serverName.length > 18 ? serverName.substring(0, 16) + '..' : serverName;
    return `<span>${escapeHtml(shortServer)}</span> <span class="fl-nic-id">${escapeHtml(nicId)}</span>`;
  }
  return `<span class="fl-nic-id">${escapeHtml(nicId)}</span>`;
}

// ---- Flow Log Context Menu ----
let flCtxRecord = null; // the record for the currently open context menu

function showFlContextMenu(e, record, targetDoc) {
  e.preventDefault();
  e.stopPropagation(); // prevent document click listener from immediately hiding menu

  // Determine which document the menu is in (parent or popout)
  const doc = targetDoc || document;
  const menuId = doc === document ? 'flContextMenu' : 'poContextMenu';
  const menu = doc.getElementById(menuId);
  if (!menu) return;

  // Hide any other open context menu first (this nulls flCtxRecord)
  hideFlContextMenu();

  // Set record AFTER hide so it doesn't get nulled out
  flCtxRecord = record;

  // Position near cursor, but keep within viewport
  const win = doc.defaultView || window;
  const mx = Math.min(e.clientX, win.innerWidth - 220);
  const my = Math.min(e.clientY, win.innerHeight - 280);
  menu.style.left = mx + 'px';
  menu.style.top = my + 'px';
  menu.classList.add('visible');
  menu._activeDoc = doc; // track which doc owns this menu
}

function hideFlContextMenu() {
  // Hide in both parent and popout
  const menu1 = document.getElementById('flContextMenu');
  if (menu1) menu1.classList.remove('visible');
  if (flPopoutWindow && !flPopoutWindow.closed) {
    const menu2 = flPopoutWindow.document.getElementById('poContextMenu');
    if (menu2) menu2.classList.remove('visible');
  }
  flCtxRecord = null;
}

// Copy text to clipboard with toast feedback
function flCopyToClipboard(text, label) {
  navigator.clipboard.writeText(text).then(() => {
    toast('Copied ' + label, 'info', true);
  }).catch(() => {
    // Fallback for older browsers
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.cssText = 'position:fixed;left:-9999px';
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    toast('Copied ' + label, 'info', true);
  });
}

// Handle context menu actions
function handleFlCtxAction(action) {
  if (!flCtxRecord) { console.warn('[FlowLog] No record for context action:', action); return; }
  // Save reference before hideFlContextMenu nulls flCtxRecord
  const r = flCtxRecord;
  const proto = PROTO_MAP[r.protocol] || r.protocol;
  const time = r.start ? new Date(r.start * 1000).toLocaleString() : '-';

  switch (action) {
    case 'copy-row': {
      const srcTag = resolveIpTag(r.srcaddr);
      const dstTag = resolveIpTag(r.dstaddr);
      const srcLabel = srcTag ? ` (${srcTag.label}: ${srcTag.name})` : '';
      const dstLabel = dstTag ? ` (${dstTag.label}: ${dstTag.name})` : '';
      const srcPortLabel = WELL_KNOWN_PORTS[r.srcport] ? ` ${WELL_KNOWN_PORTS[r.srcport]}` : '';
      const dstPortLabel = WELL_KNOWN_PORTS[r.dstport] ? ` ${WELL_KNOWN_PORTS[r.dstport]}` : '';
      const text = `${time}\t${r.srcaddr}${srcLabel}\t${r.srcport || '-'}${srcPortLabel}\t${r.dstaddr}${dstLabel}\t${r.dstport || '-'}${dstPortLabel}\t${proto}\t${r.packets}\t${r.bytes}\t${r.action}\t${r.interfaceId || '-'}`;
      flCopyToClipboard(text, 'row');
      break;
    }
    case 'copy-src-ip':
      flCopyToClipboard(r.srcaddr || '', 'source IP');
      break;
    case 'copy-dst-ip':
      flCopyToClipboard(r.dstaddr || '', 'dest IP');
      break;
    case 'copy-nic':
      flCopyToClipboard(r.interfaceId || '', 'NIC UUID');
      break;
    case 'copy-json': {
      const obj = {
        time, srcaddr: r.srcaddr, srcport: r.srcport, dstaddr: r.dstaddr,
        dstport: r.dstport, protocol: proto, packets: r.packets,
        bytes: r.bytes, action: r.action, interfaceId: r.interfaceId,
      };
      const srcTag = resolveIpTag(r.srcaddr);
      const dstTag = resolveIpTag(r.dstaddr);
      if (srcTag) obj.srcResource = `${srcTag.label}: ${srcTag.name}`;
      if (dstTag) obj.dstResource = `${dstTag.label}: ${dstTag.name}`;
      if (WELL_KNOWN_PORTS[r.srcport]) obj.srcService = WELL_KNOWN_PORTS[r.srcport];
      if (WELL_KNOWN_PORTS[r.dstport]) obj.dstService = WELL_KNOWN_PORTS[r.dstport];
      flCopyToClipboard(JSON.stringify(obj, null, 2), 'JSON');
      break;
    }
    case 'filter-src': {
      const input = document.getElementById('flFilterSrc');
      if (input) { input.value = r.srcaddr || ''; filterFlowLogs(); }
      break;
    }
    case 'filter-dst': {
      const input = document.getElementById('flFilterDst');
      if (input) { input.value = r.dstaddr || ''; filterFlowLogs(); }
      break;
    }
  }
  hideFlContextMenu();
}

// Wire context menu using event delegation (handles both menus)
document.getElementById('flContextMenu')?.addEventListener('click', (e) => {
  e.stopPropagation();
  const item = e.target.closest('.fl-ctx-item[data-action]');
  if (item) handleFlCtxAction(item.dataset.action);
});

// Dismiss context menu on click elsewhere or Escape
document.addEventListener('click', (e) => {
  if (!e.target.closest('.fl-context-menu')) hideFlContextMenu();
});
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') hideFlContextMenu();
});

let flAllRecords = [];      // all parsed flow log records
let flFilteredRecords = []; // after filtering
let flFiles = [];           // loaded file metadata: {name, nicId, timestamp, recordCount}
let flSortCol = 'start';
let flSortDir = 'desc';
let flPage = 0;
const FL_PAGE_SIZE = 500;
let flFilterTimeout = null;

let flDocked = false; // dock state

function openFlowLogExplorer() {
  const overlay = document.getElementById('flowlogOverlay');
  const dialog = document.getElementById('flowlogDialog');
  overlay.style.display = '';

  // Restore dock preference
  const savedDock = localStorage.getItem('fl-docked');
  flDocked = savedDock === '1';

  if (flDocked) {
    dialog.classList.add('fl-docked');
    dialog.classList.remove('fl-dragged');
    dialog.style.top = ''; dialog.style.left = ''; dialog.style.transform = '';
    // Restore saved height
    const savedH = localStorage.getItem('fl-dock-height');
    if (savedH) dialog.style.height = savedH;
  } else {
    dialog.classList.remove('fl-docked');
    dialog.classList.remove('fl-dragged');
    dialog.style.top = '50%'; dialog.style.left = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.height = '';
  }
  updateDockButton();
  setupFlowLogDropzone();
  setupFlowLogDrag();
  setupFlDockResize();
}

function toggleFlowLogDock() {
  const dialog = document.getElementById('flowlogDialog');
  flDocked = !flDocked;
  localStorage.setItem('fl-docked', flDocked ? '1' : '0');

  if (flDocked) {
    dialog.classList.add('fl-docked');
    dialog.classList.remove('fl-dragged');
    dialog.style.top = ''; dialog.style.left = ''; dialog.style.transform = '';
    const savedH = localStorage.getItem('fl-dock-height');
    if (savedH) dialog.style.height = savedH;
  } else {
    dialog.classList.remove('fl-docked');
    dialog.classList.remove('fl-dragged');
    dialog.style.top = '50%'; dialog.style.left = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.height = '';
  }
  updateDockButton();
}

function updateDockButton() {
  const btn = document.getElementById('flDockBtn');
  if (!btn) return;
  if (flDocked) {
    btn.title = 'Float (restore centered dialog)';
    btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="2" width="10" height="10" rx="2"/><path d="M3 8h10"/></svg>';
  } else {
    btn.title = 'Dock to bottom (see map while browsing)';
    btn.innerHTML = '<svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="1" y="1" width="14" height="14" rx="2"/><line x1="1" y1="9" x2="15" y2="9"/></svg>';
  }
}

// Top-edge resize for docked mode
let flDockResizeState = null;
function setupFlDockResize() {
  const handle = document.getElementById('flDockResize');
  const dialog = document.getElementById('flowlogDialog');
  if (!handle || handle._bound) return;
  handle._bound = true;

  handle.addEventListener('mousedown', (e) => {
    if (!flDocked) return;
    e.preventDefault();
    const rect = dialog.getBoundingClientRect();
    flDockResizeState = { startY: e.clientY, origHeight: rect.height };
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
  });
  document.addEventListener('mousemove', (e) => {
    if (!flDockResizeState) return;
    const dy = flDockResizeState.startY - e.clientY;
    const newH = Math.max(200, Math.min(window.innerHeight * 0.85, flDockResizeState.origHeight + dy));
    dialog.style.height = newH + 'px';
  });
  document.addEventListener('mouseup', () => {
    if (!flDockResizeState) return;
    localStorage.setItem('fl-dock-height', dialog.style.height);
    flDockResizeState = null;
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });
}

function closeFlowLogExplorer() {
  document.getElementById('flowlogOverlay').style.display = 'none';
  // Also close popout if open
  if (flPopoutWindow && !flPopoutWindow.closed) {
    flPopoutWindow.close();
  }
  flPopoutWindow = null;
}

// ---- Pop-out to separate window ----
let flPopoutWindow = null;

function popOutFlowLogExplorer() {
  if (flPopoutWindow && !flPopoutWindow.closed) {
    flPopoutWindow.focus();
    return;
  }

  const theme = document.documentElement.getAttribute('data-theme') || 'dark';

  const w = window.open('', 'FlowLogExplorer', 'width=1100,height=600,menubar=no,toolbar=no,location=no,status=no');
  if (!w) {
    toast('Pop-up blocked — please allow pop-ups for this page', 'warning');
    return;
  }
  flPopoutWindow = w;

  // Close the inline explorer
  document.getElementById('flowlogOverlay').style.display = 'none';

  // Build the popout document
  w.document.write(buildPopoutHTML(theme));
  w.document.close();

  // When popout closes, restore inline
  w.addEventListener('beforeunload', () => {
    flPopoutWindow = null;
  });

  // Wire all popout controls from the PARENT context
  // This avoids window.opener issues — all handlers run in the parent's scope
  setTimeout(() => {
    if (!w || w.closed) return;
    const d = w.document;

    // Filter inputs — sync to parent DOM then trigger filterFlowLogs
    let poFilterTimeout = null;
    const syncAndFilter = () => {
      clearTimeout(poFilterTimeout);
      poFilterTimeout = setTimeout(() => {
        if (w.closed) return;
        const map = [
          ['flSearch', 'poSearch'], ['flFilterAction', 'poFilterAction'],
          ['flFilterProto', 'poFilterProto'], ['flFilterSrc', 'poFilterSrc'],
          ['flFilterDst', 'poFilterDst'], ['flFilterPort', 'poFilterPort'],
          ['flFilterNic', 'poFilterNic'],
        ];
        map.forEach(([pid, lid]) => {
          const pe = document.getElementById(pid);
          const le = d.getElementById(lid);
          if (pe && le) pe.value = le.value;
        });
        filterFlowLogs();
      }, 150);
    };

    // Attach input/change listeners on filter elements
    ['poSearch', 'poFilterSrc', 'poFilterDst', 'poFilterPort'].forEach(id => {
      const el = d.getElementById(id);
      if (el) el.addEventListener('input', syncAndFilter);
    });
    ['poFilterAction', 'poFilterProto', 'poFilterNic'].forEach(id => {
      const el = d.getElementById(id);
      if (el) el.addEventListener('change', syncAndFilter);
    });

    // Buttons
    d.querySelector('[data-action="add-files"]')?.addEventListener('click', () => {
      document.getElementById('flFileInput').click();
    });
    d.querySelector('[data-action="export-csv"]')?.addEventListener('click', () => exportFlowLogCSV());
    d.querySelector('[data-action="clear"]')?.addEventListener('click', () => clearFlowLogs());

    // Pagination
    d.getElementById('poPrevBtn')?.addEventListener('click', () => flPagePrev());
    d.getElementById('poNextBtn')?.addEventListener('click', () => flPageNext());

    // Sync NIC filter options
    const parentNic = document.getElementById('flFilterNic');
    const popoutNic = d.getElementById('poFilterNic');
    if (parentNic && popoutNic) popoutNic.innerHTML = parentNic.innerHTML;

    // Connection checker
    const hint = d.querySelector('.po-connection-hint');
    const checkInterval = setInterval(() => {
      if (w.closed) { clearInterval(checkInterval); return; }
      if (!window || window.closed) {
        if (hint) {
          hint.textContent = 'Main window closed \u2014 reopen from app';
          hint.style.color = 'var(--danger)';
          hint.style.opacity = '1';
        }
      }
    }, 2000);

    // Wire popout context menu using event delegation
    const poCtx = d.getElementById('poContextMenu');
    if (poCtx) {
      poCtx.addEventListener('click', (e) => {
        e.stopPropagation();
        const item = e.target.closest('.fl-ctx-item[data-action]');
        if (item) handleFlCtxAction(item.dataset.action);
      });
      // Dismiss on click elsewhere
      d.addEventListener('click', (e) => {
        if (!e.target.closest('.fl-context-menu')) {
          poCtx.classList.remove('visible');
        }
      });
      d.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') poCtx.classList.remove('visible');
      });
    }

    // Render the table
    renderPopoutTable();
  }, 50);
}

function buildPopoutHTML(theme) {
  return `<!DOCTYPE html>
<html lang="en" data-theme="${theme}">
<head>
<meta charset="UTF-8">
<title>Flow Log Explorer</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-primary: #001B41; --bg-secondary: #00264d; --bg-tertiary: #003366;
    --bg-hover: #004080; --text-primary: #f1f5f9; --text-secondary: #a0c4e8;
    --text-muted: #6a9ec8; --border: #1a4a7a; --accent: #11C7E6;
    --accent-hover: #0ea8c4; --success: #10b981; --warning: #FFAA00; --danger: #ef4444;
  }
  html[data-theme="light"] {
    --bg-primary: #ffffff; --bg-secondary: #f8f9fa; --bg-tertiary: #e8ecf1;
    --bg-hover: #e0e8f0; --text-primary: #0f172a; --text-secondary: #1e293b;
    --text-muted: #64748b; --border: #cbd5e1; --accent: #0284c7;
    --accent-hover: #0369a1;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg-primary); color: var(--text-primary);
    display: flex; flex-direction: column; height: 100vh; overflow: hidden;
  }
  .po-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 12px 20px; border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, rgba(17,199,230,0.06) 0%, transparent 100%);
    flex-shrink: 0;
  }
  .po-header h2 { font-size: 15px; font-weight: 700; display: flex; align-items: center; gap: 8px; }
  .po-header h2 svg { flex-shrink: 0; }
  .po-header .fl-count { font-size: 12px; font-weight: 500; color: var(--text-muted); }
  .po-controls { display: flex; align-items: center; gap: 8px; }
  .po-controls input[type="text"] {
    width: 180px; padding: 6px 10px; font-size: 12px; border: 1px solid var(--border);
    border-radius: 6px; background: var(--bg-tertiary); color: var(--text-primary);
    font-family: inherit; outline: none;
  }
  .po-controls input[type="text"]:focus { border-color: var(--accent); }
  .fl-btn {
    padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 600;
    cursor: pointer; border: 1px solid var(--border); background: var(--bg-tertiary);
    color: var(--text-secondary); transition: all 0.15s; font-family: inherit;
  }
  .fl-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
  .fl-btn-accent { background: rgba(17,199,230,0.15); color: var(--accent); border-color: rgba(17,199,230,0.3); }
  .fl-btn-accent:hover { background: rgba(17,199,230,0.25); }
  .po-filters {
    display: flex; flex-wrap: wrap; align-items: center; gap: 6px;
    padding: 10px 20px; border-bottom: 1px solid var(--border); font-size: 12px; flex-shrink: 0;
  }
  .po-filters label { font-size: 11px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.3px; white-space: nowrap; }
  .po-filters select, .po-filters input[type="text"] {
    padding: 4px 8px; font-size: 12px; border: 1px solid var(--border); border-radius: 4px;
    background: var(--bg-tertiary); color: var(--text-primary); font-family: inherit; outline: none;
  }
  .po-filters select { min-width: 80px; }
  .po-filters input[type="text"] { width: 120px; }
  .fl-filter-sep { width: 1px; height: 20px; background: var(--border); margin: 0 4px; }
  .po-body { flex: 1; overflow: auto; min-height: 0; }
  .fl-table { min-width: 1100px; width: 100%; border-collapse: collapse; font-size: 12px; }
  .fl-table thead { position: sticky; top: 0; z-index: 2; }
  .fl-table th {
    padding: 8px 10px; text-align: left; font-weight: 600; font-size: 11px;
    text-transform: uppercase; letter-spacing: 0.3px; color: var(--text-muted);
    background: var(--bg-tertiary); border-bottom: 1px solid var(--border);
    white-space: nowrap; cursor: pointer; user-select: none;
  }
  .fl-table th:hover { color: var(--text-primary); }
  .fl-table th .sort-arrow { margin-left: 4px; font-size: 9px; }
  .fl-table td {
    padding: 6px 10px; border-bottom: 1px solid var(--bg-tertiary);
    color: var(--text-secondary); white-space: nowrap;
    font-family: 'SF Mono', 'Consolas', 'Monaco', monospace; font-size: 11px;
  }
  .fl-table tr { cursor: pointer; }
  .fl-table tr:hover td { background: var(--bg-hover); }
  .fl-table tr.fl-row-reject td { color: #f87171; }
  .fl-table tr.fl-row-highlighted td { background: rgba(17,199,230,0.1); }
  .fl-table .fl-action-accept { color: var(--success); font-weight: 600; }
  .fl-table .fl-action-reject { color: var(--danger); font-weight: 600; }
  .fl-table .fl-proto { color: var(--accent); }
  .fl-table .fl-empty { text-align: center; padding: 40px; color: var(--text-muted); font-family: inherit; font-style: italic; }
  .fl-table td:nth-child(2), .fl-table td:nth-child(4) { white-space: nowrap; }
  .fl-ip-tag { display: inline-block; font-size: 9px; padding: 1px 5px; border-radius: 3px; margin-left: 4px; font-weight: 600; vertical-align: middle; opacity: 0.9; }
  .fl-port-label { display: inline-block; font-size: 9px; color: var(--text-muted); margin-left: 3px; font-style: italic; }
  .fl-threat-badge { display: inline-block; font-size: 9px; padding: 1px 5px; border-radius: 3px; background: rgba(248,113,113,0.15); color: #f87171; font-weight: 600; margin-left: 4px; }
  .fl-nic-id { font-size: 9px; color: var(--text-muted); opacity: 0.7; margin-left: 2px; }
  .fl-table td:last-child { white-space: nowrap; }
  .fl-context-menu {
    position: fixed; z-index: 10000; min-width: 200px;
    background: var(--bg-secondary); border: 1px solid var(--border);
    border-radius: 8px; padding: 4px 0; box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    font-size: 12px; font-family: 'Inter', sans-serif; display: none;
  }
  .fl-context-menu.visible { display: block; }
  .fl-ctx-item {
    padding: 7px 14px; cursor: pointer; color: var(--text-secondary);
    display: flex; align-items: center; gap: 8px; transition: background 0.1s;
  }
  .fl-ctx-item:hover { background: var(--bg-hover); color: var(--text-primary); }
  .fl-ctx-item svg { flex-shrink: 0; opacity: 0.6; }
  .fl-ctx-sep { height: 1px; background: var(--border); margin: 4px 0; }
  .po-footer {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 20px; border-top: 1px solid var(--border); font-size: 12px;
    color: var(--text-muted); flex-shrink: 0;
  }
  .po-footer .fl-stats { display: flex; gap: 16px; }
  .fl-stat-label { color: var(--text-muted); }
  .fl-stat-value { font-weight: 600; color: var(--text-secondary); margin-left: 4px; }
  .fl-stat-accept { color: var(--success) !important; }
  .fl-stat-reject { color: var(--danger) !important; }
  .fl-page-controls { display: flex; align-items: center; gap: 6px; }
  .fl-page-controls button {
    padding: 3px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;
    background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border); font-family: inherit;
  }
  .fl-page-controls button:hover { background: var(--bg-hover); }
  .fl-page-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
  .po-connection-hint {
    position: fixed; bottom: 8px; right: 12px; font-size: 10px; color: var(--text-muted); opacity: 0.5;
  }
</style>
</head>
<body>
  <div class="po-header">
    <h2>
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg>
      Flow Log Explorer
      <span class="fl-count" id="poRecordCount"></span>
    </h2>
    <div class="po-controls">
      <input type="text" id="poSearch" placeholder="Search IPs, ports...">
      <button class="fl-btn fl-btn-accent" data-action="add-files">+ Add Files</button>
      <button class="fl-btn" data-action="export-csv" id="poExportBtn">&#8681; CSV</button>
      <button class="fl-btn" data-action="clear">Clear</button>
    </div>
  </div>
  <div class="po-filters" id="poFilters">
    <label>Action:</label>
    <select id="poFilterAction">
      <option value="">All</option><option value="ACCEPT">ACCEPT</option><option value="REJECT">REJECT</option>
    </select>
    <span class="fl-filter-sep"></span>
    <label>Protocol:</label>
    <select id="poFilterProto">
      <option value="">All</option><option value="6">TCP (6)</option><option value="17">UDP (17)</option><option value="1">ICMP (1)</option>
    </select>
    <span class="fl-filter-sep"></span>
    <label>Src IP:</label>
    <input type="text" id="poFilterSrc" placeholder="e.g. 10.0.0">
    <span class="fl-filter-sep"></span>
    <label>Dst IP:</label>
    <input type="text" id="poFilterDst" placeholder="e.g. 192.168">
    <span class="fl-filter-sep"></span>
    <label>Port:</label>
    <input type="text" id="poFilterPort" placeholder="e.g. 443" style="width:70px;">
    <span class="fl-filter-sep"></span>
    <label>NIC:</label>
    <select id="poFilterNic">
      <option value="">All NICs</option>
    </select>
  </div>
  <div class="po-body" id="poBody"></div>
  <div class="fl-context-menu" id="poContextMenu">
    <div class="fl-ctx-item" data-action="copy-row"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy Row</div>
    <div class="fl-ctx-item" data-action="copy-src-ip"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy Source IP</div>
    <div class="fl-ctx-item" data-action="copy-dst-ip"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy Dest IP</div>
    <div class="fl-ctx-item" data-action="copy-nic"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="5" y="5" width="9" height="9" rx="1.5"/><path d="M5 11H3.5A1.5 1.5 0 012 9.5v-7A1.5 1.5 0 013.5 1h7A1.5 1.5 0 0112 2.5V5"/></svg>Copy NIC UUID</div>
    <div class="fl-ctx-sep"></div>
    <div class="fl-ctx-item" data-action="copy-json"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2h5l4 4v8a1 1 0 01-1 1H4a1 1 0 01-1-1V3a1 1 0 011-1z"/><path d="M9 2v4h4"/></svg>Copy as JSON</div>
    <div class="fl-ctx-item" data-action="filter-src"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M1 3h14M3 7h10M5 11h6"/></svg>Filter by Source IP</div>
    <div class="fl-ctx-item" data-action="filter-dst"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M1 3h14M3 7h10M5 11h6"/></svg>Filter by Dest IP</div>
  </div>
  <div class="po-footer">
    <div class="fl-stats">
      <span><span class="fl-stat-label">Records:</span><span class="fl-stat-value" id="poStatTotal">0</span></span>
      <span><span class="fl-stat-label">Accepted:</span><span class="fl-stat-value fl-stat-accept" id="poStatAccept">0</span></span>
      <span><span class="fl-stat-label">Rejected:</span><span class="fl-stat-value fl-stat-reject" id="poStatReject">0</span></span>
      <span><span class="fl-stat-label">Files:</span><span class="fl-stat-value" id="poStatFiles">0</span></span>
      <span><span class="fl-stat-label">Shown:</span><span class="fl-stat-value" id="poStatShown">0</span></span>
    </div>
    <div class="fl-page-controls">
      <button id="poPrevBtn" disabled>&laquo; Prev</button>
      <span id="poPageInfo">Page 1</span>
      <button id="poNextBtn">Next &raquo;</button>
    </div>
  </div>
  <div class="po-connection-hint">Connected to main window &bull; hover to highlight on map</div>
</body>
</html>`;
}

function renderPopoutTable() {
  const w = flPopoutWindow;
  if (!w || w.closed) return;

  const body = w.document.getElementById('poBody');
  if (!body) return;

  const cols = [
    { key: 'start', label: 'Time' },
    { key: 'srcaddr', label: 'Source IP' },
    { key: 'srcport', label: 'Src Port' },
    { key: 'dstaddr', label: 'Dest IP' },
    { key: 'dstport', label: 'Dst Port' },
    { key: 'protocol', label: 'Proto' },
    { key: 'packets', label: 'Packets' },
    { key: 'bytes', label: 'Bytes' },
    { key: 'action', label: 'Action' },
    { key: 'interfaceId', label: 'Server / NIC' },
  ];

  const parts = ['<table class="fl-table"><thead><tr>'];
  for (let c = 0; c < cols.length; c++) {
    const col = cols[c];
    const isSorted = flSortCol === col.key;
    const arrow = isSorted ? (flSortDir === 'asc' ? '\u25B2' : '\u25BC') : '\u25B8';
    parts.push(`<th data-col="${col.key}">${col.label}<span class="sort-arrow">${arrow}</span></th>`);
  }
  parts.push('</tr></thead><tbody>');

  const startIdx = flPage * FL_PAGE_SIZE;
  const pageRows = flFilteredRecords.slice(startIdx, startIdx + FL_PAGE_SIZE);

  if (pageRows.length === 0) {
    parts.push(`<tr><td colspan="${cols.length}" class="fl-empty">${flAllRecords.length === 0 ? 'No flow log records loaded' : 'No records match the current filters'}</td></tr>`);
  } else {
    for (let idx = 0; idx < pageRows.length; idx++) {
      const r = pageRows[idx];
      const rowClass = r.action === 'REJECT' ? ' class="fl-row-reject"' : '';
      const time = r.start ? new Date(r.start * 1000).toLocaleString() : '-';
      const proto = PROTO_MAP[r.protocol] || r.protocol;
      const actionClass = r.action === 'ACCEPT' ? 'fl-action-accept' : (r.action === 'REJECT' ? 'fl-action-reject' : '');

      const globalIdx = startIdx + idx;

      parts.push(
        `<tr${rowClass} data-idx="${globalIdx}" title="Click to pin highlight, hover to preview">`,
        `<td>${escapeHtml(time)}</td>`,
        `<td>${enrichIpCell(r.srcaddr, r.action)}</td>`,
        `<td>${enrichPortCell(r.srcport, r.srcaddr, r.action, r.protocol)}</td>`,
        `<td>${enrichIpCell(r.dstaddr, r.action)}</td>`,
        `<td>${enrichPortCell(r.dstport, r.dstaddr, r.action, r.protocol)}</td>`,
        `<td class="fl-proto">${escapeHtml(String(proto))}</td>`,
        `<td>${r.packets.toLocaleString()}</td>`,
        `<td>${formatFlowBytes(r.bytes)}</td>`,
        `<td class="${actionClass}">${escapeHtml(r.action)}</td>`,
        `<td>${enrichNicCell(r.interfaceId)}</td>`,
        '</tr>'
      );
    }
  }

  parts.push('</tbody></table>');
  body.innerHTML = parts.join('');

  // Attach event listeners from the PARENT context (not inline handlers)
  // so they directly call parent functions without needing window.opener
  body.querySelectorAll('.fl-table th[data-col]').forEach(th => {
    th.style.cursor = 'pointer';
    th.addEventListener('click', () => sortFlowLog(th.dataset.col));
  });
  body.querySelectorAll('.fl-table tbody tr[data-idx]').forEach(tr => {
    const globalIdx = parseInt(tr.dataset.idx);
    tr.addEventListener('mouseenter', () => hoverFlowLogEntry(globalIdx));
    tr.addEventListener('mouseleave', () => unhoverFlowLogEntry());
    tr.addEventListener('contextmenu', (e) => {
      const record = flFilteredRecords[globalIdx];
      if (record) showFlContextMenu(e, record, w.document);
    });
    tr.addEventListener('click', () => {
      // Highlight on map persistently
      const record = flFilteredRecords[globalIdx];
      if (!record) return;
      const resolved = resolveFlowPath(record);
      if (!resolved) {
        toast(flowDescText(record) + ' \u2014 ' + noMatchReason(record), 'warning');
        return;
      }
      applyFlowHighlight(resolved);
      // Highlight row in popout
      body.querySelectorAll('.fl-table tbody tr').forEach(r => r.classList.remove('fl-row-highlighted'));
      tr.classList.add('fl-row-highlighted');
      // Toast
      const names = graphData.nodes.filter(n => resolved.matchedNodeIds.has(n.id)).map(n => n.name);
      toast(flowDescText(record) + ' \u2014 ' + names.join(', '), 'info', true);
    });
  });

  // Update pagination and stats in popout
  const totalPages = Math.max(1, Math.ceil(flFilteredRecords.length / FL_PAGE_SIZE));
  const pageInfo = w.document.getElementById('poPageInfo');
  if (pageInfo) pageInfo.textContent = 'Page ' + (flPage + 1) + ' of ' + totalPages;
  const prevBtn = w.document.getElementById('poPrevBtn');
  if (prevBtn) prevBtn.disabled = flPage === 0;
  const nextBtn = w.document.getElementById('poNextBtn');
  if (nextBtn) nextBtn.disabled = flPage >= totalPages - 1;

  // Stats
  const total = flAllRecords.length;
  let accepts = 0, rejects = 0;
  for (let i = 0; i < flFilteredRecords.length; i++) {
    if (flFilteredRecords[i].action === 'ACCEPT') accepts++;
    else if (flFilteredRecords[i].action === 'REJECT') rejects++;
  }
  const el = (id, val) => { const e = w.document.getElementById(id); if (e) e.textContent = val; };
  el('poStatTotal', total.toLocaleString());
  el('poStatAccept', accepts.toLocaleString());
  el('poStatReject', rejects.toLocaleString());
  el('poStatFiles', flFiles.length);
  el('poStatShown', flFilteredRecords.length.toLocaleString());
  el('poRecordCount', '(' + flFilteredRecords.length.toLocaleString() + ' of ' + total.toLocaleString() + ')');

  // Sync NIC filter options
  const parentNic = document.getElementById('flFilterNic');
  const popoutNic = w.document.getElementById('poFilterNic');
  if (parentNic && popoutNic && popoutNic.innerHTML !== parentNic.innerHTML) {
    popoutNic.innerHTML = parentNic.innerHTML;
  }
}

// ---- Draggable dialog ----
let flDragState = null;
function setupFlowLogDrag() {
  const dialog = document.getElementById('flowlogDialog');
  const header = dialog.querySelector('.flowlog-header');
  if (!header || header._flDragBound) return;
  header._flDragBound = true;

  header.addEventListener('mousedown', (e) => {
    // Don't drag if clicking on buttons, inputs, selects, or if docked
    if (flDocked) return;
    if (e.target.closest('button, input, select, .detail-close')) return;
    e.preventDefault();
    const rect = dialog.getBoundingClientRect();
    flDragState = { startX: e.clientX, startY: e.clientY, origLeft: rect.left, origTop: rect.top };

    // Switch from centered to absolute positioning on first drag
    if (!dialog.classList.contains('fl-dragged')) {
      dialog.style.left = rect.left + 'px';
      dialog.style.top = rect.top + 'px';
      dialog.style.transform = 'none';
      dialog.classList.add('fl-dragged');
    }
  });

  document.addEventListener('mousemove', (e) => {
    if (!flDragState) return;
    const dx = e.clientX - flDragState.startX;
    const dy = e.clientY - flDragState.startY;
    dialog.style.left = (flDragState.origLeft + dx) + 'px';
    dialog.style.top = (flDragState.origTop + dy) + 'px';
  });

  document.addEventListener('mouseup', () => { flDragState = null; });
}

function setupFlowLogDropzone() {
  const overlay = document.getElementById('flowlogOverlay');
  if (!overlay || overlay._flDropBound) return;
  overlay._flDropBound = true;

  overlay.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); });
  overlay.addEventListener('dragleave', (e) => {
    e.preventDefault(); e.stopPropagation();
    const dz = document.getElementById('flDropzone');
    if (dz) dz.classList.remove('drag-over');
  });
  overlay.addEventListener('dragenter', (e) => {
    e.preventDefault(); e.stopPropagation();
    const dz = document.getElementById('flDropzone');
    if (dz) dz.classList.add('drag-over');
  });
  overlay.addEventListener('drop', (e) => {
    e.preventDefault(); e.stopPropagation();
    const dz = document.getElementById('flDropzone');
    if (dz) dz.classList.remove('drag-over');
    if (e.dataTransfer.files.length) handleFlowLogFiles(e.dataTransfer.files);
  });
}

async function handleFlowLogFiles(fileList) {
  const files = Array.from(fileList).filter(f => f.name.endsWith('.gz') || f.name.endsWith('.log'));
  if (!files.length) { toast('No .log.gz files found', 'warning'); return; }

  // Show loading state
  const body = document.getElementById('flBody');
  body.innerHTML = '<div style="padding:60px;text-align:center;color:var(--text-muted);"><div style="font-size:24px;margin-bottom:12px;">&#9203;</div>Parsing ' + files.length + ' file(s)...</div>';

  // Process each file async
  let newRecords = 0;
  for (const file of files) {
    try {
      const records = await parseFlowLogFile(file);
      if (records.length > 0) {
        // Extract NIC UUID and timestamp from filename
        const match = file.name.match(/^([0-9a-f-]{36})-(\d+)\.log/);
        const nicId = match ? match[1] : file.name.replace(/\.log\.gz$|\.gz$|\.log$/, '');
        const ts = match ? parseInt(match[2]) : null;

        flFiles.push({
          name: file.name,
          nicId,
          timestamp: ts,
          recordCount: records.length,
        });

        flAllRecords.push(...records);
        newRecords += records.length;
      }
    } catch (err) {
      console.error('Failed to parse:', file.name, err);
      toast('Failed to parse: ' + file.name, 'error');
    }
  }

  if (newRecords === 0) {
    toast('No flow log records found in uploaded files', 'warning');
    renderFlowLogDropzone();
    return;
  }

  toast(newRecords.toLocaleString() + ' records loaded from ' + files.length + ' file(s)', 'success');

  // Reset file input so same file can be re-selected
  const fileInput = document.getElementById('flFileInput');
  if (fileInput) fileInput.value = '';

  // Update NIC filter dropdown
  updateFlowLogNicFilter();

  // Apply filters and render
  flPage = 0;
  filterFlowLogs();
  showFlowLogControls();
}

async function parseFlowLogFile(file) {
  let buffer;
  try { buffer = await file.arrayBuffer(); }
  catch (e) { throw new Error(`Cannot read file ${file.name}: ${e.message}`); }
  let text;

  if (file.name.endsWith('.gz')) {
    try {
      const decompressed = pako.inflate(new Uint8Array(buffer));
      text = new TextDecoder().decode(decompressed);
    } catch (e) {
      // Try as plain text
      text = new TextDecoder().decode(buffer);
    }
  } else {
    text = new TextDecoder().decode(buffer);
  }

  const lines = text.split('\n').filter(l => l.trim());
  const records = [];

  // Extract NIC UUID from filename for records
  const match = file.name.match(/^([0-9a-f-]{36})-(\d+)\.log/);
  const fileNicId = match ? match[1] : '';

  for (const line of lines) {
    const parts = line.trim().split(/\s+/);
    if (parts.length < 14) continue;

    // IONOS flow log format:
    // version account-id interface-id srcaddr dstaddr srcport dstport protocol packets bytes start end action log-status
    const [version, accountId, interfaceId, srcaddr, dstaddr, srcport, dstport, protocol, packets, bytes, start, end, action, logStatus] = parts;

    // Skip header lines or malformed
    if (version === 'version' || isNaN(parseInt(version))) continue;

    records.push({
      version: parseInt(version),
      accountId,
      interfaceId: interfaceId !== '-' ? interfaceId : fileNicId,
      srcaddr,
      dstaddr,
      srcport: parseInt(srcport) || 0,
      dstport: parseInt(dstport) || 0,
      protocol: parseInt(protocol) || 0,
      packets: parseInt(packets) || 0,
      bytes: parseInt(bytes) || 0,
      start: parseInt(start) || 0,
      end: parseInt(end) || 0,
      action: action || '',
      logStatus: logStatus || '',
    });
  }

  return records;
}

function showFlowLogControls() {
  document.getElementById('flFilters').style.display = '';
  document.getElementById('flFilePills').style.display = '';
  document.getElementById('flFooter').style.display = '';
  document.getElementById('flExportBtn').style.display = '';
  document.getElementById('flClearBtn').style.display = '';
  renderFlowLogFilePills();
}

function renderFlowLogDropzone() {
  const body = document.getElementById('flBody');
  body.innerHTML = `
    <div class="fl-dropzone" id="flDropzone">
      <div class="fl-dropzone-icon">
        <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
      </div>
      <div class="fl-dropzone-title">Drop .log.gz files here</div>
      <div class="fl-dropzone-subtitle">
        Upload IONOS Flow Log files to explore traffic records. Files are parsed locally in your browser — nothing is uploaded to any server.
        <br><br>
        File format: <code style="color:var(--accent); font-size:11px;">{nic-uuid}-{epoch}.log.gz</code>
      </div>
      <button class="fl-dropzone-btn" onclick="document.getElementById('flFileInput').click()">Browse Files</button>
    </div>
  `;
}

function updateFlowLogNicFilter() {
  const select = document.getElementById('flFilterNic');
  if (!select) return;
  const nics = [...new Set(flFiles.map(f => f.nicId))];
  let html = '<option value="">All NICs (' + nics.length + ')</option>';
  nics.forEach(nic => {
    // Try to match NIC to a node name in the graph
    let label = nic.substring(0, 8) + '...';
    if (graphData && graphData.nodes) {
      const matchNode = graphData.nodes.find(n =>
        n.data?.nics?.some(nData => nData.nicId === nic)
      );
      if (matchNode) {
        label = matchNode.name + ' (' + nic.substring(0, 8) + ')';
      }
    }
    html += `<option value="${escapeHtml(nic)}">${escapeHtml(label)}</option>`;
  });
  select.innerHTML = html;
}

function renderFlowLogFilePills() {
  const container = document.getElementById('flFilePills');
  if (!container) return;
  let html = '';
  flFiles.forEach((f, i) => {
    const timeStr = f.timestamp ? new Date(f.timestamp * 1000).toLocaleString() : 'unknown';
    const nicShort = f.nicId.substring(0, 8);
    html += `<span class="fl-file-pill">
      <span class="fl-pill-nic" title="${escapeHtml(f.nicId)}">${escapeHtml(nicShort)}</span>
      <span class="fl-pill-time">${escapeHtml(timeStr)}</span>
      <span class="fl-pill-count">(${f.recordCount.toLocaleString()})</span>
      <span class="fl-pill-remove" onclick="removeFlowLogFile(${i})" title="Remove">&times;</span>
    </span>`;
  });
  container.innerHTML = html;
}

function removeFlowLogFile(index) {
  const file = flFiles[index];
  if (!file) return;
  // Remove records belonging to this file's NIC+timestamp
  flAllRecords = flAllRecords.filter(r => {
    if (r.interfaceId === file.nicId) {
      // If we have timestamp, filter by time range; otherwise remove all for that NIC
      if (file.timestamp) {
        // Records within a few minutes of the file timestamp likely belong to it
        return Math.abs(r.start - file.timestamp) > 600;
      }
      return false;
    }
    return true;
  });
  flFiles.splice(index, 1);

  if (flFiles.length === 0) {
    clearFlowLogs();
    return;
  }

  updateFlowLogNicFilter();
  renderFlowLogFilePills();
  flPage = 0;
  filterFlowLogs();
}

function clearFlowLogs() {
  flAllRecords = [];
  flFilteredRecords = [];
  flFiles = [];
  invalidateHeatmapCache();
  flPage = 0;
  if (heatmapActive) clearHeatmap();

  document.getElementById('flFilters').style.display = 'none';
  document.getElementById('flFilePills').style.display = 'none';
  document.getElementById('flFooter').style.display = 'none';
  document.getElementById('flExportBtn').style.display = 'none';
  document.getElementById('flClearBtn').style.display = 'none';
  document.getElementById('flRecordCount').textContent = '';

  // Reset filter inputs
  ['flSearch', 'flFilterSrc', 'flFilterDst', 'flFilterPort'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  ['flFilterAction', 'flFilterProto', 'flFilterNic'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.selectedIndex = 0;
  });

  // Reset file input so same files can be re-selected
  const fileInput = document.getElementById('flFileInput');
  if (fileInput) fileInput.value = '';

  renderFlowLogDropzone();
}

function filterFlowLogs() {
  clearTimeout(flFilterTimeout);
  flFilterTimeout = setTimeout(_applyFlowLogFilters, 150);
}

function _applyFlowLogFilters() {
  const search = (document.getElementById('flSearch')?.value || '').toLowerCase();
  const actionFilter = document.getElementById('flFilterAction')?.value || '';
  const protoFilter = document.getElementById('flFilterProto')?.value || '';
  const srcFilter = (document.getElementById('flFilterSrc')?.value || '').toLowerCase();
  const dstFilter = (document.getElementById('flFilterDst')?.value || '').toLowerCase();
  const portFilter = document.getElementById('flFilterPort')?.value || '';
  const nicFilter = document.getElementById('flFilterNic')?.value || '';

  flFilteredRecords = flAllRecords.filter(r => {
    if (actionFilter && r.action !== actionFilter) return false;
    if (protoFilter && r.protocol !== parseInt(protoFilter)) return false;
    if (srcFilter && !r.srcaddr.toLowerCase().includes(srcFilter)) return false;
    if (dstFilter && !r.dstaddr.toLowerCase().includes(dstFilter)) return false;
    if (portFilter) {
      const p = parseInt(portFilter);
      if (r.srcport !== p && r.dstport !== p) return false;
    }
    if (nicFilter && r.interfaceId !== nicFilter) return false;
    if (search) {
      const haystack = (r.srcaddr + ' ' + r.dstaddr + ' ' + r.srcport + ' ' + r.dstport + ' ' + r.action + ' ' + (PROTO_MAP[r.protocol] || r.protocol) + ' ' + r.interfaceId).toLowerCase();
      if (!haystack.includes(search)) return false;
    }
    return true;
  });

  // Sort
  sortFlowLogRecords();

  // Update stats
  updateFlowLogStats();
  updateAiButtonVisibility();

  // Reset page
  flPage = 0;
  renderFlowLogTable();
}

function sortFlowLogRecords() {
  const dir = flSortDir === 'asc' ? 1 : -1;
  flFilteredRecords.sort((a, b) => {
    let av = a[flSortCol], bv = b[flSortCol];
    if (typeof av === 'string') {
      av = av.toLowerCase(); bv = (bv || '').toLowerCase();
      if (av < bv) return -1 * dir;
      if (av > bv) return dir;
      return 0;
    }
    return ((av || 0) - (bv || 0)) * dir;
  });
}

function sortFlowLog(colKey) {
  if (flSortCol === colKey) {
    flSortDir = flSortDir === 'asc' ? 'desc' : 'asc';
  } else {
    flSortCol = colKey;
    flSortDir = colKey === 'start' ? 'desc' : 'asc';
  }
  sortFlowLogRecords();
  renderFlowLogTable();
}

function updateFlowLogStats() {
  const total = flAllRecords.length;
  // Single pass to count accepts/rejects instead of two .filter() scans
  let accepts = 0, rejects = 0;
  for (let i = 0; i < flFilteredRecords.length; i++) {
    if (flFilteredRecords[i].action === 'ACCEPT') accepts++;
    else if (flFilteredRecords[i].action === 'REJECT') rejects++;
  }

  document.getElementById('flStatTotal').textContent = total.toLocaleString();
  document.getElementById('flStatAccept').textContent = accepts.toLocaleString();
  document.getElementById('flStatReject').textContent = rejects.toLocaleString();
  document.getElementById('flStatFiles').textContent = flFiles.length;
  document.getElementById('flStatShown').textContent = flFilteredRecords.length.toLocaleString();
  document.getElementById('flRecordCount').textContent = '(' + flFilteredRecords.length.toLocaleString() + ' of ' + total.toLocaleString() + ')';

  // Count tagged IPs (IPs that match topology resources)
  if (graphData?._ipToNodes) {
    const taggedIps = new Set();
    for (let i = 0; i < flFilteredRecords.length; i++) {
      const r = flFilteredRecords[i];
      if (r.srcaddr && graphData._ipToNodes.has(r.srcaddr)) taggedIps.add(r.srcaddr);
      if (r.dstaddr && graphData._ipToNodes.has(r.dstaddr)) taggedIps.add(r.dstaddr);
    }
    const el = document.getElementById('flStatTagged');
    if (el) el.textContent = taggedIps.size + ' IPs';
  }
}

function renderFlowLogTable() {
  const body = document.getElementById('flBody');
  if (!body) return;

  const cols = [
    { key: 'start', label: 'Time' },
    { key: 'srcaddr', label: 'Source IP' },
    { key: 'srcport', label: 'Src Port' },
    { key: 'dstaddr', label: 'Dest IP' },
    { key: 'dstport', label: 'Dst Port' },
    { key: 'protocol', label: 'Proto' },
    { key: 'packets', label: 'Packets' },
    { key: 'bytes', label: 'Bytes' },
    { key: 'action', label: 'Action' },
    { key: 'interfaceId', label: 'Server / NIC' },
  ];

  // Header — use array.join() instead of string += to avoid O(n²) string allocation
  const parts = ['<table class="fl-table"><thead><tr>'];
  for (let c = 0; c < cols.length; c++) {
    const col = cols[c];
    const isSorted = flSortCol === col.key;
    const arrow = isSorted ? (flSortDir === 'asc' ? '\u25B2' : '\u25BC') : '\u25B8';
    parts.push(`<th onclick="sortFlowLog('${col.key}')">${col.label}<span class="sort-arrow">${arrow}</span></th>`);
  }
  parts.push('</tr></thead><tbody>');

  // Paginated rows
  const startIdx = flPage * FL_PAGE_SIZE;
  const pageRows = flFilteredRecords.slice(startIdx, startIdx + FL_PAGE_SIZE);

  if (pageRows.length === 0) {
    parts.push(`<tr><td colspan="${cols.length}" class="fl-empty">${flAllRecords.length === 0 ? 'No flow log records loaded' : 'No records match the current filters'}</td></tr>`);
  } else {
    for (let idx = 0; idx < pageRows.length; idx++) {
      const r = pageRows[idx];
      const rowClass = r.action === 'REJECT' ? ' class="fl-row-reject"' : '';
      const time = r.start ? new Date(r.start * 1000).toLocaleString() : '-';
      const proto = PROTO_MAP[r.protocol] || r.protocol;
      const actionClass = r.action === 'ACCEPT' ? 'fl-action-accept' : (r.action === 'REJECT' ? 'fl-action-reject' : '');

      const globalIdx = startIdx + idx;

      parts.push(
        `<tr${rowClass} onclick="highlightFlowLogEntry(${globalIdx})" onmouseenter="hoverFlowLogEntry(${globalIdx})" onmouseleave="unhoverFlowLogEntry()" oncontextmenu="showFlContextMenu(event, flFilteredRecords[${globalIdx}])" title="Click to pin highlight, hover to preview, right-click to copy">`,
        `<td>${escapeHtml(time)}</td>`,
        `<td>${enrichIpCell(r.srcaddr, r.action)}</td>`,
        `<td>${enrichPortCell(r.srcport, r.srcaddr, r.action, r.protocol)}</td>`,
        `<td>${enrichIpCell(r.dstaddr, r.action)}</td>`,
        `<td>${enrichPortCell(r.dstport, r.dstaddr, r.action, r.protocol)}</td>`,
        `<td class="fl-proto">${escapeHtml(String(proto))}</td>`,
        `<td>${r.packets.toLocaleString()}</td>`,
        `<td>${formatFlowBytes(r.bytes)}</td>`,
        `<td class="${actionClass}">${escapeHtml(r.action)}</td>`,
        `<td>${enrichNicCell(r.interfaceId)}</td>`,
        '</tr>'
      );
    }
  }

  parts.push('</tbody></table>');
  body.innerHTML = parts.join('');

  // Update pagination
  const totalPages = Math.max(1, Math.ceil(flFilteredRecords.length / FL_PAGE_SIZE));
  document.getElementById('flPageInfo').textContent = 'Page ' + (flPage + 1) + ' of ' + totalPages;
  document.getElementById('flPrevBtn').disabled = flPage === 0;
  document.getElementById('flNextBtn').disabled = flPage >= totalPages - 1;

  // Also sync to popout window if open
  if (flPopoutWindow && !flPopoutWindow.closed) renderPopoutTable();
}

function formatFlowBytes(b) {
  if (b === 0) return '0';
  if (b < 1024) return b + ' B';
  if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
  if (b < 1073741824) return (b / 1048576).toFixed(1) + ' MB';
  return (b / 1073741824).toFixed(2) + ' GB';
}

function flPagePrev() {
  if (flPage > 0) { flPage--; renderFlowLogTable(); }
}

function flPageNext() {
  const totalPages = Math.ceil(flFilteredRecords.length / FL_PAGE_SIZE);
  if (flPage < totalPages - 1) { flPage++; renderFlowLogTable(); }
}

// Resolve a flow record to matched graph nodes and the path between them
function resolveFlowPath(record) {
  if (!record || !graphData || !graphData.nodes || !graphData.nodes.length) return null;

  const srcIp = record.srcaddr;
  const dstIp = record.dstaddr;
  const nicId = record.interfaceId;

  const matchedNodeIds = new Set();
  const matchReasons = new Map();

  // Use pre-built lookup maps (O(1) instead of scanning all nodes)
  const ipToNodes = graphData._ipToNodes;
  const nicToNode = graphData._nicToNode;

  if (ipToNodes && nicToNode) {
    // NIC match
    if (nicId && nicToNode.has(nicId)) {
      const nId = nicToNode.get(nicId);
      matchedNodeIds.add(nId);
      matchReasons.set(nId, 'NIC ' + nicId.substring(0, 8));
    }
    // Source IP match
    if (srcIp && ipToNodes.has(srcIp)) {
      ipToNodes.get(srcIp).forEach(nId => {
        matchedNodeIds.add(nId);
        if (!matchReasons.has(nId)) matchReasons.set(nId, 'src ' + srcIp);
      });
    }
    // Destination IP match
    if (dstIp && ipToNodes.has(dstIp)) {
      ipToNodes.get(dstIp).forEach(nId => {
        matchedNodeIds.add(nId);
        if (!matchReasons.has(nId)) matchReasons.set(nId, 'dst ' + dstIp);
      });
    }
  } else {
    // Fallback: scan all nodes (only if lookup maps not yet built)
    graphData.nodes.forEach(n => {
      if (n.data?.nics) {
        n.data.nics.forEach(nic => {
          if (nic.nicId === nicId) { matchedNodeIds.add(n.id); matchReasons.set(n.id, 'NIC ' + nicId.substring(0, 8)); }
          if (nic.ips) {
            if (nic.ips.includes(srcIp)) { matchedNodeIds.add(n.id); matchReasons.set(n.id, 'src ' + srcIp); }
            if (nic.ips.includes(dstIp)) { matchedNodeIds.add(n.id); matchReasons.set(n.id, 'dst ' + dstIp); }
          }
        });
      }
      if (n.type === 'ipblock' && n.data?.ips) {
        if (n.data.ips.includes(srcIp)) { matchedNodeIds.add(n.id); matchReasons.set(n.id, 'src ' + srcIp); }
        if (n.data.ips.includes(dstIp)) { matchedNodeIds.add(n.id); matchReasons.set(n.id, 'dst ' + dstIp); }
      }
      if (n.type === 'nat' && n.data?.publicIps) {
        if (n.data.publicIps.includes(srcIp) || n.data.publicIps.includes(dstIp)) {
          matchedNodeIds.add(n.id); matchReasons.set(n.id, 'NAT IP');
        }
      }
    });
  }

  if (matchedNodeIds.size === 0) return null;

  // Find full path including intermediate nodes
  const pathNodeIds = new Set(matchedNodeIds);
  const pathLinkIds = new Set();

  if (matchedNodeIds.size >= 2 && graphData.links) {
    // Use pre-built BFS adjacency map if available
    const adj = graphData._bfsAdj || (() => {
      const m = new Map();
      graphData.links.forEach((l, idx) => {
        const sId = typeof l.source === 'object' ? l.source.id : l.source;
        const tId = typeof l.target === 'object' ? l.target.id : l.target;
        if (!m.has(sId)) m.set(sId, []);
        if (!m.has(tId)) m.set(tId, []);
        m.get(sId).push({ neighborId: tId, linkIdx: idx });
        m.get(tId).push({ neighborId: sId, linkIdx: idx });
      });
      return m;
    })();

    const matchedArr = [...matchedNodeIds];
    for (let i = 0; i < matchedArr.length; i++) {
      for (let j = i + 1; j < matchedArr.length; j++) {
        const path = bfsPath(adj, matchedArr[i], matchedArr[j], 4);
        if (path) {
          path.nodes.forEach(id => pathNodeIds.add(id));
          path.links.forEach(idx => pathLinkIds.add(idx));
        }
      }
    }
  }

  return { matchedNodeIds, matchReasons, pathNodeIds, pathLinkIds };
}

// Apply highlight to the graph for a resolved flow path
let flHighlightActive = false;
function applyFlowHighlight(resolved) {
  if (!resolved || typeof svgGroup === 'undefined' || !svgGroup) return;
  const { matchedNodeIds, pathNodeIds, pathLinkIds } = resolved;

  flHighlightActive = true;

  // Dim all nodes except the full path
  svgGroup.selectAll('.node').classed('hl-dimmed', d => !pathNodeIds.has(d.id));
  svgGroup.selectAll('.node').classed('hl-matched', d => matchedNodeIds.has(d.id));
  svgGroup.selectAll('.node').classed('hl-path', d => pathNodeIds.has(d.id) && !matchedNodeIds.has(d.id));

  // Dim all links except path links
  svgGroup.selectAll('.link').each(function(d, i) {
    const el = d3.select(this);
    if (pathLinkIds.has(i)) {
      el.style('opacity', 1).style('stroke', '#11C7E6').style('stroke-width', '3px');
    } else {
      el.style('opacity', 0.1);
    }
  });

  // Glow on matched endpoint nodes
  svgGroup.selectAll('.node.hl-matched .node-shape')
    .attr('stroke', '#11C7E6').attr('stroke-width', 4);

  // Softer glow on intermediate path nodes
  svgGroup.selectAll('.node.hl-path .node-shape')
    .attr('stroke', 'rgba(17,199,230,0.5)').attr('stroke-width', 3);
}

function clearFlowHighlight() {
  if (!flHighlightActive || typeof svgGroup === 'undefined' || !svgGroup) return;
  flHighlightActive = false;

  svgGroup.selectAll('.node').classed('hl-dimmed', false).classed('hl-matched', false).classed('hl-path', false);
  svgGroup.selectAll('.link').style('opacity', null).style('stroke', null).style('stroke-width', null);
  svgGroup.selectAll('.node .node-shape').attr('stroke', null).attr('stroke-width', null);
  clearPersistentToast();
}

function flowDescText(record) {
  const proto = PROTO_MAP[record.protocol] || record.protocol;
  return `${record.srcaddr}:${record.srcport} \u2192 ${record.dstaddr}:${record.dstport} (${proto} ${record.action})`;
}

function noMatchReason(record) {
  const isPrivateSrc = /^(10\.|172\.(1[6-9]|2\d|3[01])\.|192\.168\.)/.test(record.srcaddr);
  const isPrivateDst = /^(10\.|172\.(1[6-9]|2\d|3[01])\.|192\.168\.)/.test(record.dstaddr);
  if (!isPrivateSrc && !isPrivateDst) return 'Both IPs are external \u2014 not part of this VDC topology';
  if (!isPrivateSrc) return record.srcaddr + ' is external (internet traffic)';
  if (!isPrivateDst) return record.dstaddr + ' is external (internet traffic)';
  return 'IPs not found \u2014 resource may have been deleted or belongs to a different VDC';
}

// Click a row: close dialog, highlight persistently until user clicks the map
function highlightFlowLogEntry(index) {
  const record = flFilteredRecords[index];
  if (!record) return;

  const desc = flowDescText(record);
  if (!graphData || !graphData.nodes || !graphData.nodes.length) {
    toast(desc, 'info');
    return;
  }

  const resolved = resolveFlowPath(record);
  if (!resolved) {
    toast(`${desc} \u2014 ${noMatchReason(record)}`, 'warning');
    return;
  }

  // In docked mode, keep explorer open — map is visible above
  if (!flDocked) closeFlowLogExplorer();

  setTimeout(() => {
    applyFlowHighlight(resolved);

    // Build toast message
    const names = graphData.nodes
      .filter(n => resolved.matchedNodeIds.has(n.id))
      .map(n => n.name + ' (' + (resolved.matchReasons.get(n.id) || '') + ')');
    const intermediates = graphData.nodes
      .filter(n => resolved.pathNodeIds.has(n.id) && !resolved.matchedNodeIds.has(n.id))
      .map(n => n.name);
    let msg = `${desc} \u2014 ${names.join(', ')}`;
    if (intermediates.length) msg += ` via ${intermediates.join(', ')}`;
    toast(msg + (flDocked ? '' : ' \u2014 click map to clear'), 'info', true);

    // Highlight the clicked row in the table
    if (flDocked) {
      const tbody = document.querySelector('.fl-table tbody');
      if (tbody) {
        tbody.querySelectorAll('tr').forEach(r => r.classList.remove('fl-row-highlighted'));
        const pageIdx = index - flPage * FL_PAGE_SIZE;
        const row = tbody.querySelectorAll('tr')[pageIdx];
        if (row) row.classList.add('fl-row-highlighted');
      }
    }
  }, flDocked ? 0 : 150);
}

// Hover a row: highlight on the graph while hovering, clear on leave
function hoverFlowLogEntry(index) {
  const record = flFilteredRecords[index];
  if (!record) return;
  const resolved = resolveFlowPath(record);
  if (resolved) applyFlowHighlight(resolved);
}

function unhoverFlowLogEntry() {
  clearFlowHighlight();
}

// BFS shortest path between two nodes, limited to maxDepth hops
function bfsPath(adj, startId, endId, maxDepth) {
  if (startId === endId) return { nodes: [startId], links: [] };
  const visited = new Set([startId]);
  const queue = [{ id: startId, path: [startId], links: [], depth: 0 }];

  while (queue.length > 0) {
    const { id, path, links, depth } = queue.shift();
    if (depth >= maxDepth) continue;

    const neighbors = adj.get(id) || [];
    for (const { neighborId, linkIdx } of neighbors) {
      if (visited.has(neighborId)) continue;
      const newPath = [...path, neighborId];
      const newLinks = [...links, linkIdx];

      if (neighborId === endId) {
        return { nodes: newPath, links: newLinks };
      }

      visited.add(neighborId);
      queue.push({ id: neighborId, path: newPath, links: newLinks, depth: depth + 1 });
    }
  }
  return null; // no path found within maxDepth
}

function exportFlowLogCSV() {
  if (!flFilteredRecords.length) { toast('No records to export', 'warning'); return; }

  const headers = ['Time', 'Source IP', 'Src Port', 'Dest IP', 'Dst Port', 'Protocol', 'Packets', 'Bytes', 'Action', 'NIC ID', 'Account ID', 'Log Status'];
  const rows = flFilteredRecords.map(r => [
    r.start ? new Date(r.start * 1000).toISOString() : '',
    r.srcaddr, r.srcport, r.dstaddr, r.dstport,
    PROTO_MAP[r.protocol] || r.protocol,
    r.packets, r.bytes, r.action, r.interfaceId, r.accountId, r.logStatus,
  ]);

  let csv = headers.join(',') + '\n';
  rows.forEach(row => {
    csv += row.map(v => {
      const s = String(v);
      return s.includes(',') || s.includes('"') ? '"' + s.replace(/"/g, '""') + '"' : s;
    }).join(',') + '\n';
  });

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'flowlogs-export-' + new Date().toISOString().slice(0, 10) + '.csv';
  a.click();
  URL.revokeObjectURL(url);
  toast('Exported ' + flFilteredRecords.length.toLocaleString() + ' records to CSV', 'success');
}

// ============================== AI FLOW LOG ANALYST ==============================

function toggleAiPanel() {
  aiPanelOpen = !aiPanelOpen;
  const panel = document.getElementById('aiPanel');
  if (aiPanelOpen) {
    panel.classList.add('open');
    // Populate model selector on first open
    const sel = document.getElementById('aiModelSelect');
    if (sel && sel.options.length === 0) {
      AI_MODELS.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = m.label;
        sel.appendChild(opt);
      });
      sel.value = aiSelectedModel;
    }
    // Restore cost banner state
    if (localStorage.getItem('ai-cost-dismissed') === '1') {
      document.getElementById('aiCostBanner')?.classList.add('hidden');
    }
    updateAiSuggestions();
    document.getElementById('aiInput')?.focus();
  } else {
    panel.classList.remove('open');
  }
}

function openAiPanel() {
  if (!aiPanelOpen) toggleAiPanel();
}

function closeAiPanel() {
  if (aiPanelOpen) toggleAiPanel();
}

/** Close the AI panel instantly (skip CSS transition) — use before map navigation
 *  so Leaflet sees the final container dimensions immediately. */
function closeAiPanelInstant() {
  if (!aiPanelOpen) return;
  const panel = document.getElementById('aiPanel');
  // Disable transitions, remove open state, force reflow, then re-enable
  panel.style.transition = 'none';
  panel.classList.remove('open');
  aiPanelOpen = false;
  void panel.offsetWidth;            // force reflow
  panel.style.transition = '';       // restore CSS transition for future use
}

function updateAiSuggestions() {
  const container = document.getElementById('aiSuggestions');
  if (!container) return;
  container.innerHTML = '';

  const suggestions = [];
  const hasTopology = graphData?.nodes?.length > 0;
  const hasFlowLogs = flAllRecords.length > 0;
  const hasBilling = _billingByServer.size > 0 || _billingByVdc.size > 0;
  const hasDatabases = graphData?.nodes?.some(n => ['postgres', 'mongodb', 'mysql', 'mariadb', 'kafka'].includes(n.type));

  // Always available when topology is loaded
  if (hasTopology) {
    suggestions.push({ label: 'Summarize infrastructure', prompt: 'Give me a concise overview of my cloud infrastructure — servers, networks, databases, and any notable observations.' });
    suggestions.push({ label: 'Security assessment', prompt: 'Assess the security posture of my infrastructure. Check firewall coverage, flow log monitoring, security groups, and highlight any gaps or concerns.' });
  }

  // Flow log suggestions
  if (hasFlowLogs) {
    suggestions.push({ label: 'Traffic patterns', prompt: 'Analyze the traffic patterns in my flow logs. Identify the top talkers, busiest ports, and any unusual activity.' });
    suggestions.push({ label: 'Rejected flows', prompt: 'Analyze the rejected flows. Are there patterns suggesting attacks, misconfigurations, or missing firewall rules?' });
  }

  // Billing suggestions
  if (hasBilling) {
    suggestions.push({ label: 'Cost optimization', prompt: 'Review my data transfer and billing data. Which servers consume the most bandwidth? Are there cost optimization opportunities?' });
  }

  // Database suggestions
  if (hasDatabases) {
    suggestions.push({ label: 'Database overview', prompt: 'Summarize my database services — types, versions, instance counts, and any recommendations for updates or improvements.' });
  }

  // Limit to 4 suggestions max
  suggestions.slice(0, 4).forEach(s => {
    const btn = document.createElement('button');
    btn.className = 'ai-suggest-btn';
    btn.textContent = s.label;
    btn.onclick = () => sendAiMessage(s.prompt);
    container.appendChild(btn);
  });
}

function dismissAiCostBanner() {
  document.getElementById('aiCostBanner')?.classList.add('hidden');
  localStorage.setItem('ai-cost-dismissed', '1');
}

function addAiMessage(text, role) {
  const container = document.getElementById('aiMessages');
  if (!container) return;
  // Remove welcome message on first interaction
  const welcome = container.querySelector('.ai-welcome');
  if (welcome) welcome.remove();

  const el = document.createElement('div');
  el.className = `ai-msg ai-msg-${role}`;
  if (role === 'assistant') {
    // Basic markdown-like formatting: **bold**, `code`, newlines
    let html = escapeHtml(text)
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/`([^`]+)`/g, '<code style="background:var(--bg-hover);padding:1px 4px;border-radius:3px;font-size:12px;">$1</code>');
    el.innerHTML = html;
  } else {
    el.textContent = text;
  }
  container.appendChild(el);
  container.scrollTop = container.scrollHeight;
  return el;
}

function addAiTypingIndicator() {
  const container = document.getElementById('aiMessages');
  if (!container) return null;
  const el = document.createElement('div');
  el.className = 'ai-typing';
  el.innerHTML = '<span class="ai-typing-dots"><span></span><span></span><span></span></span> Analyzing...';
  container.appendChild(el);
  container.scrollTop = container.scrollHeight;
  return el;
}

// Build dynamic system prompt based on what data is loaded
// ── MCP Docs Search (IONOS GitBook documentation) ──────────────
let _mcpRequestId = 0;
let _mcpSearchToolName = null;  // discovered via tools/list

async function mcpRequest(method, params) {
  _mcpRequestId++;
  const body = { jsonrpc: '2.0', id: _mcpRequestId, method, params: params || {} };
  const headers = { 'Content-Type': 'application/json' };
  if (mcpSessionId) headers['Mcp-Session-Id'] = mcpSessionId;

  const resp = await fetch('/mcp-docs', {
    method: 'POST',
    headers,
    body: JSON.stringify(body),
  });

  // Capture session ID from response
  const sid = resp.headers.get('Mcp-Session-Id');
  if (sid) mcpSessionId = sid;

  if (!resp.ok) {
    const errText = await resp.text().catch(() => '');
    throw new Error(`MCP ${resp.status}: ${errText.substring(0, 200)}`);
  }
  const json = await resp.json();
  // Check for JSON-RPC error
  if (json.error) {
    throw new Error(`MCP-RPC: ${json.error.message || JSON.stringify(json.error)}`);
  }
  return json;
}

async function initMcpSession() {
  if (mcpInitialized) return;
  try {
    const initResult = await mcpRequest('initialize', {
      protocolVersion: '2025-03-26',
      capabilities: {},
      clientInfo: { name: 'IONOS-Cloud-Visualizer', version: '1.9' },
    });
    console.log('[AI] MCP init response:', JSON.stringify(initResult).substring(0, 500));
    mcpInitialized = true;

    // Send initialized notification (fire-and-forget)
    mcpRequest('notifications/initialized', {}).catch(() => {});

    // Discover available tools
    try {
      const toolsResult = await mcpRequest('tools/list', {});
      const tools = toolsResult?.result?.tools || [];
      console.log('[AI] MCP available tools:', tools.map(t => t.name).join(', '));
      // Find a search-like tool (GitBook typically exposes one)
      const searchTool = tools.find(t =>
        /search/i.test(t.name) || /query/i.test(t.name) || /find/i.test(t.name)
      );
      if (searchTool) {
        _mcpSearchToolName = searchTool.name;
        console.log('[AI] MCP search tool found:', _mcpSearchToolName);
      } else if (tools.length > 0) {
        // If no obvious search tool, use the first tool as fallback
        _mcpSearchToolName = tools[0].name;
        console.log('[AI] MCP using first available tool:', _mcpSearchToolName);
      }
    } catch (e) {
      console.warn('[AI] MCP tools/list failed:', e.message);
      // Fallback tool names to try
      _mcpSearchToolName = 'search';
    }

    console.log('[AI] MCP docs session initialized, search tool:', _mcpSearchToolName);
  } catch (e) {
    console.warn('[AI] MCP docs init failed:', e.message);
  }
}

async function searchIonosDocs(query) {
  if (!aiDocsSearchEnabled) return '';
  try {
    await initMcpSession();
    if (!mcpInitialized || !_mcpSearchToolName) return '';

    console.log('[AI] Searching IONOS docs for:', query, 'using tool:', _mcpSearchToolName);
    const result = await mcpRequest('tools/call', {
      name: _mcpSearchToolName,
      arguments: { query },
    });
    console.log('[AI] MCP search result keys:', JSON.stringify(Object.keys(result || {})));
    console.log('[AI] MCP search result preview:', JSON.stringify(result).substring(0, 800));

    // MCP tools/call result is at result.result.content (JSON-RPC wraps it)
    // But depending on the response, it could also be directly at result.content
    const content = result?.result?.content || result?.content;
    if (!content) {
      console.warn('[AI] MCP search: no content in result');
      return '';
    }

    // Handle both array and string content
    let texts = [];
    if (Array.isArray(content)) {
      texts = content
        .filter(c => c.type === 'text' && c.text)
        .map(c => c.text.substring(0, 1500))
        .slice(0, 3);
    } else if (typeof content === 'string') {
      texts = [content.substring(0, 4500)];
    }

    if (texts.length === 0) {
      console.warn('[AI] MCP search: content array empty or no text items');
      return '';
    }
    console.log('[AI] MCP docs context length:', texts.join('').length, 'chars');
    return '\n\n[IONOS Documentation Reference]\n' + texts.join('\n---\n');
  } catch (e) {
    console.warn('[AI] Docs search failed:', e.message);
    return '';
  }
}

function buildAiSystemPrompt(contextStr) {
  const hasTopology = graphData?.nodes?.length > 0;
  const hasFlowLogs = flAllRecords.length > 0;
  const hasBilling = _billingByServer.size > 0 || _billingByVdc.size > 0;
  const ctx = contextStr || buildAiContext();

  let prompt = 'You are an IONOS Cloud infrastructure assistant. Give concise, actionable insights. Format key findings with **bold**. Use short paragraphs. Only reference resources, IPs, and data explicitly present in the context below — do not guess or invent details. If information is missing, say so. IMPORTANT: The context contains data at two scopes — items marked [Contract-wide] cover ALL VDCs in the account, while items marked with a specific VDC name only cover that loaded VDC. When answering, clearly distinguish between contract-wide data and VDC-specific data. If asked about resources in a VDC that is not currently loaded, explain that only the loaded VDC topology is available but billing/VDC inventory is contract-wide.';
  if (hasTopology) prompt += ' You have full visibility into the currently loaded VDC\'s topology — servers, LANs, databases, load balancers, VPNs, NAT gateways, and Kubernetes clusters.';
  if (hasFlowLogs) prompt += ' You can analyze network flow logs for traffic patterns, security threats, and anomalies. When mentioning IPs, include their resource names if known.';
  if (hasBilling) prompt += ' You have access to contract-wide billing and data transfer metrics across all VDCs. Provide cost-aware recommendations and identify high-traffic resources.';
  if (ctx.includes('[IONOS Documentation Reference]')) prompt += ' You also have excerpts from the official IONOS Cloud documentation. Use these to provide accurate how-to guidance, API references, and service details. Cite the documentation when relevant.';
  prompt += '\n\nCurrent infrastructure context:\n' + ctx;
  return prompt;
}

// Sanitize names for AI context — strip newlines and control chars to prevent prompt injection
function sanitizeName(s) {
  if (typeof s !== 'string') return '';
  return s.replace(/[\n\r\t]/g, ' ').replace(/[^\x20-\x7E\xA0-\xFF]/g, '').substring(0, 100);
}

// Build concise context string from all loaded data
function buildAiContext() {
  const parts = [];

  // Determine the loaded VDC name for section headers
  const loadedVdcName = currentDC ? (sanitizeName(currentDC.properties?.name) || currentDC.id) : 'loaded VDC';

  // ── VDC inventory (from Cloud API /datacenters — authoritative list) ──
  if (datacenters.length > 0) {
    const vdcList = datacenters.map(dc => {
      const name = sanitizeName(dc.properties?.name) || dc.id;
      const loc = dc.properties?.location || '';
      return `${name} (${loc})`;
    });
    parts.push(`[Contract-wide] Virtual Data Centers (${datacenters.length}): ${vdcList.join(', ')}`);
    if (currentDC) {
      parts.push(`Currently loaded VDC: ${loadedVdcName}`);
    }
  } else if (currentDC) {
    // Fallback: only the currently loaded VDC
    parts.push(`Current VDC: ${loadedVdcName}`);
  }

  // ── Topology summary ──
  if (graphData?.nodes?.length > 0) {
    const typeCounts = {};
    let totalCores = 0, totalRamMB = 0;
    graphData.nodes.forEach(n => {
      typeCounts[n.type] = (typeCounts[n.type] || 0) + 1;
      if ((n.type === 'server' || n.type === 'cube') && n.data) {
        totalCores += n.data.cores || 0;
        totalRamMB += n.data.ram || 0;
      }
    });
    const summary = Object.entries(typeCounts)
      .map(([t, c]) => `${NODE_TYPES[t]?.label || t}: ${c}`)
      .join(', ');
    parts.push(`[${loadedVdcName}] Topology: ${graphData.nodes.length} resources — ${summary}`);
    if (totalCores > 0) {
      parts.push(`Compute: ${totalCores} total vCPUs, ${(totalRamMB / 1024).toFixed(1)} GB total RAM`);
    }
  }

  // ── Server inventory (top 15) ──
  if (graphData?.nodes?.length > 0) {
    const servers = graphData.nodes.filter(n => n.type === 'server' || n.type === 'cube');
    if (servers.length > 0) {
      parts.push(`\n[${loadedVdcName}] Servers:`);
      servers.slice(0, 15).forEach(s => {
        const d = s.data || {};
        const nics = d.nics || [];
        const ips = nics.flatMap(n => n.ips || []);
        const fwCount = nics.filter(n => n.firewall).length;
        const flCount = nics.filter(n => n.flowLogsEnabled).length;
        const hasSG = (d.securityGroupCount || 0) > 0 || nics.some(n => (n.securityGroupCount || 0) > 0);
        parts.push(`  ${sanitizeName(s.name)} — ${d.cores || '?'}C/${((d.ram || 0) / 1024).toFixed(0)}GB, ${d.vmState || '?'}, ${ips.length} IPs${fwCount > 0 ? ', FW on' : ', FW off'}${flCount > 0 ? ', FL on' : ''}${hasSG ? ', SG on' : ''}`);
      });
      if (servers.length > 15) parts.push(`  ...and ${servers.length - 15} more`);
    }
  }

  // ── Network layout (LANs) ──
  if (graphData?.nodes?.length > 0) {
    const lans = graphData.nodes.filter(n => n.type === 'lan');
    if (lans.length > 0) {
      parts.push(`\n[${loadedVdcName}] LANs:`);
      lans.forEach(l => {
        const d = l.data || {};
        const connCount = graphData.links?.filter(lk => lk.source?.id === l.id || lk.target?.id === l.id || lk.source === l.id || lk.target === l.id).length || 0;
        parts.push(`  ${sanitizeName(l.name)} — ${d.isPublic ? 'Public' : 'Private'}${d.cidr ? ', ' + d.cidr : ''}, ${connCount} connections`);
      });
    }
  }

  // ── Database services ──
  if (graphData?.nodes?.length > 0) {
    const dbs = graphData.nodes.filter(n => ['postgres', 'mongodb', 'mysql', 'mariadb', 'kafka'].includes(n.type));
    if (dbs.length > 0) {
      parts.push(`\n[${loadedVdcName}] Database/Streaming Services:`);
      dbs.forEach(d => {
        const info = d.data || {};
        parts.push(`  ${NODE_TYPES[d.type]?.label || d.type}: ${sanitizeName(d.name)} — v${info.version || '?'}, ${info.instances || '?'} instance(s)`);
      });
    }
  }

  // ── Load balancers, NAT gateways, VPNs ──
  if (graphData?.nodes?.length > 0) {
    const infra = graphData.nodes.filter(n => ['alb', 'nlb', 'nat', 'vpn_wg', 'vpn_ipsec', 'nfs', 'pcc'].includes(n.type));
    if (infra.length > 0) {
      parts.push(`\n[${loadedVdcName}] Network Infrastructure:`);
      infra.forEach(i => {
        const d = i.data || {};
        const ips = d.ips?.join(', ') || d.publicIps?.join(', ') || '';
        parts.push(`  ${NODE_TYPES[i.type]?.label || i.type}: ${sanitizeName(i.name)}${ips ? ' (' + ips + ')' : ''}`);
      });
    }
  }

  // ── Security posture ──
  if (graphData?.nodes?.length > 0) {
    const servers = graphData.nodes.filter(n => n.type === 'server' || n.type === 'cube');
    if (servers.length > 0) {
      let fwEnabled = 0, flEnabled = 0, sgEnabled = 0;
      const sgDetails = [];
      servers.forEach(s => {
        const nics = s.data?.nics || [];
        if (nics.some(n => n.firewall)) fwEnabled++;
        if (nics.some(n => n.flowLogsEnabled)) flEnabled++;
        const hasSrvSG = (s.data?.securityGroupCount || 0) > 0;
        const hasNicSG = nics.some(n => (n.securityGroupCount || 0) > 0);
        if (hasSrvSG || hasNicSG) {
          sgEnabled++;
          // Collect SG names for this server
          const sgIds = new Set();
          (s.data?.securityGroupIds || []).forEach(id => sgIds.add(id));
          nics.forEach(n => (n.securityGroupIds || []).forEach(id => sgIds.add(id)));
          const sgNames = [...sgIds].map(id => {
            const sg = graphData._securityGroups?.get(id);
            return sg ? sg.name : id.substring(0, 8);
          });
          if (sgNames.length) sgDetails.push(`${sanitizeName(s.name)}: ${sgNames.map(n => sanitizeName(n)).join(', ')}`);
        }
      });
      parts.push(`\n[${loadedVdcName}] Security Posture: ${fwEnabled}/${servers.length} servers with firewall, ${flEnabled}/${servers.length} with flow logs, ${sgEnabled}/${servers.length} with security groups`);
      if (sgDetails.length > 0) {
        parts.push('Security Group Assignments:');
        sgDetails.forEach(d => parts.push(`  ${d}`));
      }
    }
  }

  // ── Billing / data transfer ──
  if (_billingByVdc.size > 0) {
    parts.push('\n[Contract-wide] Data Transfer by VDC (billing period):');
    _billingByVdc.forEach((v, id) => {
      parts.push(`  ${sanitizeName(v.name) || id} — In: ${v.totalIn.toFixed(2)} GB, Out: ${v.totalOut.toFixed(2)} GB`);
    });
  }
  if (_billingByServer.size > 0) {
    const topTransfer = [..._billingByServer.entries()]
      .map(([id, v]) => ({ id, total: v.totalIn + v.totalOut, ...v }))
      .sort((a, b) => b.total - a.total)
      .slice(0, 10);
    if (topTransfer.length > 0) {
      parts.push('\nTop Servers by Data Transfer:');
      topTransfer.forEach(s => {
        const node = graphData?.nodes?.find(n => n.id === `srv-${s.id}` || n.id === `cube-${s.id}`);
        const name = sanitizeName(node?.name) || s.id;
        parts.push(`  ${name} — In: ${s.totalIn.toFixed(2)} GB, Out: ${s.totalOut.toFixed(2)} GB`);
      });
    }
  }

  // ── Flow log analysis (if loaded) ──
  if (flAllRecords.length > 0) {
    const records = flFilteredRecords;
    const total = flAllRecords.length;
    const filtered = records.length;

    let accepts = 0, rejects = 0, totalBytes = 0;
    const srcCounts = new Map(), dstCounts = new Map(), portCounts = new Map();

    for (let i = 0; i < records.length; i++) {
      const r = records[i];
      if (r.action === 'ACCEPT') accepts++;
      else if (r.action === 'REJECT') rejects++;
      totalBytes += r.bytes || 0;

      if (r.srcaddr) srcCounts.set(r.srcaddr, (srcCounts.get(r.srcaddr) || 0) + 1);
      if (r.dstaddr) dstCounts.set(r.dstaddr, (dstCounts.get(r.dstaddr) || 0) + 1);
      if (r.dstport) portCounts.set(r.dstport, (portCounts.get(r.dstport) || 0) + 1);
    }

    parts.push(`\nFlow Log Summary: ${filtered} records shown (${total} total), ${accepts} ACCEPT, ${rejects} REJECT, ${formatFlowBytes(totalBytes)} total traffic.`);

    const topSrc = [...srcCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10);
    if (topSrc.length) {
      parts.push('\nTop Source IPs:');
      topSrc.forEach(([ip, cnt]) => {
        const tag = resolveIpTag(ip);
        const label = tag ? ` [${tag.label}: ${sanitizeName(tag.name)}]` : ' [External]';
        parts.push(`  ${ip}${label} — ${cnt} flows`);
      });
    }

    const topDst = [...dstCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10);
    if (topDst.length) {
      parts.push('\nTop Destination IPs:');
      topDst.forEach(([ip, cnt]) => {
        const tag = resolveIpTag(ip);
        const label = tag ? ` [${tag.label}: ${sanitizeName(tag.name)}]` : ' [External]';
        parts.push(`  ${ip}${label} — ${cnt} flows`);
      });
    }

    const topPorts = [...portCounts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10);
    if (topPorts.length) {
      parts.push('\nTop Destination Ports:');
      topPorts.forEach(([port, cnt]) => {
        const svc = WELL_KNOWN_PORTS[port] || '';
        parts.push(`  ${port}${svc ? ' (' + svc + ')' : ''} — ${cnt} flows`);
      });
    }

    // Active filters
    const filters = [];
    const srcF = document.getElementById('flFilterSrc')?.value;
    const dstF = document.getElementById('flFilterDst')?.value;
    const portF = document.getElementById('flFilterPort')?.value;
    const actionF = document.getElementById('flFilterAction')?.value;
    if (srcF) filters.push(`Source IP: ${srcF}`);
    if (dstF) filters.push(`Dest IP: ${dstF}`);
    if (portF) filters.push(`Port: ${portF}`);
    if (actionF) filters.push(`Action: ${actionF}`);
    if (filters.length) parts.push('\nActive Flow Log Filters: ' + filters.join(', '));
  }

  return parts.join('\n');
}

async function sendAiMessage(presetPrompt) {
  const input = document.getElementById('aiInput');
  const sendBtn = document.getElementById('aiSendBtn');
  const userMsg = presetPrompt || (input ? input.value.trim() : '');
  if (!userMsg) return;
  if (input && !presetPrompt) input.value = '';

  // Ensure panel is open
  if (!aiPanelOpen) openAiPanel();

  // Check if connected
  if (!apiToken) {
    addAiMessage('Please connect with your IONOS API token first.', 'error');
    return;
  }

  // Check if any data is loaded
  if (graphData.nodes.length === 0 && flAllRecords.length === 0) {
    addAiMessage('No data loaded yet. Please connect to a data center first.', 'error');
    return;
  }

  // Rate limiting — prevent spam
  const now = Date.now();
  if (now - aiLastRequestTime < AI_COOLDOWN_MS) {
    toast('Please wait a moment before sending another message.', 'info', true);
    return;
  }

  // Cancel any in-flight request
  if (aiAbortController) {
    aiAbortController.abort();
    aiAbortController = null;
  }

  addAiMessage(userMsg, 'user');
  if (sendBtn) sendBtn.disabled = true;
  aiLastRequestTime = now;

  const typing = addAiTypingIndicator();

  // Build infra context and search docs in parallel
  let context = buildAiContext();

  // Search IONOS docs for relevant information (non-blocking, best-effort)
  let docsContext = '';
  try {
    docsContext = await searchIonosDocs(userMsg);
  } catch (_) { /* docs search failure is non-fatal */ }

  // Append docs to context if found
  if (docsContext) context += docsContext;

  if (context.length > AI_MAX_CONTEXT_CHARS) {
    context = context.substring(0, AI_MAX_CONTEXT_CHARS) + '\n\n[Context truncated — showing most important data]';
  }
  const systemPrompt = buildAiSystemPrompt(context);

  // Abort controller with timeout
  aiAbortController = new AbortController();
  const timeoutId = setTimeout(() => aiAbortController?.abort(), AI_TIMEOUT_MS);

  try {
    const endpoint = `${API_BASES.ai}/chat/completions`;
    const fetchUrl = useProxy()
      ? `/proxy?url=${encodeURIComponent(endpoint)}`
      : endpoint;

    const headers = {
      'Authorization': `Bearer ${apiToken}`,
      'Content-Type': 'application/json',
    };
    if (useProxy()) headers['X-Token'] = apiToken;

    const resp = await fetch(fetchUrl, {
      method: 'POST',
      headers,
      signal: aiAbortController.signal,
      body: JSON.stringify({
        model: aiSelectedModel,
        messages: [
          { role: 'system', content: systemPrompt },
          ...aiConversationHistory,
          { role: 'user', content: userMsg },
        ],
        temperature: 0.3,
        max_tokens: 1024,
      }),
    });

    if (!resp.ok) {
      const errText = await resp.text();
      if (resp.status === 429) throw new Error('Rate limited — please wait and try again.');
      throw new Error(`${resp.status}: ${errText.substring(0, 200)}`);
    }

    const data = await resp.json();
    const reply = data.choices?.[0]?.message?.content || 'No response received.';

    if (typing) typing.remove();
    addAiMessage(reply, 'assistant');

    // Track conversation for multi-turn context (keep last 6 turns)
    aiConversationHistory.push({ role: 'user', content: userMsg });
    aiConversationHistory.push({ role: 'assistant', content: reply });
    if (aiConversationHistory.length > 12) aiConversationHistory = aiConversationHistory.slice(-12);

  } catch (e) {
    if (typing) typing.remove();
    if (e.name === 'AbortError') {
      addAiMessage('Request timed out or was cancelled. Please try again.', 'error');
    } else {
      addAiMessage('Error: ' + e.message, 'error');
      toast('AI request failed: ' + e.message, 'error');
    }
  } finally {
    clearTimeout(timeoutId);
    aiAbortController = null;
    if (sendBtn) sendBtn.disabled = false;
    if (input) input.focus();
  }
}

function clearAiConversation() {
  aiConversationHistory = [];
  const container = document.getElementById('aiMessages');
  if (container) {
    container.innerHTML = '<div class="ai-welcome"><svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#a855f7" stroke-width="1.5" stroke-linecap="round"><path d="M12 2l2.09 6.26L20 10.27l-4.91 3.82L16.18 22 12 18.27 7.82 22l1.09-7.91L4 10.27l5.91-2.01L12 2z"/></svg><div>Ask about your cloud infrastructure — topology, security posture, billing, traffic, or flow log analysis.<br>The AI receives a context summary of all loaded data.</div></div>';
  }
}

// Show AI button when flow logs are loaded
function updateAiButtonVisibility() {
  const btn = document.getElementById('aiToggleBtn');
  if (btn) btn.style.display = (graphData.nodes.length > 0 || flAllRecords.length > 0) ? '' : 'none';
}

// ============================== GLOBAL KEYBOARD SHORTCUTS ==============================
document.addEventListener('keydown', (e) => {
  const tag = document.activeElement?.tagName?.toLowerCase();
  const isInput = tag === 'input' || tag === 'textarea' || tag === 'select';

  if (e.key === 'Escape') {
    if (document.getElementById('localeMenu')?.classList.contains('open')) { closeLocaleMenu(); return; }
    if (document.getElementById('exportDropdown')?.classList.contains('open')) { closeExportMenu(); return; }
    if (document.getElementById('flowlogDropdown')?.classList.contains('open')) { closeFlowLogMenu(); return; }
    const tableOv = document.getElementById('tableOverlay');
    if (tableOv && tableOv.style.display !== 'none') { closeTableView(); return; }
    const secOv = document.getElementById('securityOverlay');
    if (secOv && secOv.style.display !== 'none') { closeSecurityOverlay(); return; }
    const flOv = document.getElementById('flowlogOverlay');
    if (flOv && flOv.style.display !== 'none') { closeFlowLogExplorer(); return; }
    if (aiPanelOpen) { closeAiPanel(); return; }
    if (heatmapActive) { clearHeatmap(); return; }
    document.getElementById('shortcutsOverlay').style.display = 'none';
    closeDetail();
    clearSearch();
    return;
  }
  if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
    e.preventDefault();
    const searchInput = document.getElementById('searchInput');
    if (searchInput && document.getElementById('searchSection').style.display !== 'none') {
      searchInput.focus();
    }
    return;
  }
  if (isInput) return;
  if (e.key === '?' || e.key === '/') { document.getElementById('shortcutsOverlay').style.display = ''; }
  else if (e.key === '+' || e.key === '=') zoomIn();
  else if (e.key === '-') zoomOut();
  else if (e.key === 'f' || e.key === 'F') resetView();
  else if (e.key === 'l' || e.key === 'L') toggleLabels();
  else if (e.key === 'i' || e.key === 'I') toggleIPView();
  else if (e.key === 'c' || e.key === 'C') toggleComputeView();
  else if (e.key === 'h' || e.key === 'H') toggleHighlightsOverlay();
  else if (e.key === 'm' || e.key === 'M') toggleMapBackground();
  else if (e.key === 'g' || e.key === 'G') setViewMode('map');
  else if (e.key === 't' || e.key === 'T') openTableView();
  else if (e.key === 's' || e.key === 'S') openSecurityOverlay();
  else if (e.key === 'w' || e.key === 'W') openFlowLogExplorer();
  else if (e.key === 'x' || e.key === 'X') toggleHeatmap();
  else if (e.key === 'b' || e.key === 'B') { setHeatmapMode('billing'); if (!heatmapActive) toggleHeatmap(); else applyHeatmap(); }
  else if (e.key === 'r' || e.key === 'R') resetView();
  else if (e.key === 'a' || e.key === 'A') { if (graphData.nodes.length > 0 || flAllRecords.length > 0) toggleAiPanel(); }
});
</script>
</body>
</html>
